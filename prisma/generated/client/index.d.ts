
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Movie
 * 
 */
export type Movie = $Result.DefaultSelection<Prisma.$MoviePayload>
/**
 * Model Platform
 * 
 */
export type Platform = $Result.DefaultSelection<Prisma.$PlatformPayload>
/**
 * Model Region
 * 
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model Availability
 * 
 */
export type Availability = $Result.DefaultSelection<Prisma.$AvailabilityPayload>
/**
 * Model ContentVersion
 * 
 */
export type ContentVersion = $Result.DefaultSelection<Prisma.$ContentVersionPayload>
/**
 * Model ContentReview
 * 
 */
export type ContentReview = $Result.DefaultSelection<Prisma.$ContentReviewPayload>
/**
 * Model ContentUpdateTask
 * 
 */
export type ContentUpdateTask = $Result.DefaultSelection<Prisma.$ContentUpdateTaskPayload>
/**
 * Model ContentQualityMetric
 * 
 */
export type ContentQualityMetric = $Result.DefaultSelection<Prisma.$ContentQualityMetricPayload>
/**
 * Model UserFeedback
 * 
 */
export type UserFeedback = $Result.DefaultSelection<Prisma.$UserFeedbackPayload>
/**
 * Model ContentSyncLog
 * 
 */
export type ContentSyncLog = $Result.DefaultSelection<Prisma.$ContentSyncLogPayload>
/**
 * Model Character
 * 
 */
export type Character = $Result.DefaultSelection<Prisma.$CharacterPayload>
/**
 * Model MovieCharacter
 * 
 */
export type MovieCharacter = $Result.DefaultSelection<Prisma.$MovieCharacterPayload>
/**
 * Model CrewMember
 * 
 */
export type CrewMember = $Result.DefaultSelection<Prisma.$CrewMemberPayload>
/**
 * Model MovieCrew
 * 
 */
export type MovieCrew = $Result.DefaultSelection<Prisma.$MovieCrewPayload>
/**
 * Model MovieReview
 * 
 */
export type MovieReview = $Result.DefaultSelection<Prisma.$MovieReviewPayload>
/**
 * Model WatchGuide
 * 
 */
export type WatchGuide = $Result.DefaultSelection<Prisma.$WatchGuidePayload>
/**
 * Model WatchGuideMovie
 * 
 */
export type WatchGuideMovie = $Result.DefaultSelection<Prisma.$WatchGuideMoviePayload>
/**
 * Model MediaContent
 * 
 */
export type MediaContent = $Result.DefaultSelection<Prisma.$MediaContentPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model MovieTag
 * 
 */
export type MovieTag = $Result.DefaultSelection<Prisma.$MovieTagPayload>
/**
 * Model UserFavorite
 * 
 */
export type UserFavorite = $Result.DefaultSelection<Prisma.$UserFavoritePayload>
/**
 * Model MovieStats
 * 
 */
export type MovieStats = $Result.DefaultSelection<Prisma.$MovieStatsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PlatformType: {
  STREAMING: 'STREAMING',
  RENTAL: 'RENTAL',
  PURCHASE: 'PURCHASE',
  FREE: 'FREE',
  CINEMA: 'CINEMA',
  PHYSICAL: 'PHYSICAL'
};

export type PlatformType = (typeof PlatformType)[keyof typeof PlatformType]


export const AvailabilityType: {
  SUBSCRIPTION: 'SUBSCRIPTION',
  RENT: 'RENT',
  BUY: 'BUY',
  FREE: 'FREE',
  CINEMA: 'CINEMA',
  LIBRARY: 'LIBRARY',
  DVD: 'DVD'
};

export type AvailabilityType = (typeof AvailabilityType)[keyof typeof AvailabilityType]


export const ChangeType: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  RESTORE: 'RESTORE'
};

export type ChangeType = (typeof ChangeType)[keyof typeof ChangeType]


export const ReviewStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  NEEDS_REVISION: 'NEEDS_REVISION'
};

export type ReviewStatus = (typeof ReviewStatus)[keyof typeof ReviewStatus]


export const TaskType: {
  MOVIE_UPDATE: 'MOVIE_UPDATE',
  AVAILABILITY_CHECK: 'AVAILABILITY_CHECK',
  PLATFORM_SYNC: 'PLATFORM_SYNC',
  REGION_UPDATE: 'REGION_UPDATE',
  QUALITY_CHECK: 'QUALITY_CHECK',
  CONTENT_REVIEW: 'CONTENT_REVIEW'
};

export type TaskType = (typeof TaskType)[keyof typeof TaskType]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const TaskStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const FeedbackType: {
  INCORRECT_INFO: 'INCORRECT_INFO',
  MISSING_INFO: 'MISSING_INFO',
  BROKEN_LINK: 'BROKEN_LINK',
  SUGGESTION: 'SUGGESTION',
  BUG_REPORT: 'BUG_REPORT',
  OTHER: 'OTHER'
};

export type FeedbackType = (typeof FeedbackType)[keyof typeof FeedbackType]


export const SyncType: {
  FULL_SYNC: 'FULL_SYNC',
  INCREMENTAL_SYNC: 'INCREMENTAL_SYNC',
  MANUAL_SYNC: 'MANUAL_SYNC',
  SCHEDULED_SYNC: 'SCHEDULED_SYNC'
};

export type SyncType = (typeof SyncType)[keyof typeof SyncType]


export const SyncStatus: {
  STARTED: 'STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type SyncStatus = (typeof SyncStatus)[keyof typeof SyncStatus]


export const CrewRole: {
  DIRECTOR: 'DIRECTOR',
  PRODUCER: 'PRODUCER',
  WRITER: 'WRITER',
  ANIMATOR: 'ANIMATOR',
  COMPOSER: 'COMPOSER',
  VOICE_DIRECTOR: 'VOICE_DIRECTOR',
  ART_DIRECTOR: 'ART_DIRECTOR',
  SOUND_DESIGNER: 'SOUND_DESIGNER',
  EDITOR: 'EDITOR',
  OTHER: 'OTHER'
};

export type CrewRole = (typeof CrewRole)[keyof typeof CrewRole]


export const ReviewType: {
  PROFESSIONAL: 'PROFESSIONAL',
  EDITORIAL: 'EDITORIAL',
  ANALYSIS: 'ANALYSIS',
  BEHIND_SCENES: 'BEHIND_SCENES',
  TRIVIA: 'TRIVIA'
};

export type ReviewType = (typeof ReviewType)[keyof typeof ReviewType]


export const GuideType: {
  CHRONOLOGICAL: 'CHRONOLOGICAL',
  THEMATIC: 'THEMATIC',
  BEGINNER: 'BEGINNER',
  ADVANCED: 'ADVANCED',
  FAMILY: 'FAMILY',
  SEASONAL: 'SEASONAL'
};

export type GuideType = (typeof GuideType)[keyof typeof GuideType]


export const MediaType: {
  TRAILER: 'TRAILER',
  CLIP: 'CLIP',
  BEHIND_SCENES: 'BEHIND_SCENES',
  INTERVIEW: 'INTERVIEW',
  SOUNDTRACK: 'SOUNDTRACK',
  ARTWORK: 'ARTWORK',
  POSTER: 'POSTER',
  WALLPAPER: 'WALLPAPER'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]

}

export type PlatformType = $Enums.PlatformType

export const PlatformType: typeof $Enums.PlatformType

export type AvailabilityType = $Enums.AvailabilityType

export const AvailabilityType: typeof $Enums.AvailabilityType

export type ChangeType = $Enums.ChangeType

export const ChangeType: typeof $Enums.ChangeType

export type ReviewStatus = $Enums.ReviewStatus

export const ReviewStatus: typeof $Enums.ReviewStatus

export type TaskType = $Enums.TaskType

export const TaskType: typeof $Enums.TaskType

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type FeedbackType = $Enums.FeedbackType

export const FeedbackType: typeof $Enums.FeedbackType

export type SyncType = $Enums.SyncType

export const SyncType: typeof $Enums.SyncType

export type SyncStatus = $Enums.SyncStatus

export const SyncStatus: typeof $Enums.SyncStatus

export type CrewRole = $Enums.CrewRole

export const CrewRole: typeof $Enums.CrewRole

export type ReviewType = $Enums.ReviewType

export const ReviewType: typeof $Enums.ReviewType

export type GuideType = $Enums.GuideType

export const GuideType: typeof $Enums.GuideType

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Movies
 * const movies = await prisma.movie.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Movies
   * const movies = await prisma.movie.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.movie`: Exposes CRUD operations for the **Movie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movies
    * const movies = await prisma.movie.findMany()
    * ```
    */
  get movie(): Prisma.MovieDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platform`: Exposes CRUD operations for the **Platform** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Platforms
    * const platforms = await prisma.platform.findMany()
    * ```
    */
  get platform(): Prisma.PlatformDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.availability`: Exposes CRUD operations for the **Availability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Availabilities
    * const availabilities = await prisma.availability.findMany()
    * ```
    */
  get availability(): Prisma.AvailabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentVersion`: Exposes CRUD operations for the **ContentVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentVersions
    * const contentVersions = await prisma.contentVersion.findMany()
    * ```
    */
  get contentVersion(): Prisma.ContentVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentReview`: Exposes CRUD operations for the **ContentReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentReviews
    * const contentReviews = await prisma.contentReview.findMany()
    * ```
    */
  get contentReview(): Prisma.ContentReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentUpdateTask`: Exposes CRUD operations for the **ContentUpdateTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentUpdateTasks
    * const contentUpdateTasks = await prisma.contentUpdateTask.findMany()
    * ```
    */
  get contentUpdateTask(): Prisma.ContentUpdateTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentQualityMetric`: Exposes CRUD operations for the **ContentQualityMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentQualityMetrics
    * const contentQualityMetrics = await prisma.contentQualityMetric.findMany()
    * ```
    */
  get contentQualityMetric(): Prisma.ContentQualityMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFeedback`: Exposes CRUD operations for the **UserFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFeedbacks
    * const userFeedbacks = await prisma.userFeedback.findMany()
    * ```
    */
  get userFeedback(): Prisma.UserFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentSyncLog`: Exposes CRUD operations for the **ContentSyncLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentSyncLogs
    * const contentSyncLogs = await prisma.contentSyncLog.findMany()
    * ```
    */
  get contentSyncLog(): Prisma.ContentSyncLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character`: Exposes CRUD operations for the **Character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.CharacterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.movieCharacter`: Exposes CRUD operations for the **MovieCharacter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieCharacters
    * const movieCharacters = await prisma.movieCharacter.findMany()
    * ```
    */
  get movieCharacter(): Prisma.MovieCharacterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crewMember`: Exposes CRUD operations for the **CrewMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrewMembers
    * const crewMembers = await prisma.crewMember.findMany()
    * ```
    */
  get crewMember(): Prisma.CrewMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.movieCrew`: Exposes CRUD operations for the **MovieCrew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieCrews
    * const movieCrews = await prisma.movieCrew.findMany()
    * ```
    */
  get movieCrew(): Prisma.MovieCrewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.movieReview`: Exposes CRUD operations for the **MovieReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieReviews
    * const movieReviews = await prisma.movieReview.findMany()
    * ```
    */
  get movieReview(): Prisma.MovieReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.watchGuide`: Exposes CRUD operations for the **WatchGuide** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchGuides
    * const watchGuides = await prisma.watchGuide.findMany()
    * ```
    */
  get watchGuide(): Prisma.WatchGuideDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.watchGuideMovie`: Exposes CRUD operations for the **WatchGuideMovie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchGuideMovies
    * const watchGuideMovies = await prisma.watchGuideMovie.findMany()
    * ```
    */
  get watchGuideMovie(): Prisma.WatchGuideMovieDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mediaContent`: Exposes CRUD operations for the **MediaContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaContents
    * const mediaContents = await prisma.mediaContent.findMany()
    * ```
    */
  get mediaContent(): Prisma.MediaContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.movieTag`: Exposes CRUD operations for the **MovieTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieTags
    * const movieTags = await prisma.movieTag.findMany()
    * ```
    */
  get movieTag(): Prisma.MovieTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFavorite`: Exposes CRUD operations for the **UserFavorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFavorites
    * const userFavorites = await prisma.userFavorite.findMany()
    * ```
    */
  get userFavorite(): Prisma.UserFavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.movieStats`: Exposes CRUD operations for the **MovieStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieStats
    * const movieStats = await prisma.movieStats.findMany()
    * ```
    */
  get movieStats(): Prisma.MovieStatsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Movie: 'Movie',
    Platform: 'Platform',
    Region: 'Region',
    Availability: 'Availability',
    ContentVersion: 'ContentVersion',
    ContentReview: 'ContentReview',
    ContentUpdateTask: 'ContentUpdateTask',
    ContentQualityMetric: 'ContentQualityMetric',
    UserFeedback: 'UserFeedback',
    ContentSyncLog: 'ContentSyncLog',
    Character: 'Character',
    MovieCharacter: 'MovieCharacter',
    CrewMember: 'CrewMember',
    MovieCrew: 'MovieCrew',
    MovieReview: 'MovieReview',
    WatchGuide: 'WatchGuide',
    WatchGuideMovie: 'WatchGuideMovie',
    MediaContent: 'MediaContent',
    Tag: 'Tag',
    MovieTag: 'MovieTag',
    UserFavorite: 'UserFavorite',
    MovieStats: 'MovieStats'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "movie" | "platform" | "region" | "availability" | "contentVersion" | "contentReview" | "contentUpdateTask" | "contentQualityMetric" | "userFeedback" | "contentSyncLog" | "character" | "movieCharacter" | "crewMember" | "movieCrew" | "movieReview" | "watchGuide" | "watchGuideMovie" | "mediaContent" | "tag" | "movieTag" | "userFavorite" | "movieStats"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Movie: {
        payload: Prisma.$MoviePayload<ExtArgs>
        fields: Prisma.MovieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          findFirst: {
            args: Prisma.MovieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          findMany: {
            args: Prisma.MovieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>[]
          }
          create: {
            args: Prisma.MovieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          createMany: {
            args: Prisma.MovieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>[]
          }
          delete: {
            args: Prisma.MovieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          update: {
            args: Prisma.MovieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          deleteMany: {
            args: Prisma.MovieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MovieUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>[]
          }
          upsert: {
            args: Prisma.MovieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          aggregate: {
            args: Prisma.MovieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovie>
          }
          groupBy: {
            args: Prisma.MovieGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieCountArgs<ExtArgs>
            result: $Utils.Optional<MovieCountAggregateOutputType> | number
          }
        }
      }
      Platform: {
        payload: Prisma.$PlatformPayload<ExtArgs>
        fields: Prisma.PlatformFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          findFirst: {
            args: Prisma.PlatformFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          findMany: {
            args: Prisma.PlatformFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          create: {
            args: Prisma.PlatformCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          createMany: {
            args: Prisma.PlatformCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          delete: {
            args: Prisma.PlatformDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          update: {
            args: Prisma.PlatformUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          deleteMany: {
            args: Prisma.PlatformDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlatformUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          upsert: {
            args: Prisma.PlatformUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          aggregate: {
            args: Prisma.PlatformAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatform>
          }
          groupBy: {
            args: Prisma.PlatformGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformCountAggregateOutputType> | number
          }
        }
      }
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      Availability: {
        payload: Prisma.$AvailabilityPayload<ExtArgs>
        fields: Prisma.AvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findFirst: {
            args: Prisma.AvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findMany: {
            args: Prisma.AvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          create: {
            args: Prisma.AvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          createMany: {
            args: Prisma.AvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          delete: {
            args: Prisma.AvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          update: {
            args: Prisma.AvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.AvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvailabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          upsert: {
            args: Prisma.AvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          aggregate: {
            args: Prisma.AvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvailability>
          }
          groupBy: {
            args: Prisma.AvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityCountAggregateOutputType> | number
          }
        }
      }
      ContentVersion: {
        payload: Prisma.$ContentVersionPayload<ExtArgs>
        fields: Prisma.ContentVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>
          }
          findFirst: {
            args: Prisma.ContentVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>
          }
          findMany: {
            args: Prisma.ContentVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>[]
          }
          create: {
            args: Prisma.ContentVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>
          }
          createMany: {
            args: Prisma.ContentVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>[]
          }
          delete: {
            args: Prisma.ContentVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>
          }
          update: {
            args: Prisma.ContentVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>
          }
          deleteMany: {
            args: Prisma.ContentVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>[]
          }
          upsert: {
            args: Prisma.ContentVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>
          }
          aggregate: {
            args: Prisma.ContentVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentVersion>
          }
          groupBy: {
            args: Prisma.ContentVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentVersionCountArgs<ExtArgs>
            result: $Utils.Optional<ContentVersionCountAggregateOutputType> | number
          }
        }
      }
      ContentReview: {
        payload: Prisma.$ContentReviewPayload<ExtArgs>
        fields: Prisma.ContentReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReviewPayload>
          }
          findFirst: {
            args: Prisma.ContentReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReviewPayload>
          }
          findMany: {
            args: Prisma.ContentReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReviewPayload>[]
          }
          create: {
            args: Prisma.ContentReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReviewPayload>
          }
          createMany: {
            args: Prisma.ContentReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReviewPayload>[]
          }
          delete: {
            args: Prisma.ContentReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReviewPayload>
          }
          update: {
            args: Prisma.ContentReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReviewPayload>
          }
          deleteMany: {
            args: Prisma.ContentReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReviewPayload>[]
          }
          upsert: {
            args: Prisma.ContentReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReviewPayload>
          }
          aggregate: {
            args: Prisma.ContentReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentReview>
          }
          groupBy: {
            args: Prisma.ContentReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ContentReviewCountAggregateOutputType> | number
          }
        }
      }
      ContentUpdateTask: {
        payload: Prisma.$ContentUpdateTaskPayload<ExtArgs>
        fields: Prisma.ContentUpdateTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentUpdateTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUpdateTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentUpdateTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUpdateTaskPayload>
          }
          findFirst: {
            args: Prisma.ContentUpdateTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUpdateTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentUpdateTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUpdateTaskPayload>
          }
          findMany: {
            args: Prisma.ContentUpdateTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUpdateTaskPayload>[]
          }
          create: {
            args: Prisma.ContentUpdateTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUpdateTaskPayload>
          }
          createMany: {
            args: Prisma.ContentUpdateTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentUpdateTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUpdateTaskPayload>[]
          }
          delete: {
            args: Prisma.ContentUpdateTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUpdateTaskPayload>
          }
          update: {
            args: Prisma.ContentUpdateTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUpdateTaskPayload>
          }
          deleteMany: {
            args: Prisma.ContentUpdateTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentUpdateTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentUpdateTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUpdateTaskPayload>[]
          }
          upsert: {
            args: Prisma.ContentUpdateTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUpdateTaskPayload>
          }
          aggregate: {
            args: Prisma.ContentUpdateTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentUpdateTask>
          }
          groupBy: {
            args: Prisma.ContentUpdateTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentUpdateTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentUpdateTaskCountArgs<ExtArgs>
            result: $Utils.Optional<ContentUpdateTaskCountAggregateOutputType> | number
          }
        }
      }
      ContentQualityMetric: {
        payload: Prisma.$ContentQualityMetricPayload<ExtArgs>
        fields: Prisma.ContentQualityMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentQualityMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentQualityMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentQualityMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentQualityMetricPayload>
          }
          findFirst: {
            args: Prisma.ContentQualityMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentQualityMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentQualityMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentQualityMetricPayload>
          }
          findMany: {
            args: Prisma.ContentQualityMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentQualityMetricPayload>[]
          }
          create: {
            args: Prisma.ContentQualityMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentQualityMetricPayload>
          }
          createMany: {
            args: Prisma.ContentQualityMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentQualityMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentQualityMetricPayload>[]
          }
          delete: {
            args: Prisma.ContentQualityMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentQualityMetricPayload>
          }
          update: {
            args: Prisma.ContentQualityMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentQualityMetricPayload>
          }
          deleteMany: {
            args: Prisma.ContentQualityMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentQualityMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentQualityMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentQualityMetricPayload>[]
          }
          upsert: {
            args: Prisma.ContentQualityMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentQualityMetricPayload>
          }
          aggregate: {
            args: Prisma.ContentQualityMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentQualityMetric>
          }
          groupBy: {
            args: Prisma.ContentQualityMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentQualityMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentQualityMetricCountArgs<ExtArgs>
            result: $Utils.Optional<ContentQualityMetricCountAggregateOutputType> | number
          }
        }
      }
      UserFeedback: {
        payload: Prisma.$UserFeedbackPayload<ExtArgs>
        fields: Prisma.UserFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          findFirst: {
            args: Prisma.UserFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          findMany: {
            args: Prisma.UserFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>[]
          }
          create: {
            args: Prisma.UserFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          createMany: {
            args: Prisma.UserFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>[]
          }
          delete: {
            args: Prisma.UserFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          update: {
            args: Prisma.UserFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.UserFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>[]
          }
          upsert: {
            args: Prisma.UserFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          aggregate: {
            args: Prisma.UserFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFeedback>
          }
          groupBy: {
            args: Prisma.UserFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<UserFeedbackCountAggregateOutputType> | number
          }
        }
      }
      ContentSyncLog: {
        payload: Prisma.$ContentSyncLogPayload<ExtArgs>
        fields: Prisma.ContentSyncLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentSyncLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSyncLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentSyncLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSyncLogPayload>
          }
          findFirst: {
            args: Prisma.ContentSyncLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSyncLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentSyncLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSyncLogPayload>
          }
          findMany: {
            args: Prisma.ContentSyncLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSyncLogPayload>[]
          }
          create: {
            args: Prisma.ContentSyncLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSyncLogPayload>
          }
          createMany: {
            args: Prisma.ContentSyncLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentSyncLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSyncLogPayload>[]
          }
          delete: {
            args: Prisma.ContentSyncLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSyncLogPayload>
          }
          update: {
            args: Prisma.ContentSyncLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSyncLogPayload>
          }
          deleteMany: {
            args: Prisma.ContentSyncLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentSyncLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentSyncLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSyncLogPayload>[]
          }
          upsert: {
            args: Prisma.ContentSyncLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSyncLogPayload>
          }
          aggregate: {
            args: Prisma.ContentSyncLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentSyncLog>
          }
          groupBy: {
            args: Prisma.ContentSyncLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentSyncLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentSyncLogCountArgs<ExtArgs>
            result: $Utils.Optional<ContentSyncLogCountAggregateOutputType> | number
          }
        }
      }
      Character: {
        payload: Prisma.$CharacterPayload<ExtArgs>
        fields: Prisma.CharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findFirst: {
            args: Prisma.CharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findMany: {
            args: Prisma.CharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          create: {
            args: Prisma.CharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          createMany: {
            args: Prisma.CharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          delete: {
            args: Prisma.CharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          update: {
            args: Prisma.CharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          deleteMany: {
            args: Prisma.CharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          upsert: {
            args: Prisma.CharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          aggregate: {
            args: Prisma.CharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter>
          }
          groupBy: {
            args: Prisma.CharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterCountAggregateOutputType> | number
          }
        }
      }
      MovieCharacter: {
        payload: Prisma.$MovieCharacterPayload<ExtArgs>
        fields: Prisma.MovieCharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieCharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieCharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCharacterPayload>
          }
          findFirst: {
            args: Prisma.MovieCharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieCharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCharacterPayload>
          }
          findMany: {
            args: Prisma.MovieCharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCharacterPayload>[]
          }
          create: {
            args: Prisma.MovieCharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCharacterPayload>
          }
          createMany: {
            args: Prisma.MovieCharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieCharacterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCharacterPayload>[]
          }
          delete: {
            args: Prisma.MovieCharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCharacterPayload>
          }
          update: {
            args: Prisma.MovieCharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCharacterPayload>
          }
          deleteMany: {
            args: Prisma.MovieCharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieCharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MovieCharacterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCharacterPayload>[]
          }
          upsert: {
            args: Prisma.MovieCharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCharacterPayload>
          }
          aggregate: {
            args: Prisma.MovieCharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieCharacter>
          }
          groupBy: {
            args: Prisma.MovieCharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieCharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieCharacterCountArgs<ExtArgs>
            result: $Utils.Optional<MovieCharacterCountAggregateOutputType> | number
          }
        }
      }
      CrewMember: {
        payload: Prisma.$CrewMemberPayload<ExtArgs>
        fields: Prisma.CrewMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewMemberPayload>
          }
          findFirst: {
            args: Prisma.CrewMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewMemberPayload>
          }
          findMany: {
            args: Prisma.CrewMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewMemberPayload>[]
          }
          create: {
            args: Prisma.CrewMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewMemberPayload>
          }
          createMany: {
            args: Prisma.CrewMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrewMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewMemberPayload>[]
          }
          delete: {
            args: Prisma.CrewMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewMemberPayload>
          }
          update: {
            args: Prisma.CrewMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewMemberPayload>
          }
          deleteMany: {
            args: Prisma.CrewMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrewMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CrewMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewMemberPayload>[]
          }
          upsert: {
            args: Prisma.CrewMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewMemberPayload>
          }
          aggregate: {
            args: Prisma.CrewMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrewMember>
          }
          groupBy: {
            args: Prisma.CrewMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrewMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewMemberCountArgs<ExtArgs>
            result: $Utils.Optional<CrewMemberCountAggregateOutputType> | number
          }
        }
      }
      MovieCrew: {
        payload: Prisma.$MovieCrewPayload<ExtArgs>
        fields: Prisma.MovieCrewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieCrewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCrewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieCrewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCrewPayload>
          }
          findFirst: {
            args: Prisma.MovieCrewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCrewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieCrewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCrewPayload>
          }
          findMany: {
            args: Prisma.MovieCrewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCrewPayload>[]
          }
          create: {
            args: Prisma.MovieCrewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCrewPayload>
          }
          createMany: {
            args: Prisma.MovieCrewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieCrewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCrewPayload>[]
          }
          delete: {
            args: Prisma.MovieCrewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCrewPayload>
          }
          update: {
            args: Prisma.MovieCrewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCrewPayload>
          }
          deleteMany: {
            args: Prisma.MovieCrewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieCrewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MovieCrewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCrewPayload>[]
          }
          upsert: {
            args: Prisma.MovieCrewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCrewPayload>
          }
          aggregate: {
            args: Prisma.MovieCrewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieCrew>
          }
          groupBy: {
            args: Prisma.MovieCrewGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieCrewGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieCrewCountArgs<ExtArgs>
            result: $Utils.Optional<MovieCrewCountAggregateOutputType> | number
          }
        }
      }
      MovieReview: {
        payload: Prisma.$MovieReviewPayload<ExtArgs>
        fields: Prisma.MovieReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieReviewPayload>
          }
          findFirst: {
            args: Prisma.MovieReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieReviewPayload>
          }
          findMany: {
            args: Prisma.MovieReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieReviewPayload>[]
          }
          create: {
            args: Prisma.MovieReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieReviewPayload>
          }
          createMany: {
            args: Prisma.MovieReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieReviewPayload>[]
          }
          delete: {
            args: Prisma.MovieReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieReviewPayload>
          }
          update: {
            args: Prisma.MovieReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieReviewPayload>
          }
          deleteMany: {
            args: Prisma.MovieReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MovieReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieReviewPayload>[]
          }
          upsert: {
            args: Prisma.MovieReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieReviewPayload>
          }
          aggregate: {
            args: Prisma.MovieReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieReview>
          }
          groupBy: {
            args: Prisma.MovieReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieReviewCountArgs<ExtArgs>
            result: $Utils.Optional<MovieReviewCountAggregateOutputType> | number
          }
        }
      }
      WatchGuide: {
        payload: Prisma.$WatchGuidePayload<ExtArgs>
        fields: Prisma.WatchGuideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WatchGuideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchGuideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuidePayload>
          }
          findFirst: {
            args: Prisma.WatchGuideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchGuideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuidePayload>
          }
          findMany: {
            args: Prisma.WatchGuideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuidePayload>[]
          }
          create: {
            args: Prisma.WatchGuideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuidePayload>
          }
          createMany: {
            args: Prisma.WatchGuideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WatchGuideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuidePayload>[]
          }
          delete: {
            args: Prisma.WatchGuideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuidePayload>
          }
          update: {
            args: Prisma.WatchGuideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuidePayload>
          }
          deleteMany: {
            args: Prisma.WatchGuideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WatchGuideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WatchGuideUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuidePayload>[]
          }
          upsert: {
            args: Prisma.WatchGuideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuidePayload>
          }
          aggregate: {
            args: Prisma.WatchGuideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWatchGuide>
          }
          groupBy: {
            args: Prisma.WatchGuideGroupByArgs<ExtArgs>
            result: $Utils.Optional<WatchGuideGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchGuideCountArgs<ExtArgs>
            result: $Utils.Optional<WatchGuideCountAggregateOutputType> | number
          }
        }
      }
      WatchGuideMovie: {
        payload: Prisma.$WatchGuideMoviePayload<ExtArgs>
        fields: Prisma.WatchGuideMovieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WatchGuideMovieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuideMoviePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchGuideMovieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuideMoviePayload>
          }
          findFirst: {
            args: Prisma.WatchGuideMovieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuideMoviePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchGuideMovieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuideMoviePayload>
          }
          findMany: {
            args: Prisma.WatchGuideMovieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuideMoviePayload>[]
          }
          create: {
            args: Prisma.WatchGuideMovieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuideMoviePayload>
          }
          createMany: {
            args: Prisma.WatchGuideMovieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WatchGuideMovieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuideMoviePayload>[]
          }
          delete: {
            args: Prisma.WatchGuideMovieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuideMoviePayload>
          }
          update: {
            args: Prisma.WatchGuideMovieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuideMoviePayload>
          }
          deleteMany: {
            args: Prisma.WatchGuideMovieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WatchGuideMovieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WatchGuideMovieUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuideMoviePayload>[]
          }
          upsert: {
            args: Prisma.WatchGuideMovieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchGuideMoviePayload>
          }
          aggregate: {
            args: Prisma.WatchGuideMovieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWatchGuideMovie>
          }
          groupBy: {
            args: Prisma.WatchGuideMovieGroupByArgs<ExtArgs>
            result: $Utils.Optional<WatchGuideMovieGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchGuideMovieCountArgs<ExtArgs>
            result: $Utils.Optional<WatchGuideMovieCountAggregateOutputType> | number
          }
        }
      }
      MediaContent: {
        payload: Prisma.$MediaContentPayload<ExtArgs>
        fields: Prisma.MediaContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaContentPayload>
          }
          findFirst: {
            args: Prisma.MediaContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaContentPayload>
          }
          findMany: {
            args: Prisma.MediaContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaContentPayload>[]
          }
          create: {
            args: Prisma.MediaContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaContentPayload>
          }
          createMany: {
            args: Prisma.MediaContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaContentPayload>[]
          }
          delete: {
            args: Prisma.MediaContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaContentPayload>
          }
          update: {
            args: Prisma.MediaContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaContentPayload>
          }
          deleteMany: {
            args: Prisma.MediaContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaContentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaContentPayload>[]
          }
          upsert: {
            args: Prisma.MediaContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaContentPayload>
          }
          aggregate: {
            args: Prisma.MediaContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaContent>
          }
          groupBy: {
            args: Prisma.MediaContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaContentCountArgs<ExtArgs>
            result: $Utils.Optional<MediaContentCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      MovieTag: {
        payload: Prisma.$MovieTagPayload<ExtArgs>
        fields: Prisma.MovieTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>
          }
          findFirst: {
            args: Prisma.MovieTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>
          }
          findMany: {
            args: Prisma.MovieTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>[]
          }
          create: {
            args: Prisma.MovieTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>
          }
          createMany: {
            args: Prisma.MovieTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>[]
          }
          delete: {
            args: Prisma.MovieTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>
          }
          update: {
            args: Prisma.MovieTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>
          }
          deleteMany: {
            args: Prisma.MovieTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MovieTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>[]
          }
          upsert: {
            args: Prisma.MovieTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>
          }
          aggregate: {
            args: Prisma.MovieTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieTag>
          }
          groupBy: {
            args: Prisma.MovieTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieTagCountArgs<ExtArgs>
            result: $Utils.Optional<MovieTagCountAggregateOutputType> | number
          }
        }
      }
      UserFavorite: {
        payload: Prisma.$UserFavoritePayload<ExtArgs>
        fields: Prisma.UserFavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          findFirst: {
            args: Prisma.UserFavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          findMany: {
            args: Prisma.UserFavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          create: {
            args: Prisma.UserFavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          createMany: {
            args: Prisma.UserFavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          delete: {
            args: Prisma.UserFavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          update: {
            args: Prisma.UserFavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          deleteMany: {
            args: Prisma.UserFavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          upsert: {
            args: Prisma.UserFavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          aggregate: {
            args: Prisma.UserFavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFavorite>
          }
          groupBy: {
            args: Prisma.UserFavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteCountAggregateOutputType> | number
          }
        }
      }
      MovieStats: {
        payload: Prisma.$MovieStatsPayload<ExtArgs>
        fields: Prisma.MovieStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieStatsPayload>
          }
          findFirst: {
            args: Prisma.MovieStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieStatsPayload>
          }
          findMany: {
            args: Prisma.MovieStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieStatsPayload>[]
          }
          create: {
            args: Prisma.MovieStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieStatsPayload>
          }
          createMany: {
            args: Prisma.MovieStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieStatsPayload>[]
          }
          delete: {
            args: Prisma.MovieStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieStatsPayload>
          }
          update: {
            args: Prisma.MovieStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieStatsPayload>
          }
          deleteMany: {
            args: Prisma.MovieStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MovieStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieStatsPayload>[]
          }
          upsert: {
            args: Prisma.MovieStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieStatsPayload>
          }
          aggregate: {
            args: Prisma.MovieStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieStats>
          }
          groupBy: {
            args: Prisma.MovieStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieStatsCountArgs<ExtArgs>
            result: $Utils.Optional<MovieStatsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    movie?: MovieOmit
    platform?: PlatformOmit
    region?: RegionOmit
    availability?: AvailabilityOmit
    contentVersion?: ContentVersionOmit
    contentReview?: ContentReviewOmit
    contentUpdateTask?: ContentUpdateTaskOmit
    contentQualityMetric?: ContentQualityMetricOmit
    userFeedback?: UserFeedbackOmit
    contentSyncLog?: ContentSyncLogOmit
    character?: CharacterOmit
    movieCharacter?: MovieCharacterOmit
    crewMember?: CrewMemberOmit
    movieCrew?: MovieCrewOmit
    movieReview?: MovieReviewOmit
    watchGuide?: WatchGuideOmit
    watchGuideMovie?: WatchGuideMovieOmit
    mediaContent?: MediaContentOmit
    tag?: TagOmit
    movieTag?: MovieTagOmit
    userFavorite?: UserFavoriteOmit
    movieStats?: MovieStatsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MovieCountOutputType
   */

  export type MovieCountOutputType = {
    availabilities: number
    movieCharacters: number
    movieCrew: number
    reviews: number
    guideMovies: number
    mediaContent: number
    movieTags: number
    favorites: number
  }

  export type MovieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availabilities?: boolean | MovieCountOutputTypeCountAvailabilitiesArgs
    movieCharacters?: boolean | MovieCountOutputTypeCountMovieCharactersArgs
    movieCrew?: boolean | MovieCountOutputTypeCountMovieCrewArgs
    reviews?: boolean | MovieCountOutputTypeCountReviewsArgs
    guideMovies?: boolean | MovieCountOutputTypeCountGuideMoviesArgs
    mediaContent?: boolean | MovieCountOutputTypeCountMediaContentArgs
    movieTags?: boolean | MovieCountOutputTypeCountMovieTagsArgs
    favorites?: boolean | MovieCountOutputTypeCountFavoritesArgs
  }

  // Custom InputTypes
  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCountOutputType
     */
    select?: MovieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountAvailabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountMovieCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieCharacterWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountMovieCrewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieCrewWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieReviewWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountGuideMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchGuideMovieWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountMediaContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaContentWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountMovieTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieTagWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
  }


  /**
   * Count Type PlatformCountOutputType
   */

  export type PlatformCountOutputType = {
    availabilities: number
  }

  export type PlatformCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availabilities?: boolean | PlatformCountOutputTypeCountAvailabilitiesArgs
  }

  // Custom InputTypes
  /**
   * PlatformCountOutputType without action
   */
  export type PlatformCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformCountOutputType
     */
    select?: PlatformCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlatformCountOutputType without action
   */
  export type PlatformCountOutputTypeCountAvailabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
  }


  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    availabilities: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availabilities?: boolean | RegionCountOutputTypeCountAvailabilitiesArgs
  }

  // Custom InputTypes
  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountAvailabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
  }


  /**
   * Count Type ContentVersionCountOutputType
   */

  export type ContentVersionCountOutputType = {
    reviews: number
  }

  export type ContentVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | ContentVersionCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * ContentVersionCountOutputType without action
   */
  export type ContentVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersionCountOutputType
     */
    select?: ContentVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentVersionCountOutputType without action
   */
  export type ContentVersionCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentReviewWhereInput
  }


  /**
   * Count Type CharacterCountOutputType
   */

  export type CharacterCountOutputType = {
    movieCharacters: number
  }

  export type CharacterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movieCharacters?: boolean | CharacterCountOutputTypeCountMovieCharactersArgs
  }

  // Custom InputTypes
  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterCountOutputType
     */
    select?: CharacterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountMovieCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieCharacterWhereInput
  }


  /**
   * Count Type CrewMemberCountOutputType
   */

  export type CrewMemberCountOutputType = {
    movieCrew: number
  }

  export type CrewMemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movieCrew?: boolean | CrewMemberCountOutputTypeCountMovieCrewArgs
  }

  // Custom InputTypes
  /**
   * CrewMemberCountOutputType without action
   */
  export type CrewMemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewMemberCountOutputType
     */
    select?: CrewMemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CrewMemberCountOutputType without action
   */
  export type CrewMemberCountOutputTypeCountMovieCrewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieCrewWhereInput
  }


  /**
   * Count Type WatchGuideCountOutputType
   */

  export type WatchGuideCountOutputType = {
    movies: number
  }

  export type WatchGuideCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movies?: boolean | WatchGuideCountOutputTypeCountMoviesArgs
  }

  // Custom InputTypes
  /**
   * WatchGuideCountOutputType without action
   */
  export type WatchGuideCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideCountOutputType
     */
    select?: WatchGuideCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WatchGuideCountOutputType without action
   */
  export type WatchGuideCountOutputTypeCountMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchGuideMovieWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    movieTags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movieTags?: boolean | TagCountOutputTypeCountMovieTagsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountMovieTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieTagWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Movie
   */

  export type AggregateMovie = {
    _count: MovieCountAggregateOutputType | null
    _avg: MovieAvgAggregateOutputType | null
    _sum: MovieSumAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  export type MovieAvgAggregateOutputType = {
    tmdbId: number | null
    year: number | null
    duration: number | null
    voteAverage: number | null
  }

  export type MovieSumAggregateOutputType = {
    tmdbId: number | null
    year: number | null
    duration: number | null
    voteAverage: number | null
  }

  export type MovieMinAggregateOutputType = {
    id: string | null
    tmdbId: number | null
    titleEn: string | null
    titleJa: string | null
    titleZh: string | null
    year: number | null
    director: string | null
    duration: number | null
    synopsis: string | null
    posterUrl: string | null
    backdropUrl: string | null
    voteAverage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovieMaxAggregateOutputType = {
    id: string | null
    tmdbId: number | null
    titleEn: string | null
    titleJa: string | null
    titleZh: string | null
    year: number | null
    director: string | null
    duration: number | null
    synopsis: string | null
    posterUrl: string | null
    backdropUrl: string | null
    voteAverage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovieCountAggregateOutputType = {
    id: number
    tmdbId: number
    titleEn: number
    titleJa: number
    titleZh: number
    year: number
    director: number
    duration: number
    synopsis: number
    posterUrl: number
    backdropUrl: number
    voteAverage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MovieAvgAggregateInputType = {
    tmdbId?: true
    year?: true
    duration?: true
    voteAverage?: true
  }

  export type MovieSumAggregateInputType = {
    tmdbId?: true
    year?: true
    duration?: true
    voteAverage?: true
  }

  export type MovieMinAggregateInputType = {
    id?: true
    tmdbId?: true
    titleEn?: true
    titleJa?: true
    titleZh?: true
    year?: true
    director?: true
    duration?: true
    synopsis?: true
    posterUrl?: true
    backdropUrl?: true
    voteAverage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovieMaxAggregateInputType = {
    id?: true
    tmdbId?: true
    titleEn?: true
    titleJa?: true
    titleZh?: true
    year?: true
    director?: true
    duration?: true
    synopsis?: true
    posterUrl?: true
    backdropUrl?: true
    voteAverage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovieCountAggregateInputType = {
    id?: true
    tmdbId?: true
    titleEn?: true
    titleJa?: true
    titleZh?: true
    year?: true
    director?: true
    duration?: true
    synopsis?: true
    posterUrl?: true
    backdropUrl?: true
    voteAverage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MovieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movie to aggregate.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Movies
    **/
    _count?: true | MovieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieMaxAggregateInputType
  }

  export type GetMovieAggregateType<T extends MovieAggregateArgs> = {
        [P in keyof T & keyof AggregateMovie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovie[P]>
      : GetScalarType<T[P], AggregateMovie[P]>
  }




  export type MovieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieWhereInput
    orderBy?: MovieOrderByWithAggregationInput | MovieOrderByWithAggregationInput[]
    by: MovieScalarFieldEnum[] | MovieScalarFieldEnum
    having?: MovieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieCountAggregateInputType | true
    _avg?: MovieAvgAggregateInputType
    _sum?: MovieSumAggregateInputType
    _min?: MovieMinAggregateInputType
    _max?: MovieMaxAggregateInputType
  }

  export type MovieGroupByOutputType = {
    id: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh: string | null
    year: number
    director: string | null
    duration: number | null
    synopsis: string | null
    posterUrl: string | null
    backdropUrl: string | null
    voteAverage: number | null
    createdAt: Date
    updatedAt: Date
    _count: MovieCountAggregateOutputType | null
    _avg: MovieAvgAggregateOutputType | null
    _sum: MovieSumAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  type GetMovieGroupByPayload<T extends MovieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieGroupByOutputType[P]>
            : GetScalarType<T[P], MovieGroupByOutputType[P]>
        }
      >
    >


  export type MovieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tmdbId?: boolean
    titleEn?: boolean
    titleJa?: boolean
    titleZh?: boolean
    year?: boolean
    director?: boolean
    duration?: boolean
    synopsis?: boolean
    posterUrl?: boolean
    backdropUrl?: boolean
    voteAverage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    availabilities?: boolean | Movie$availabilitiesArgs<ExtArgs>
    movieCharacters?: boolean | Movie$movieCharactersArgs<ExtArgs>
    movieCrew?: boolean | Movie$movieCrewArgs<ExtArgs>
    reviews?: boolean | Movie$reviewsArgs<ExtArgs>
    guideMovies?: boolean | Movie$guideMoviesArgs<ExtArgs>
    mediaContent?: boolean | Movie$mediaContentArgs<ExtArgs>
    movieTags?: boolean | Movie$movieTagsArgs<ExtArgs>
    favorites?: boolean | Movie$favoritesArgs<ExtArgs>
    stats?: boolean | Movie$statsArgs<ExtArgs>
    _count?: boolean | MovieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movie"]>

  export type MovieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tmdbId?: boolean
    titleEn?: boolean
    titleJa?: boolean
    titleZh?: boolean
    year?: boolean
    director?: boolean
    duration?: boolean
    synopsis?: boolean
    posterUrl?: boolean
    backdropUrl?: boolean
    voteAverage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["movie"]>

  export type MovieSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tmdbId?: boolean
    titleEn?: boolean
    titleJa?: boolean
    titleZh?: boolean
    year?: boolean
    director?: boolean
    duration?: boolean
    synopsis?: boolean
    posterUrl?: boolean
    backdropUrl?: boolean
    voteAverage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["movie"]>

  export type MovieSelectScalar = {
    id?: boolean
    tmdbId?: boolean
    titleEn?: boolean
    titleJa?: boolean
    titleZh?: boolean
    year?: boolean
    director?: boolean
    duration?: boolean
    synopsis?: boolean
    posterUrl?: boolean
    backdropUrl?: boolean
    voteAverage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MovieOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tmdbId" | "titleEn" | "titleJa" | "titleZh" | "year" | "director" | "duration" | "synopsis" | "posterUrl" | "backdropUrl" | "voteAverage" | "createdAt" | "updatedAt", ExtArgs["result"]["movie"]>
  export type MovieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availabilities?: boolean | Movie$availabilitiesArgs<ExtArgs>
    movieCharacters?: boolean | Movie$movieCharactersArgs<ExtArgs>
    movieCrew?: boolean | Movie$movieCrewArgs<ExtArgs>
    reviews?: boolean | Movie$reviewsArgs<ExtArgs>
    guideMovies?: boolean | Movie$guideMoviesArgs<ExtArgs>
    mediaContent?: boolean | Movie$mediaContentArgs<ExtArgs>
    movieTags?: boolean | Movie$movieTagsArgs<ExtArgs>
    favorites?: boolean | Movie$favoritesArgs<ExtArgs>
    stats?: boolean | Movie$statsArgs<ExtArgs>
    _count?: boolean | MovieCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MovieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MovieIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MoviePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Movie"
    objects: {
      availabilities: Prisma.$AvailabilityPayload<ExtArgs>[]
      movieCharacters: Prisma.$MovieCharacterPayload<ExtArgs>[]
      movieCrew: Prisma.$MovieCrewPayload<ExtArgs>[]
      reviews: Prisma.$MovieReviewPayload<ExtArgs>[]
      guideMovies: Prisma.$WatchGuideMoviePayload<ExtArgs>[]
      mediaContent: Prisma.$MediaContentPayload<ExtArgs>[]
      movieTags: Prisma.$MovieTagPayload<ExtArgs>[]
      favorites: Prisma.$UserFavoritePayload<ExtArgs>[]
      stats: Prisma.$MovieStatsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tmdbId: number
      titleEn: string
      titleJa: string
      titleZh: string | null
      year: number
      director: string | null
      duration: number | null
      synopsis: string | null
      posterUrl: string | null
      backdropUrl: string | null
      voteAverage: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["movie"]>
    composites: {}
  }

  type MovieGetPayload<S extends boolean | null | undefined | MovieDefaultArgs> = $Result.GetResult<Prisma.$MoviePayload, S>

  type MovieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MovieFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MovieCountAggregateInputType | true
    }

  export interface MovieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Movie'], meta: { name: 'Movie' } }
    /**
     * Find zero or one Movie that matches the filter.
     * @param {MovieFindUniqueArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieFindUniqueArgs>(args: SelectSubset<T, MovieFindUniqueArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Movie that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MovieFindUniqueOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Movie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindFirstArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieFindFirstArgs>(args?: SelectSubset<T, MovieFindFirstArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Movie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindFirstOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Movies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movies
     * const movies = await prisma.movie.findMany()
     * 
     * // Get first 10 Movies
     * const movies = await prisma.movie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieWithIdOnly = await prisma.movie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieFindManyArgs>(args?: SelectSubset<T, MovieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Movie.
     * @param {MovieCreateArgs} args - Arguments to create a Movie.
     * @example
     * // Create one Movie
     * const Movie = await prisma.movie.create({
     *   data: {
     *     // ... data to create a Movie
     *   }
     * })
     * 
     */
    create<T extends MovieCreateArgs>(args: SelectSubset<T, MovieCreateArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Movies.
     * @param {MovieCreateManyArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movie = await prisma.movie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieCreateManyArgs>(args?: SelectSubset<T, MovieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Movies and returns the data saved in the database.
     * @param {MovieCreateManyAndReturnArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movie = await prisma.movie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Movies and only return the `id`
     * const movieWithIdOnly = await prisma.movie.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Movie.
     * @param {MovieDeleteArgs} args - Arguments to delete one Movie.
     * @example
     * // Delete one Movie
     * const Movie = await prisma.movie.delete({
     *   where: {
     *     // ... filter to delete one Movie
     *   }
     * })
     * 
     */
    delete<T extends MovieDeleteArgs>(args: SelectSubset<T, MovieDeleteArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Movie.
     * @param {MovieUpdateArgs} args - Arguments to update one Movie.
     * @example
     * // Update one Movie
     * const movie = await prisma.movie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieUpdateArgs>(args: SelectSubset<T, MovieUpdateArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Movies.
     * @param {MovieDeleteManyArgs} args - Arguments to filter Movies to delete.
     * @example
     * // Delete a few Movies
     * const { count } = await prisma.movie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieDeleteManyArgs>(args?: SelectSubset<T, MovieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movies
     * const movie = await prisma.movie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieUpdateManyArgs>(args: SelectSubset<T, MovieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movies and returns the data updated in the database.
     * @param {MovieUpdateManyAndReturnArgs} args - Arguments to update many Movies.
     * @example
     * // Update many Movies
     * const movie = await prisma.movie.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Movies and only return the `id`
     * const movieWithIdOnly = await prisma.movie.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MovieUpdateManyAndReturnArgs>(args: SelectSubset<T, MovieUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Movie.
     * @param {MovieUpsertArgs} args - Arguments to update or create a Movie.
     * @example
     * // Update or create a Movie
     * const movie = await prisma.movie.upsert({
     *   create: {
     *     // ... data to create a Movie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movie we want to update
     *   }
     * })
     */
    upsert<T extends MovieUpsertArgs>(args: SelectSubset<T, MovieUpsertArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCountArgs} args - Arguments to filter Movies to count.
     * @example
     * // Count the number of Movies
     * const count = await prisma.movie.count({
     *   where: {
     *     // ... the filter for the Movies we want to count
     *   }
     * })
    **/
    count<T extends MovieCountArgs>(
      args?: Subset<T, MovieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieAggregateArgs>(args: Subset<T, MovieAggregateArgs>): Prisma.PrismaPromise<GetMovieAggregateType<T>>

    /**
     * Group by Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieGroupByArgs['orderBy'] }
        : { orderBy?: MovieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Movie model
   */
  readonly fields: MovieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Movie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    availabilities<T extends Movie$availabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Movie$availabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    movieCharacters<T extends Movie$movieCharactersArgs<ExtArgs> = {}>(args?: Subset<T, Movie$movieCharactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    movieCrew<T extends Movie$movieCrewArgs<ExtArgs> = {}>(args?: Subset<T, Movie$movieCrewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCrewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Movie$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Movie$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guideMovies<T extends Movie$guideMoviesArgs<ExtArgs> = {}>(args?: Subset<T, Movie$guideMoviesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchGuideMoviePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mediaContent<T extends Movie$mediaContentArgs<ExtArgs> = {}>(args?: Subset<T, Movie$mediaContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    movieTags<T extends Movie$movieTagsArgs<ExtArgs> = {}>(args?: Subset<T, Movie$movieTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends Movie$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Movie$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stats<T extends Movie$statsArgs<ExtArgs> = {}>(args?: Subset<T, Movie$statsArgs<ExtArgs>>): Prisma__MovieStatsClient<$Result.GetResult<Prisma.$MovieStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Movie model
   */
  interface MovieFieldRefs {
    readonly id: FieldRef<"Movie", 'String'>
    readonly tmdbId: FieldRef<"Movie", 'Int'>
    readonly titleEn: FieldRef<"Movie", 'String'>
    readonly titleJa: FieldRef<"Movie", 'String'>
    readonly titleZh: FieldRef<"Movie", 'String'>
    readonly year: FieldRef<"Movie", 'Int'>
    readonly director: FieldRef<"Movie", 'String'>
    readonly duration: FieldRef<"Movie", 'Int'>
    readonly synopsis: FieldRef<"Movie", 'String'>
    readonly posterUrl: FieldRef<"Movie", 'String'>
    readonly backdropUrl: FieldRef<"Movie", 'String'>
    readonly voteAverage: FieldRef<"Movie", 'Float'>
    readonly createdAt: FieldRef<"Movie", 'DateTime'>
    readonly updatedAt: FieldRef<"Movie", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Movie findUnique
   */
  export type MovieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie findUniqueOrThrow
   */
  export type MovieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie findFirst
   */
  export type MovieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie findFirstOrThrow
   */
  export type MovieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie findMany
   */
  export type MovieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movies to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie create
   */
  export type MovieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The data needed to create a Movie.
     */
    data: XOR<MovieCreateInput, MovieUncheckedCreateInput>
  }

  /**
   * Movie createMany
   */
  export type MovieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Movies.
     */
    data: MovieCreateManyInput | MovieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Movie createManyAndReturn
   */
  export type MovieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * The data used to create many Movies.
     */
    data: MovieCreateManyInput | MovieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Movie update
   */
  export type MovieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The data needed to update a Movie.
     */
    data: XOR<MovieUpdateInput, MovieUncheckedUpdateInput>
    /**
     * Choose, which Movie to update.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie updateMany
   */
  export type MovieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Movies.
     */
    data: XOR<MovieUpdateManyMutationInput, MovieUncheckedUpdateManyInput>
    /**
     * Filter which Movies to update
     */
    where?: MovieWhereInput
    /**
     * Limit how many Movies to update.
     */
    limit?: number
  }

  /**
   * Movie updateManyAndReturn
   */
  export type MovieUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * The data used to update Movies.
     */
    data: XOR<MovieUpdateManyMutationInput, MovieUncheckedUpdateManyInput>
    /**
     * Filter which Movies to update
     */
    where?: MovieWhereInput
    /**
     * Limit how many Movies to update.
     */
    limit?: number
  }

  /**
   * Movie upsert
   */
  export type MovieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The filter to search for the Movie to update in case it exists.
     */
    where: MovieWhereUniqueInput
    /**
     * In case the Movie found by the `where` argument doesn't exist, create a new Movie with this data.
     */
    create: XOR<MovieCreateInput, MovieUncheckedCreateInput>
    /**
     * In case the Movie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieUpdateInput, MovieUncheckedUpdateInput>
  }

  /**
   * Movie delete
   */
  export type MovieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter which Movie to delete.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie deleteMany
   */
  export type MovieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movies to delete
     */
    where?: MovieWhereInput
    /**
     * Limit how many Movies to delete.
     */
    limit?: number
  }

  /**
   * Movie.availabilities
   */
  export type Movie$availabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    cursor?: AvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Movie.movieCharacters
   */
  export type Movie$movieCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterInclude<ExtArgs> | null
    where?: MovieCharacterWhereInput
    orderBy?: MovieCharacterOrderByWithRelationInput | MovieCharacterOrderByWithRelationInput[]
    cursor?: MovieCharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieCharacterScalarFieldEnum | MovieCharacterScalarFieldEnum[]
  }

  /**
   * Movie.movieCrew
   */
  export type Movie$movieCrewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewInclude<ExtArgs> | null
    where?: MovieCrewWhereInput
    orderBy?: MovieCrewOrderByWithRelationInput | MovieCrewOrderByWithRelationInput[]
    cursor?: MovieCrewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieCrewScalarFieldEnum | MovieCrewScalarFieldEnum[]
  }

  /**
   * Movie.reviews
   */
  export type Movie$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieReview
     */
    select?: MovieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieReview
     */
    omit?: MovieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieReviewInclude<ExtArgs> | null
    where?: MovieReviewWhereInput
    orderBy?: MovieReviewOrderByWithRelationInput | MovieReviewOrderByWithRelationInput[]
    cursor?: MovieReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieReviewScalarFieldEnum | MovieReviewScalarFieldEnum[]
  }

  /**
   * Movie.guideMovies
   */
  export type Movie$guideMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieInclude<ExtArgs> | null
    where?: WatchGuideMovieWhereInput
    orderBy?: WatchGuideMovieOrderByWithRelationInput | WatchGuideMovieOrderByWithRelationInput[]
    cursor?: WatchGuideMovieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchGuideMovieScalarFieldEnum | WatchGuideMovieScalarFieldEnum[]
  }

  /**
   * Movie.mediaContent
   */
  export type Movie$mediaContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaContent
     */
    select?: MediaContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaContent
     */
    omit?: MediaContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaContentInclude<ExtArgs> | null
    where?: MediaContentWhereInput
    orderBy?: MediaContentOrderByWithRelationInput | MediaContentOrderByWithRelationInput[]
    cursor?: MediaContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaContentScalarFieldEnum | MediaContentScalarFieldEnum[]
  }

  /**
   * Movie.movieTags
   */
  export type Movie$movieTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    where?: MovieTagWhereInput
    orderBy?: MovieTagOrderByWithRelationInput | MovieTagOrderByWithRelationInput[]
    cursor?: MovieTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieTagScalarFieldEnum | MovieTagScalarFieldEnum[]
  }

  /**
   * Movie.favorites
   */
  export type Movie$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    cursor?: UserFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * Movie.stats
   */
  export type Movie$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieStats
     */
    select?: MovieStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieStats
     */
    omit?: MovieStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieStatsInclude<ExtArgs> | null
    where?: MovieStatsWhereInput
  }

  /**
   * Movie without action
   */
  export type MovieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
  }


  /**
   * Model Platform
   */

  export type AggregatePlatform = {
    _count: PlatformCountAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  export type PlatformMinAggregateOutputType = {
    id: string | null
    name: string | null
    website: string | null
    type: $Enums.PlatformType | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformMaxAggregateOutputType = {
    id: string | null
    name: string | null
    website: string | null
    type: $Enums.PlatformType | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformCountAggregateOutputType = {
    id: number
    name: number
    website: number
    type: number
    logo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlatformMinAggregateInputType = {
    id?: true
    name?: true
    website?: true
    type?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformMaxAggregateInputType = {
    id?: true
    name?: true
    website?: true
    type?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformCountAggregateInputType = {
    id?: true
    name?: true
    website?: true
    type?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlatformAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Platform to aggregate.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Platforms
    **/
    _count?: true | PlatformCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformMaxAggregateInputType
  }

  export type GetPlatformAggregateType<T extends PlatformAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatform]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatform[P]>
      : GetScalarType<T[P], AggregatePlatform[P]>
  }




  export type PlatformGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformWhereInput
    orderBy?: PlatformOrderByWithAggregationInput | PlatformOrderByWithAggregationInput[]
    by: PlatformScalarFieldEnum[] | PlatformScalarFieldEnum
    having?: PlatformScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformCountAggregateInputType | true
    _min?: PlatformMinAggregateInputType
    _max?: PlatformMaxAggregateInputType
  }

  export type PlatformGroupByOutputType = {
    id: string
    name: string
    website: string
    type: $Enums.PlatformType
    logo: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlatformCountAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  type GetPlatformGroupByPayload<T extends PlatformGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformGroupByOutputType[P]>
        }
      >
    >


  export type PlatformSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    website?: boolean
    type?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    availabilities?: boolean | Platform$availabilitiesArgs<ExtArgs>
    _count?: boolean | PlatformCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    website?: boolean
    type?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    website?: boolean
    type?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectScalar = {
    id?: boolean
    name?: boolean
    website?: boolean
    type?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlatformOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "website" | "type" | "logo" | "createdAt" | "updatedAt", ExtArgs["result"]["platform"]>
  export type PlatformInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availabilities?: boolean | Platform$availabilitiesArgs<ExtArgs>
    _count?: boolean | PlatformCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlatformIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlatformIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlatformPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Platform"
    objects: {
      availabilities: Prisma.$AvailabilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      website: string
      type: $Enums.PlatformType
      logo: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["platform"]>
    composites: {}
  }

  type PlatformGetPayload<S extends boolean | null | undefined | PlatformDefaultArgs> = $Result.GetResult<Prisma.$PlatformPayload, S>

  type PlatformCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformCountAggregateInputType | true
    }

  export interface PlatformDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Platform'], meta: { name: 'Platform' } }
    /**
     * Find zero or one Platform that matches the filter.
     * @param {PlatformFindUniqueArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformFindUniqueArgs>(args: SelectSubset<T, PlatformFindUniqueArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Platform that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformFindUniqueOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Platform that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindFirstArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformFindFirstArgs>(args?: SelectSubset<T, PlatformFindFirstArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Platform that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindFirstOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Platforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Platforms
     * const platforms = await prisma.platform.findMany()
     * 
     * // Get first 10 Platforms
     * const platforms = await prisma.platform.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformWithIdOnly = await prisma.platform.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformFindManyArgs>(args?: SelectSubset<T, PlatformFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Platform.
     * @param {PlatformCreateArgs} args - Arguments to create a Platform.
     * @example
     * // Create one Platform
     * const Platform = await prisma.platform.create({
     *   data: {
     *     // ... data to create a Platform
     *   }
     * })
     * 
     */
    create<T extends PlatformCreateArgs>(args: SelectSubset<T, PlatformCreateArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Platforms.
     * @param {PlatformCreateManyArgs} args - Arguments to create many Platforms.
     * @example
     * // Create many Platforms
     * const platform = await prisma.platform.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformCreateManyArgs>(args?: SelectSubset<T, PlatformCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Platforms and returns the data saved in the database.
     * @param {PlatformCreateManyAndReturnArgs} args - Arguments to create many Platforms.
     * @example
     * // Create many Platforms
     * const platform = await prisma.platform.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Platforms and only return the `id`
     * const platformWithIdOnly = await prisma.platform.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Platform.
     * @param {PlatformDeleteArgs} args - Arguments to delete one Platform.
     * @example
     * // Delete one Platform
     * const Platform = await prisma.platform.delete({
     *   where: {
     *     // ... filter to delete one Platform
     *   }
     * })
     * 
     */
    delete<T extends PlatformDeleteArgs>(args: SelectSubset<T, PlatformDeleteArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Platform.
     * @param {PlatformUpdateArgs} args - Arguments to update one Platform.
     * @example
     * // Update one Platform
     * const platform = await prisma.platform.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformUpdateArgs>(args: SelectSubset<T, PlatformUpdateArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Platforms.
     * @param {PlatformDeleteManyArgs} args - Arguments to filter Platforms to delete.
     * @example
     * // Delete a few Platforms
     * const { count } = await prisma.platform.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformDeleteManyArgs>(args?: SelectSubset<T, PlatformDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Platforms
     * const platform = await prisma.platform.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformUpdateManyArgs>(args: SelectSubset<T, PlatformUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platforms and returns the data updated in the database.
     * @param {PlatformUpdateManyAndReturnArgs} args - Arguments to update many Platforms.
     * @example
     * // Update many Platforms
     * const platform = await prisma.platform.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Platforms and only return the `id`
     * const platformWithIdOnly = await prisma.platform.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlatformUpdateManyAndReturnArgs>(args: SelectSubset<T, PlatformUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Platform.
     * @param {PlatformUpsertArgs} args - Arguments to update or create a Platform.
     * @example
     * // Update or create a Platform
     * const platform = await prisma.platform.upsert({
     *   create: {
     *     // ... data to create a Platform
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Platform we want to update
     *   }
     * })
     */
    upsert<T extends PlatformUpsertArgs>(args: SelectSubset<T, PlatformUpsertArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformCountArgs} args - Arguments to filter Platforms to count.
     * @example
     * // Count the number of Platforms
     * const count = await prisma.platform.count({
     *   where: {
     *     // ... the filter for the Platforms we want to count
     *   }
     * })
    **/
    count<T extends PlatformCountArgs>(
      args?: Subset<T, PlatformCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformAggregateArgs>(args: Subset<T, PlatformAggregateArgs>): Prisma.PrismaPromise<GetPlatformAggregateType<T>>

    /**
     * Group by Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformGroupByArgs['orderBy'] }
        : { orderBy?: PlatformGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Platform model
   */
  readonly fields: PlatformFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Platform.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    availabilities<T extends Platform$availabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Platform$availabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Platform model
   */
  interface PlatformFieldRefs {
    readonly id: FieldRef<"Platform", 'String'>
    readonly name: FieldRef<"Platform", 'String'>
    readonly website: FieldRef<"Platform", 'String'>
    readonly type: FieldRef<"Platform", 'PlatformType'>
    readonly logo: FieldRef<"Platform", 'String'>
    readonly createdAt: FieldRef<"Platform", 'DateTime'>
    readonly updatedAt: FieldRef<"Platform", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Platform findUnique
   */
  export type PlatformFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform findUniqueOrThrow
   */
  export type PlatformFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform findFirst
   */
  export type PlatformFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Platforms.
     */
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform findFirstOrThrow
   */
  export type PlatformFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Platforms.
     */
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform findMany
   */
  export type PlatformFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platforms to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform create
   */
  export type PlatformCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * The data needed to create a Platform.
     */
    data: XOR<PlatformCreateInput, PlatformUncheckedCreateInput>
  }

  /**
   * Platform createMany
   */
  export type PlatformCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Platforms.
     */
    data: PlatformCreateManyInput | PlatformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Platform createManyAndReturn
   */
  export type PlatformCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * The data used to create many Platforms.
     */
    data: PlatformCreateManyInput | PlatformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Platform update
   */
  export type PlatformUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * The data needed to update a Platform.
     */
    data: XOR<PlatformUpdateInput, PlatformUncheckedUpdateInput>
    /**
     * Choose, which Platform to update.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform updateMany
   */
  export type PlatformUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Platforms.
     */
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyInput>
    /**
     * Filter which Platforms to update
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to update.
     */
    limit?: number
  }

  /**
   * Platform updateManyAndReturn
   */
  export type PlatformUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * The data used to update Platforms.
     */
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyInput>
    /**
     * Filter which Platforms to update
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to update.
     */
    limit?: number
  }

  /**
   * Platform upsert
   */
  export type PlatformUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * The filter to search for the Platform to update in case it exists.
     */
    where: PlatformWhereUniqueInput
    /**
     * In case the Platform found by the `where` argument doesn't exist, create a new Platform with this data.
     */
    create: XOR<PlatformCreateInput, PlatformUncheckedCreateInput>
    /**
     * In case the Platform was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformUpdateInput, PlatformUncheckedUpdateInput>
  }

  /**
   * Platform delete
   */
  export type PlatformDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter which Platform to delete.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform deleteMany
   */
  export type PlatformDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Platforms to delete
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to delete.
     */
    limit?: number
  }

  /**
   * Platform.availabilities
   */
  export type Platform$availabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    cursor?: AvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Platform without action
   */
  export type PlatformDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
  }


  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegionMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    code: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RegionMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    id: string
    code: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: RegionCountAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    availabilities?: boolean | Region$availabilitiesArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>

  export type RegionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["region"]>

  export type RegionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["region"]>

  export type RegionSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RegionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["region"]>
  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availabilities?: boolean | Region$availabilitiesArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RegionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      availabilities: Prisma.$AvailabilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["region"]>
    composites: {}
  }

  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionFindUniqueArgs>(args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Region that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionFindFirstArgs>(args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionFindManyArgs>(args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
     */
    create<T extends RegionCreateArgs>(args: SelectSubset<T, RegionCreateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Regions.
     * @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionCreateManyArgs>(args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Regions and returns the data saved in the database.
     * @param {RegionCreateManyAndReturnArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Regions and only return the `id`
     * const regionWithIdOnly = await prisma.region.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegionCreateManyAndReturnArgs>(args?: SelectSubset<T, RegionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
     */
    delete<T extends RegionDeleteArgs>(args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionUpdateArgs>(args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionDeleteManyArgs>(args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionUpdateManyArgs>(args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions and returns the data updated in the database.
     * @param {RegionUpdateManyAndReturnArgs} args - Arguments to update many Regions.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Regions and only return the `id`
     * const regionWithIdOnly = await prisma.region.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegionUpdateManyAndReturnArgs>(args: SelectSubset<T, RegionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
     */
    upsert<T extends RegionUpsertArgs>(args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    availabilities<T extends Region$availabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Region$availabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Region model
   */
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", 'String'>
    readonly code: FieldRef<"Region", 'String'>
    readonly name: FieldRef<"Region", 'String'>
    readonly createdAt: FieldRef<"Region", 'DateTime'>
    readonly updatedAt: FieldRef<"Region", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }

  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region createManyAndReturn
   */
  export type RegionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region updateManyAndReturn
   */
  export type RegionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }

  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to delete.
     */
    limit?: number
  }

  /**
   * Region.availabilities
   */
  export type Region$availabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    cursor?: AvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
  }


  /**
   * Model Availability
   */

  export type AggregateAvailability = {
    _count: AvailabilityCountAggregateOutputType | null
    _avg: AvailabilityAvgAggregateOutputType | null
    _sum: AvailabilitySumAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  export type AvailabilityAvgAggregateOutputType = {
    price: number | null
  }

  export type AvailabilitySumAggregateOutputType = {
    price: number | null
  }

  export type AvailabilityMinAggregateOutputType = {
    id: string | null
    url: string | null
    price: number | null
    currency: string | null
    type: $Enums.AvailabilityType | null
    lastChecked: Date | null
    isAvailable: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    movieId: string | null
    platformId: string | null
    regionId: string | null
  }

  export type AvailabilityMaxAggregateOutputType = {
    id: string | null
    url: string | null
    price: number | null
    currency: string | null
    type: $Enums.AvailabilityType | null
    lastChecked: Date | null
    isAvailable: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    movieId: string | null
    platformId: string | null
    regionId: string | null
  }

  export type AvailabilityCountAggregateOutputType = {
    id: number
    url: number
    price: number
    currency: number
    type: number
    lastChecked: number
    isAvailable: number
    notes: number
    createdAt: number
    updatedAt: number
    movieId: number
    platformId: number
    regionId: number
    _all: number
  }


  export type AvailabilityAvgAggregateInputType = {
    price?: true
  }

  export type AvailabilitySumAggregateInputType = {
    price?: true
  }

  export type AvailabilityMinAggregateInputType = {
    id?: true
    url?: true
    price?: true
    currency?: true
    type?: true
    lastChecked?: true
    isAvailable?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    movieId?: true
    platformId?: true
    regionId?: true
  }

  export type AvailabilityMaxAggregateInputType = {
    id?: true
    url?: true
    price?: true
    currency?: true
    type?: true
    lastChecked?: true
    isAvailable?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    movieId?: true
    platformId?: true
    regionId?: true
  }

  export type AvailabilityCountAggregateInputType = {
    id?: true
    url?: true
    price?: true
    currency?: true
    type?: true
    lastChecked?: true
    isAvailable?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    movieId?: true
    platformId?: true
    regionId?: true
    _all?: true
  }

  export type AvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availability to aggregate.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Availabilities
    **/
    _count?: true | AvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvailabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvailabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvailabilityMaxAggregateInputType
  }

  export type GetAvailabilityAggregateType<T extends AvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvailability[P]>
      : GetScalarType<T[P], AggregateAvailability[P]>
  }




  export type AvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithAggregationInput | AvailabilityOrderByWithAggregationInput[]
    by: AvailabilityScalarFieldEnum[] | AvailabilityScalarFieldEnum
    having?: AvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvailabilityCountAggregateInputType | true
    _avg?: AvailabilityAvgAggregateInputType
    _sum?: AvailabilitySumAggregateInputType
    _min?: AvailabilityMinAggregateInputType
    _max?: AvailabilityMaxAggregateInputType
  }

  export type AvailabilityGroupByOutputType = {
    id: string
    url: string | null
    price: number | null
    currency: string | null
    type: $Enums.AvailabilityType
    lastChecked: Date
    isAvailable: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    movieId: string
    platformId: string
    regionId: string
    _count: AvailabilityCountAggregateOutputType | null
    _avg: AvailabilityAvgAggregateOutputType | null
    _sum: AvailabilitySumAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  type GetAvailabilityGroupByPayload<T extends AvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type AvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    price?: boolean
    currency?: boolean
    type?: boolean
    lastChecked?: boolean
    isAvailable?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movieId?: boolean
    platformId?: boolean
    regionId?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    price?: boolean
    currency?: boolean
    type?: boolean
    lastChecked?: boolean
    isAvailable?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movieId?: boolean
    platformId?: boolean
    regionId?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    price?: boolean
    currency?: boolean
    type?: boolean
    lastChecked?: boolean
    isAvailable?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movieId?: boolean
    platformId?: boolean
    regionId?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectScalar = {
    id?: boolean
    url?: boolean
    price?: boolean
    currency?: boolean
    type?: boolean
    lastChecked?: boolean
    isAvailable?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movieId?: boolean
    platformId?: boolean
    regionId?: boolean
  }

  export type AvailabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "price" | "currency" | "type" | "lastChecked" | "isAvailable" | "notes" | "createdAt" | "updatedAt" | "movieId" | "platformId" | "regionId", ExtArgs["result"]["availability"]>
  export type AvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }
  export type AvailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }
  export type AvailabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }

  export type $AvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Availability"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
      platform: Prisma.$PlatformPayload<ExtArgs>
      region: Prisma.$RegionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string | null
      price: number | null
      currency: string | null
      type: $Enums.AvailabilityType
      lastChecked: Date
      isAvailable: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
      movieId: string
      platformId: string
      regionId: string
    }, ExtArgs["result"]["availability"]>
    composites: {}
  }

  type AvailabilityGetPayload<S extends boolean | null | undefined | AvailabilityDefaultArgs> = $Result.GetResult<Prisma.$AvailabilityPayload, S>

  type AvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvailabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvailabilityCountAggregateInputType | true
    }

  export interface AvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Availability'], meta: { name: 'Availability' } }
    /**
     * Find zero or one Availability that matches the filter.
     * @param {AvailabilityFindUniqueArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvailabilityFindUniqueArgs>(args: SelectSubset<T, AvailabilityFindUniqueArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Availability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvailabilityFindUniqueOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, AvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Availability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvailabilityFindFirstArgs>(args?: SelectSubset<T, AvailabilityFindFirstArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Availability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, AvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Availabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Availabilities
     * const availabilities = await prisma.availability.findMany()
     * 
     * // Get first 10 Availabilities
     * const availabilities = await prisma.availability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const availabilityWithIdOnly = await prisma.availability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvailabilityFindManyArgs>(args?: SelectSubset<T, AvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Availability.
     * @param {AvailabilityCreateArgs} args - Arguments to create a Availability.
     * @example
     * // Create one Availability
     * const Availability = await prisma.availability.create({
     *   data: {
     *     // ... data to create a Availability
     *   }
     * })
     * 
     */
    create<T extends AvailabilityCreateArgs>(args: SelectSubset<T, AvailabilityCreateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Availabilities.
     * @param {AvailabilityCreateManyArgs} args - Arguments to create many Availabilities.
     * @example
     * // Create many Availabilities
     * const availability = await prisma.availability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvailabilityCreateManyArgs>(args?: SelectSubset<T, AvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Availabilities and returns the data saved in the database.
     * @param {AvailabilityCreateManyAndReturnArgs} args - Arguments to create many Availabilities.
     * @example
     * // Create many Availabilities
     * const availability = await prisma.availability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Availabilities and only return the `id`
     * const availabilityWithIdOnly = await prisma.availability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, AvailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Availability.
     * @param {AvailabilityDeleteArgs} args - Arguments to delete one Availability.
     * @example
     * // Delete one Availability
     * const Availability = await prisma.availability.delete({
     *   where: {
     *     // ... filter to delete one Availability
     *   }
     * })
     * 
     */
    delete<T extends AvailabilityDeleteArgs>(args: SelectSubset<T, AvailabilityDeleteArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Availability.
     * @param {AvailabilityUpdateArgs} args - Arguments to update one Availability.
     * @example
     * // Update one Availability
     * const availability = await prisma.availability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvailabilityUpdateArgs>(args: SelectSubset<T, AvailabilityUpdateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Availabilities.
     * @param {AvailabilityDeleteManyArgs} args - Arguments to filter Availabilities to delete.
     * @example
     * // Delete a few Availabilities
     * const { count } = await prisma.availability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvailabilityDeleteManyArgs>(args?: SelectSubset<T, AvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Availabilities
     * const availability = await prisma.availability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvailabilityUpdateManyArgs>(args: SelectSubset<T, AvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Availabilities and returns the data updated in the database.
     * @param {AvailabilityUpdateManyAndReturnArgs} args - Arguments to update many Availabilities.
     * @example
     * // Update many Availabilities
     * const availability = await prisma.availability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Availabilities and only return the `id`
     * const availabilityWithIdOnly = await prisma.availability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvailabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, AvailabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Availability.
     * @param {AvailabilityUpsertArgs} args - Arguments to update or create a Availability.
     * @example
     * // Update or create a Availability
     * const availability = await prisma.availability.upsert({
     *   create: {
     *     // ... data to create a Availability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Availability we want to update
     *   }
     * })
     */
    upsert<T extends AvailabilityUpsertArgs>(args: SelectSubset<T, AvailabilityUpsertArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityCountArgs} args - Arguments to filter Availabilities to count.
     * @example
     * // Count the number of Availabilities
     * const count = await prisma.availability.count({
     *   where: {
     *     // ... the filter for the Availabilities we want to count
     *   }
     * })
    **/
    count<T extends AvailabilityCountArgs>(
      args?: Subset<T, AvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvailabilityAggregateArgs>(args: Subset<T, AvailabilityAggregateArgs>): Prisma.PrismaPromise<GetAvailabilityAggregateType<T>>

    /**
     * Group by Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: AvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Availability model
   */
  readonly fields: AvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Availability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    platform<T extends PlatformDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlatformDefaultArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Availability model
   */
  interface AvailabilityFieldRefs {
    readonly id: FieldRef<"Availability", 'String'>
    readonly url: FieldRef<"Availability", 'String'>
    readonly price: FieldRef<"Availability", 'Float'>
    readonly currency: FieldRef<"Availability", 'String'>
    readonly type: FieldRef<"Availability", 'AvailabilityType'>
    readonly lastChecked: FieldRef<"Availability", 'DateTime'>
    readonly isAvailable: FieldRef<"Availability", 'Boolean'>
    readonly notes: FieldRef<"Availability", 'String'>
    readonly createdAt: FieldRef<"Availability", 'DateTime'>
    readonly updatedAt: FieldRef<"Availability", 'DateTime'>
    readonly movieId: FieldRef<"Availability", 'String'>
    readonly platformId: FieldRef<"Availability", 'String'>
    readonly regionId: FieldRef<"Availability", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Availability findUnique
   */
  export type AvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findUniqueOrThrow
   */
  export type AvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findFirst
   */
  export type AvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findFirstOrThrow
   */
  export type AvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findMany
   */
  export type AvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availabilities to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability create
   */
  export type AvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Availability.
     */
    data: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
  }

  /**
   * Availability createMany
   */
  export type AvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Availabilities.
     */
    data: AvailabilityCreateManyInput | AvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Availability createManyAndReturn
   */
  export type AvailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * The data used to create many Availabilities.
     */
    data: AvailabilityCreateManyInput | AvailabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Availability update
   */
  export type AvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Availability.
     */
    data: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
    /**
     * Choose, which Availability to update.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability updateMany
   */
  export type AvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Availabilities.
     */
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which Availabilities to update
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to update.
     */
    limit?: number
  }

  /**
   * Availability updateManyAndReturn
   */
  export type AvailabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * The data used to update Availabilities.
     */
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which Availabilities to update
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Availability upsert
   */
  export type AvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Availability to update in case it exists.
     */
    where: AvailabilityWhereUniqueInput
    /**
     * In case the Availability found by the `where` argument doesn't exist, create a new Availability with this data.
     */
    create: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
    /**
     * In case the Availability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
  }

  /**
   * Availability delete
   */
  export type AvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter which Availability to delete.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability deleteMany
   */
  export type AvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availabilities to delete
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to delete.
     */
    limit?: number
  }

  /**
   * Availability without action
   */
  export type AvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model ContentVersion
   */

  export type AggregateContentVersion = {
    _count: ContentVersionCountAggregateOutputType | null
    _avg: ContentVersionAvgAggregateOutputType | null
    _sum: ContentVersionSumAggregateOutputType | null
    _min: ContentVersionMinAggregateOutputType | null
    _max: ContentVersionMaxAggregateOutputType | null
  }

  export type ContentVersionAvgAggregateOutputType = {
    version: number | null
  }

  export type ContentVersionSumAggregateOutputType = {
    version: number | null
  }

  export type ContentVersionMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    version: number | null
    changeType: $Enums.ChangeType | null
    author: string | null
    reason: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ContentVersionMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    version: number | null
    changeType: $Enums.ChangeType | null
    author: string | null
    reason: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ContentVersionCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    version: number
    changes: number
    changeType: number
    author: number
    reason: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ContentVersionAvgAggregateInputType = {
    version?: true
  }

  export type ContentVersionSumAggregateInputType = {
    version?: true
  }

  export type ContentVersionMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    version?: true
    changeType?: true
    author?: true
    reason?: true
    isActive?: true
    createdAt?: true
  }

  export type ContentVersionMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    version?: true
    changeType?: true
    author?: true
    reason?: true
    isActive?: true
    createdAt?: true
  }

  export type ContentVersionCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    version?: true
    changes?: true
    changeType?: true
    author?: true
    reason?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ContentVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentVersion to aggregate.
     */
    where?: ContentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentVersions to fetch.
     */
    orderBy?: ContentVersionOrderByWithRelationInput | ContentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentVersions
    **/
    _count?: true | ContentVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentVersionMaxAggregateInputType
  }

  export type GetContentVersionAggregateType<T extends ContentVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateContentVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentVersion[P]>
      : GetScalarType<T[P], AggregateContentVersion[P]>
  }




  export type ContentVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentVersionWhereInput
    orderBy?: ContentVersionOrderByWithAggregationInput | ContentVersionOrderByWithAggregationInput[]
    by: ContentVersionScalarFieldEnum[] | ContentVersionScalarFieldEnum
    having?: ContentVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentVersionCountAggregateInputType | true
    _avg?: ContentVersionAvgAggregateInputType
    _sum?: ContentVersionSumAggregateInputType
    _min?: ContentVersionMinAggregateInputType
    _max?: ContentVersionMaxAggregateInputType
  }

  export type ContentVersionGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    version: number
    changes: JsonValue
    changeType: $Enums.ChangeType
    author: string | null
    reason: string | null
    isActive: boolean
    createdAt: Date
    _count: ContentVersionCountAggregateOutputType | null
    _avg: ContentVersionAvgAggregateOutputType | null
    _sum: ContentVersionSumAggregateOutputType | null
    _min: ContentVersionMinAggregateOutputType | null
    _max: ContentVersionMaxAggregateOutputType | null
  }

  type GetContentVersionGroupByPayload<T extends ContentVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentVersionGroupByOutputType[P]>
            : GetScalarType<T[P], ContentVersionGroupByOutputType[P]>
        }
      >
    >


  export type ContentVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    version?: boolean
    changes?: boolean
    changeType?: boolean
    author?: boolean
    reason?: boolean
    isActive?: boolean
    createdAt?: boolean
    reviews?: boolean | ContentVersion$reviewsArgs<ExtArgs>
    _count?: boolean | ContentVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentVersion"]>

  export type ContentVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    version?: boolean
    changes?: boolean
    changeType?: boolean
    author?: boolean
    reason?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contentVersion"]>

  export type ContentVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    version?: boolean
    changes?: boolean
    changeType?: boolean
    author?: boolean
    reason?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contentVersion"]>

  export type ContentVersionSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    version?: boolean
    changes?: boolean
    changeType?: boolean
    author?: boolean
    reason?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ContentVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "version" | "changes" | "changeType" | "author" | "reason" | "isActive" | "createdAt", ExtArgs["result"]["contentVersion"]>
  export type ContentVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | ContentVersion$reviewsArgs<ExtArgs>
    _count?: boolean | ContentVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContentVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContentVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentVersion"
    objects: {
      reviews: Prisma.$ContentReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      version: number
      changes: Prisma.JsonValue
      changeType: $Enums.ChangeType
      author: string | null
      reason: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["contentVersion"]>
    composites: {}
  }

  type ContentVersionGetPayload<S extends boolean | null | undefined | ContentVersionDefaultArgs> = $Result.GetResult<Prisma.$ContentVersionPayload, S>

  type ContentVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentVersionCountAggregateInputType | true
    }

  export interface ContentVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentVersion'], meta: { name: 'ContentVersion' } }
    /**
     * Find zero or one ContentVersion that matches the filter.
     * @param {ContentVersionFindUniqueArgs} args - Arguments to find a ContentVersion
     * @example
     * // Get one ContentVersion
     * const contentVersion = await prisma.contentVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentVersionFindUniqueArgs>(args: SelectSubset<T, ContentVersionFindUniqueArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentVersionFindUniqueOrThrowArgs} args - Arguments to find a ContentVersion
     * @example
     * // Get one ContentVersion
     * const contentVersion = await prisma.contentVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionFindFirstArgs} args - Arguments to find a ContentVersion
     * @example
     * // Get one ContentVersion
     * const contentVersion = await prisma.contentVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentVersionFindFirstArgs>(args?: SelectSubset<T, ContentVersionFindFirstArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionFindFirstOrThrowArgs} args - Arguments to find a ContentVersion
     * @example
     * // Get one ContentVersion
     * const contentVersion = await prisma.contentVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentVersions
     * const contentVersions = await prisma.contentVersion.findMany()
     * 
     * // Get first 10 ContentVersions
     * const contentVersions = await prisma.contentVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentVersionWithIdOnly = await prisma.contentVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentVersionFindManyArgs>(args?: SelectSubset<T, ContentVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentVersion.
     * @param {ContentVersionCreateArgs} args - Arguments to create a ContentVersion.
     * @example
     * // Create one ContentVersion
     * const ContentVersion = await prisma.contentVersion.create({
     *   data: {
     *     // ... data to create a ContentVersion
     *   }
     * })
     * 
     */
    create<T extends ContentVersionCreateArgs>(args: SelectSubset<T, ContentVersionCreateArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentVersions.
     * @param {ContentVersionCreateManyArgs} args - Arguments to create many ContentVersions.
     * @example
     * // Create many ContentVersions
     * const contentVersion = await prisma.contentVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentVersionCreateManyArgs>(args?: SelectSubset<T, ContentVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentVersions and returns the data saved in the database.
     * @param {ContentVersionCreateManyAndReturnArgs} args - Arguments to create many ContentVersions.
     * @example
     * // Create many ContentVersions
     * const contentVersion = await prisma.contentVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentVersions and only return the `id`
     * const contentVersionWithIdOnly = await prisma.contentVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentVersion.
     * @param {ContentVersionDeleteArgs} args - Arguments to delete one ContentVersion.
     * @example
     * // Delete one ContentVersion
     * const ContentVersion = await prisma.contentVersion.delete({
     *   where: {
     *     // ... filter to delete one ContentVersion
     *   }
     * })
     * 
     */
    delete<T extends ContentVersionDeleteArgs>(args: SelectSubset<T, ContentVersionDeleteArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentVersion.
     * @param {ContentVersionUpdateArgs} args - Arguments to update one ContentVersion.
     * @example
     * // Update one ContentVersion
     * const contentVersion = await prisma.contentVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentVersionUpdateArgs>(args: SelectSubset<T, ContentVersionUpdateArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentVersions.
     * @param {ContentVersionDeleteManyArgs} args - Arguments to filter ContentVersions to delete.
     * @example
     * // Delete a few ContentVersions
     * const { count } = await prisma.contentVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentVersionDeleteManyArgs>(args?: SelectSubset<T, ContentVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentVersions
     * const contentVersion = await prisma.contentVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentVersionUpdateManyArgs>(args: SelectSubset<T, ContentVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentVersions and returns the data updated in the database.
     * @param {ContentVersionUpdateManyAndReturnArgs} args - Arguments to update many ContentVersions.
     * @example
     * // Update many ContentVersions
     * const contentVersion = await prisma.contentVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentVersions and only return the `id`
     * const contentVersionWithIdOnly = await prisma.contentVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentVersion.
     * @param {ContentVersionUpsertArgs} args - Arguments to update or create a ContentVersion.
     * @example
     * // Update or create a ContentVersion
     * const contentVersion = await prisma.contentVersion.upsert({
     *   create: {
     *     // ... data to create a ContentVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentVersion we want to update
     *   }
     * })
     */
    upsert<T extends ContentVersionUpsertArgs>(args: SelectSubset<T, ContentVersionUpsertArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionCountArgs} args - Arguments to filter ContentVersions to count.
     * @example
     * // Count the number of ContentVersions
     * const count = await prisma.contentVersion.count({
     *   where: {
     *     // ... the filter for the ContentVersions we want to count
     *   }
     * })
    **/
    count<T extends ContentVersionCountArgs>(
      args?: Subset<T, ContentVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentVersionAggregateArgs>(args: Subset<T, ContentVersionAggregateArgs>): Prisma.PrismaPromise<GetContentVersionAggregateType<T>>

    /**
     * Group by ContentVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentVersionGroupByArgs['orderBy'] }
        : { orderBy?: ContentVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentVersion model
   */
  readonly fields: ContentVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reviews<T extends ContentVersion$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, ContentVersion$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentVersion model
   */
  interface ContentVersionFieldRefs {
    readonly id: FieldRef<"ContentVersion", 'String'>
    readonly entityType: FieldRef<"ContentVersion", 'String'>
    readonly entityId: FieldRef<"ContentVersion", 'String'>
    readonly version: FieldRef<"ContentVersion", 'Int'>
    readonly changes: FieldRef<"ContentVersion", 'Json'>
    readonly changeType: FieldRef<"ContentVersion", 'ChangeType'>
    readonly author: FieldRef<"ContentVersion", 'String'>
    readonly reason: FieldRef<"ContentVersion", 'String'>
    readonly isActive: FieldRef<"ContentVersion", 'Boolean'>
    readonly createdAt: FieldRef<"ContentVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentVersion findUnique
   */
  export type ContentVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ContentVersion to fetch.
     */
    where: ContentVersionWhereUniqueInput
  }

  /**
   * ContentVersion findUniqueOrThrow
   */
  export type ContentVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ContentVersion to fetch.
     */
    where: ContentVersionWhereUniqueInput
  }

  /**
   * ContentVersion findFirst
   */
  export type ContentVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ContentVersion to fetch.
     */
    where?: ContentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentVersions to fetch.
     */
    orderBy?: ContentVersionOrderByWithRelationInput | ContentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentVersions.
     */
    cursor?: ContentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentVersions.
     */
    distinct?: ContentVersionScalarFieldEnum | ContentVersionScalarFieldEnum[]
  }

  /**
   * ContentVersion findFirstOrThrow
   */
  export type ContentVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ContentVersion to fetch.
     */
    where?: ContentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentVersions to fetch.
     */
    orderBy?: ContentVersionOrderByWithRelationInput | ContentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentVersions.
     */
    cursor?: ContentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentVersions.
     */
    distinct?: ContentVersionScalarFieldEnum | ContentVersionScalarFieldEnum[]
  }

  /**
   * ContentVersion findMany
   */
  export type ContentVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ContentVersions to fetch.
     */
    where?: ContentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentVersions to fetch.
     */
    orderBy?: ContentVersionOrderByWithRelationInput | ContentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentVersions.
     */
    cursor?: ContentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentVersions.
     */
    skip?: number
    distinct?: ContentVersionScalarFieldEnum | ContentVersionScalarFieldEnum[]
  }

  /**
   * ContentVersion create
   */
  export type ContentVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentVersion.
     */
    data: XOR<ContentVersionCreateInput, ContentVersionUncheckedCreateInput>
  }

  /**
   * ContentVersion createMany
   */
  export type ContentVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentVersions.
     */
    data: ContentVersionCreateManyInput | ContentVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentVersion createManyAndReturn
   */
  export type ContentVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * The data used to create many ContentVersions.
     */
    data: ContentVersionCreateManyInput | ContentVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentVersion update
   */
  export type ContentVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentVersion.
     */
    data: XOR<ContentVersionUpdateInput, ContentVersionUncheckedUpdateInput>
    /**
     * Choose, which ContentVersion to update.
     */
    where: ContentVersionWhereUniqueInput
  }

  /**
   * ContentVersion updateMany
   */
  export type ContentVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentVersions.
     */
    data: XOR<ContentVersionUpdateManyMutationInput, ContentVersionUncheckedUpdateManyInput>
    /**
     * Filter which ContentVersions to update
     */
    where?: ContentVersionWhereInput
    /**
     * Limit how many ContentVersions to update.
     */
    limit?: number
  }

  /**
   * ContentVersion updateManyAndReturn
   */
  export type ContentVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * The data used to update ContentVersions.
     */
    data: XOR<ContentVersionUpdateManyMutationInput, ContentVersionUncheckedUpdateManyInput>
    /**
     * Filter which ContentVersions to update
     */
    where?: ContentVersionWhereInput
    /**
     * Limit how many ContentVersions to update.
     */
    limit?: number
  }

  /**
   * ContentVersion upsert
   */
  export type ContentVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentVersion to update in case it exists.
     */
    where: ContentVersionWhereUniqueInput
    /**
     * In case the ContentVersion found by the `where` argument doesn't exist, create a new ContentVersion with this data.
     */
    create: XOR<ContentVersionCreateInput, ContentVersionUncheckedCreateInput>
    /**
     * In case the ContentVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentVersionUpdateInput, ContentVersionUncheckedUpdateInput>
  }

  /**
   * ContentVersion delete
   */
  export type ContentVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * Filter which ContentVersion to delete.
     */
    where: ContentVersionWhereUniqueInput
  }

  /**
   * ContentVersion deleteMany
   */
  export type ContentVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentVersions to delete
     */
    where?: ContentVersionWhereInput
    /**
     * Limit how many ContentVersions to delete.
     */
    limit?: number
  }

  /**
   * ContentVersion.reviews
   */
  export type ContentVersion$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReview
     */
    select?: ContentReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentReview
     */
    omit?: ContentReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReviewInclude<ExtArgs> | null
    where?: ContentReviewWhereInput
    orderBy?: ContentReviewOrderByWithRelationInput | ContentReviewOrderByWithRelationInput[]
    cursor?: ContentReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentReviewScalarFieldEnum | ContentReviewScalarFieldEnum[]
  }

  /**
   * ContentVersion without action
   */
  export type ContentVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
  }


  /**
   * Model ContentReview
   */

  export type AggregateContentReview = {
    _count: ContentReviewCountAggregateOutputType | null
    _min: ContentReviewMinAggregateOutputType | null
    _max: ContentReviewMaxAggregateOutputType | null
  }

  export type ContentReviewMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    versionId: string | null
    status: $Enums.ReviewStatus | null
    reviewer: string | null
    comments: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type ContentReviewMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    versionId: string | null
    status: $Enums.ReviewStatus | null
    reviewer: string | null
    comments: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type ContentReviewCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    versionId: number
    status: number
    reviewer: number
    comments: number
    reviewedAt: number
    createdAt: number
    _all: number
  }


  export type ContentReviewMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    versionId?: true
    status?: true
    reviewer?: true
    comments?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type ContentReviewMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    versionId?: true
    status?: true
    reviewer?: true
    comments?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type ContentReviewCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    versionId?: true
    status?: true
    reviewer?: true
    comments?: true
    reviewedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ContentReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentReview to aggregate.
     */
    where?: ContentReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentReviews to fetch.
     */
    orderBy?: ContentReviewOrderByWithRelationInput | ContentReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentReviews
    **/
    _count?: true | ContentReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentReviewMaxAggregateInputType
  }

  export type GetContentReviewAggregateType<T extends ContentReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateContentReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentReview[P]>
      : GetScalarType<T[P], AggregateContentReview[P]>
  }




  export type ContentReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentReviewWhereInput
    orderBy?: ContentReviewOrderByWithAggregationInput | ContentReviewOrderByWithAggregationInput[]
    by: ContentReviewScalarFieldEnum[] | ContentReviewScalarFieldEnum
    having?: ContentReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentReviewCountAggregateInputType | true
    _min?: ContentReviewMinAggregateInputType
    _max?: ContentReviewMaxAggregateInputType
  }

  export type ContentReviewGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    versionId: string
    status: $Enums.ReviewStatus
    reviewer: string | null
    comments: string | null
    reviewedAt: Date | null
    createdAt: Date
    _count: ContentReviewCountAggregateOutputType | null
    _min: ContentReviewMinAggregateOutputType | null
    _max: ContentReviewMaxAggregateOutputType | null
  }

  type GetContentReviewGroupByPayload<T extends ContentReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ContentReviewGroupByOutputType[P]>
        }
      >
    >


  export type ContentReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    versionId?: boolean
    status?: boolean
    reviewer?: boolean
    comments?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    version?: boolean | ContentVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentReview"]>

  export type ContentReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    versionId?: boolean
    status?: boolean
    reviewer?: boolean
    comments?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    version?: boolean | ContentVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentReview"]>

  export type ContentReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    versionId?: boolean
    status?: boolean
    reviewer?: boolean
    comments?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    version?: boolean | ContentVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentReview"]>

  export type ContentReviewSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    versionId?: boolean
    status?: boolean
    reviewer?: boolean
    comments?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
  }

  export type ContentReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "versionId" | "status" | "reviewer" | "comments" | "reviewedAt" | "createdAt", ExtArgs["result"]["contentReview"]>
  export type ContentReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version?: boolean | ContentVersionDefaultArgs<ExtArgs>
  }
  export type ContentReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version?: boolean | ContentVersionDefaultArgs<ExtArgs>
  }
  export type ContentReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version?: boolean | ContentVersionDefaultArgs<ExtArgs>
  }

  export type $ContentReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentReview"
    objects: {
      version: Prisma.$ContentVersionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      versionId: string
      status: $Enums.ReviewStatus
      reviewer: string | null
      comments: string | null
      reviewedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["contentReview"]>
    composites: {}
  }

  type ContentReviewGetPayload<S extends boolean | null | undefined | ContentReviewDefaultArgs> = $Result.GetResult<Prisma.$ContentReviewPayload, S>

  type ContentReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentReviewCountAggregateInputType | true
    }

  export interface ContentReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentReview'], meta: { name: 'ContentReview' } }
    /**
     * Find zero or one ContentReview that matches the filter.
     * @param {ContentReviewFindUniqueArgs} args - Arguments to find a ContentReview
     * @example
     * // Get one ContentReview
     * const contentReview = await prisma.contentReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentReviewFindUniqueArgs>(args: SelectSubset<T, ContentReviewFindUniqueArgs<ExtArgs>>): Prisma__ContentReviewClient<$Result.GetResult<Prisma.$ContentReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentReviewFindUniqueOrThrowArgs} args - Arguments to find a ContentReview
     * @example
     * // Get one ContentReview
     * const contentReview = await prisma.contentReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentReviewClient<$Result.GetResult<Prisma.$ContentReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReviewFindFirstArgs} args - Arguments to find a ContentReview
     * @example
     * // Get one ContentReview
     * const contentReview = await prisma.contentReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentReviewFindFirstArgs>(args?: SelectSubset<T, ContentReviewFindFirstArgs<ExtArgs>>): Prisma__ContentReviewClient<$Result.GetResult<Prisma.$ContentReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReviewFindFirstOrThrowArgs} args - Arguments to find a ContentReview
     * @example
     * // Get one ContentReview
     * const contentReview = await prisma.contentReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentReviewClient<$Result.GetResult<Prisma.$ContentReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentReviews
     * const contentReviews = await prisma.contentReview.findMany()
     * 
     * // Get first 10 ContentReviews
     * const contentReviews = await prisma.contentReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentReviewWithIdOnly = await prisma.contentReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentReviewFindManyArgs>(args?: SelectSubset<T, ContentReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentReview.
     * @param {ContentReviewCreateArgs} args - Arguments to create a ContentReview.
     * @example
     * // Create one ContentReview
     * const ContentReview = await prisma.contentReview.create({
     *   data: {
     *     // ... data to create a ContentReview
     *   }
     * })
     * 
     */
    create<T extends ContentReviewCreateArgs>(args: SelectSubset<T, ContentReviewCreateArgs<ExtArgs>>): Prisma__ContentReviewClient<$Result.GetResult<Prisma.$ContentReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentReviews.
     * @param {ContentReviewCreateManyArgs} args - Arguments to create many ContentReviews.
     * @example
     * // Create many ContentReviews
     * const contentReview = await prisma.contentReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentReviewCreateManyArgs>(args?: SelectSubset<T, ContentReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentReviews and returns the data saved in the database.
     * @param {ContentReviewCreateManyAndReturnArgs} args - Arguments to create many ContentReviews.
     * @example
     * // Create many ContentReviews
     * const contentReview = await prisma.contentReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentReviews and only return the `id`
     * const contentReviewWithIdOnly = await prisma.contentReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentReview.
     * @param {ContentReviewDeleteArgs} args - Arguments to delete one ContentReview.
     * @example
     * // Delete one ContentReview
     * const ContentReview = await prisma.contentReview.delete({
     *   where: {
     *     // ... filter to delete one ContentReview
     *   }
     * })
     * 
     */
    delete<T extends ContentReviewDeleteArgs>(args: SelectSubset<T, ContentReviewDeleteArgs<ExtArgs>>): Prisma__ContentReviewClient<$Result.GetResult<Prisma.$ContentReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentReview.
     * @param {ContentReviewUpdateArgs} args - Arguments to update one ContentReview.
     * @example
     * // Update one ContentReview
     * const contentReview = await prisma.contentReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentReviewUpdateArgs>(args: SelectSubset<T, ContentReviewUpdateArgs<ExtArgs>>): Prisma__ContentReviewClient<$Result.GetResult<Prisma.$ContentReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentReviews.
     * @param {ContentReviewDeleteManyArgs} args - Arguments to filter ContentReviews to delete.
     * @example
     * // Delete a few ContentReviews
     * const { count } = await prisma.contentReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentReviewDeleteManyArgs>(args?: SelectSubset<T, ContentReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentReviews
     * const contentReview = await prisma.contentReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentReviewUpdateManyArgs>(args: SelectSubset<T, ContentReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentReviews and returns the data updated in the database.
     * @param {ContentReviewUpdateManyAndReturnArgs} args - Arguments to update many ContentReviews.
     * @example
     * // Update many ContentReviews
     * const contentReview = await prisma.contentReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentReviews and only return the `id`
     * const contentReviewWithIdOnly = await prisma.contentReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentReview.
     * @param {ContentReviewUpsertArgs} args - Arguments to update or create a ContentReview.
     * @example
     * // Update or create a ContentReview
     * const contentReview = await prisma.contentReview.upsert({
     *   create: {
     *     // ... data to create a ContentReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentReview we want to update
     *   }
     * })
     */
    upsert<T extends ContentReviewUpsertArgs>(args: SelectSubset<T, ContentReviewUpsertArgs<ExtArgs>>): Prisma__ContentReviewClient<$Result.GetResult<Prisma.$ContentReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReviewCountArgs} args - Arguments to filter ContentReviews to count.
     * @example
     * // Count the number of ContentReviews
     * const count = await prisma.contentReview.count({
     *   where: {
     *     // ... the filter for the ContentReviews we want to count
     *   }
     * })
    **/
    count<T extends ContentReviewCountArgs>(
      args?: Subset<T, ContentReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentReviewAggregateArgs>(args: Subset<T, ContentReviewAggregateArgs>): Prisma.PrismaPromise<GetContentReviewAggregateType<T>>

    /**
     * Group by ContentReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentReviewGroupByArgs['orderBy'] }
        : { orderBy?: ContentReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentReview model
   */
  readonly fields: ContentReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    version<T extends ContentVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentVersionDefaultArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentReview model
   */
  interface ContentReviewFieldRefs {
    readonly id: FieldRef<"ContentReview", 'String'>
    readonly entityType: FieldRef<"ContentReview", 'String'>
    readonly entityId: FieldRef<"ContentReview", 'String'>
    readonly versionId: FieldRef<"ContentReview", 'String'>
    readonly status: FieldRef<"ContentReview", 'ReviewStatus'>
    readonly reviewer: FieldRef<"ContentReview", 'String'>
    readonly comments: FieldRef<"ContentReview", 'String'>
    readonly reviewedAt: FieldRef<"ContentReview", 'DateTime'>
    readonly createdAt: FieldRef<"ContentReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentReview findUnique
   */
  export type ContentReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReview
     */
    select?: ContentReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentReview
     */
    omit?: ContentReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReviewInclude<ExtArgs> | null
    /**
     * Filter, which ContentReview to fetch.
     */
    where: ContentReviewWhereUniqueInput
  }

  /**
   * ContentReview findUniqueOrThrow
   */
  export type ContentReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReview
     */
    select?: ContentReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentReview
     */
    omit?: ContentReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReviewInclude<ExtArgs> | null
    /**
     * Filter, which ContentReview to fetch.
     */
    where: ContentReviewWhereUniqueInput
  }

  /**
   * ContentReview findFirst
   */
  export type ContentReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReview
     */
    select?: ContentReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentReview
     */
    omit?: ContentReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReviewInclude<ExtArgs> | null
    /**
     * Filter, which ContentReview to fetch.
     */
    where?: ContentReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentReviews to fetch.
     */
    orderBy?: ContentReviewOrderByWithRelationInput | ContentReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentReviews.
     */
    cursor?: ContentReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentReviews.
     */
    distinct?: ContentReviewScalarFieldEnum | ContentReviewScalarFieldEnum[]
  }

  /**
   * ContentReview findFirstOrThrow
   */
  export type ContentReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReview
     */
    select?: ContentReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentReview
     */
    omit?: ContentReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReviewInclude<ExtArgs> | null
    /**
     * Filter, which ContentReview to fetch.
     */
    where?: ContentReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentReviews to fetch.
     */
    orderBy?: ContentReviewOrderByWithRelationInput | ContentReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentReviews.
     */
    cursor?: ContentReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentReviews.
     */
    distinct?: ContentReviewScalarFieldEnum | ContentReviewScalarFieldEnum[]
  }

  /**
   * ContentReview findMany
   */
  export type ContentReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReview
     */
    select?: ContentReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentReview
     */
    omit?: ContentReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReviewInclude<ExtArgs> | null
    /**
     * Filter, which ContentReviews to fetch.
     */
    where?: ContentReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentReviews to fetch.
     */
    orderBy?: ContentReviewOrderByWithRelationInput | ContentReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentReviews.
     */
    cursor?: ContentReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentReviews.
     */
    skip?: number
    distinct?: ContentReviewScalarFieldEnum | ContentReviewScalarFieldEnum[]
  }

  /**
   * ContentReview create
   */
  export type ContentReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReview
     */
    select?: ContentReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentReview
     */
    omit?: ContentReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentReview.
     */
    data: XOR<ContentReviewCreateInput, ContentReviewUncheckedCreateInput>
  }

  /**
   * ContentReview createMany
   */
  export type ContentReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentReviews.
     */
    data: ContentReviewCreateManyInput | ContentReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentReview createManyAndReturn
   */
  export type ContentReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReview
     */
    select?: ContentReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentReview
     */
    omit?: ContentReviewOmit<ExtArgs> | null
    /**
     * The data used to create many ContentReviews.
     */
    data: ContentReviewCreateManyInput | ContentReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentReview update
   */
  export type ContentReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReview
     */
    select?: ContentReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentReview
     */
    omit?: ContentReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentReview.
     */
    data: XOR<ContentReviewUpdateInput, ContentReviewUncheckedUpdateInput>
    /**
     * Choose, which ContentReview to update.
     */
    where: ContentReviewWhereUniqueInput
  }

  /**
   * ContentReview updateMany
   */
  export type ContentReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentReviews.
     */
    data: XOR<ContentReviewUpdateManyMutationInput, ContentReviewUncheckedUpdateManyInput>
    /**
     * Filter which ContentReviews to update
     */
    where?: ContentReviewWhereInput
    /**
     * Limit how many ContentReviews to update.
     */
    limit?: number
  }

  /**
   * ContentReview updateManyAndReturn
   */
  export type ContentReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReview
     */
    select?: ContentReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentReview
     */
    omit?: ContentReviewOmit<ExtArgs> | null
    /**
     * The data used to update ContentReviews.
     */
    data: XOR<ContentReviewUpdateManyMutationInput, ContentReviewUncheckedUpdateManyInput>
    /**
     * Filter which ContentReviews to update
     */
    where?: ContentReviewWhereInput
    /**
     * Limit how many ContentReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentReview upsert
   */
  export type ContentReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReview
     */
    select?: ContentReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentReview
     */
    omit?: ContentReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentReview to update in case it exists.
     */
    where: ContentReviewWhereUniqueInput
    /**
     * In case the ContentReview found by the `where` argument doesn't exist, create a new ContentReview with this data.
     */
    create: XOR<ContentReviewCreateInput, ContentReviewUncheckedCreateInput>
    /**
     * In case the ContentReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentReviewUpdateInput, ContentReviewUncheckedUpdateInput>
  }

  /**
   * ContentReview delete
   */
  export type ContentReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReview
     */
    select?: ContentReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentReview
     */
    omit?: ContentReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReviewInclude<ExtArgs> | null
    /**
     * Filter which ContentReview to delete.
     */
    where: ContentReviewWhereUniqueInput
  }

  /**
   * ContentReview deleteMany
   */
  export type ContentReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentReviews to delete
     */
    where?: ContentReviewWhereInput
    /**
     * Limit how many ContentReviews to delete.
     */
    limit?: number
  }

  /**
   * ContentReview without action
   */
  export type ContentReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReview
     */
    select?: ContentReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentReview
     */
    omit?: ContentReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReviewInclude<ExtArgs> | null
  }


  /**
   * Model ContentUpdateTask
   */

  export type AggregateContentUpdateTask = {
    _count: ContentUpdateTaskCountAggregateOutputType | null
    _min: ContentUpdateTaskMinAggregateOutputType | null
    _max: ContentUpdateTaskMaxAggregateOutputType | null
  }

  export type ContentUpdateTaskMinAggregateOutputType = {
    id: string | null
    taskType: $Enums.TaskType | null
    entityType: string | null
    entityId: string | null
    priority: $Enums.Priority | null
    status: $Enums.TaskStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentUpdateTaskMaxAggregateOutputType = {
    id: string | null
    taskType: $Enums.TaskType | null
    entityType: string | null
    entityId: string | null
    priority: $Enums.Priority | null
    status: $Enums.TaskStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentUpdateTaskCountAggregateOutputType = {
    id: number
    taskType: number
    entityType: number
    entityId: number
    priority: number
    status: number
    scheduledAt: number
    startedAt: number
    completedAt: number
    errorMessage: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContentUpdateTaskMinAggregateInputType = {
    id?: true
    taskType?: true
    entityType?: true
    entityId?: true
    priority?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentUpdateTaskMaxAggregateInputType = {
    id?: true
    taskType?: true
    entityType?: true
    entityId?: true
    priority?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentUpdateTaskCountAggregateInputType = {
    id?: true
    taskType?: true
    entityType?: true
    entityId?: true
    priority?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContentUpdateTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentUpdateTask to aggregate.
     */
    where?: ContentUpdateTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentUpdateTasks to fetch.
     */
    orderBy?: ContentUpdateTaskOrderByWithRelationInput | ContentUpdateTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentUpdateTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentUpdateTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentUpdateTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentUpdateTasks
    **/
    _count?: true | ContentUpdateTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentUpdateTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentUpdateTaskMaxAggregateInputType
  }

  export type GetContentUpdateTaskAggregateType<T extends ContentUpdateTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateContentUpdateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentUpdateTask[P]>
      : GetScalarType<T[P], AggregateContentUpdateTask[P]>
  }




  export type ContentUpdateTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentUpdateTaskWhereInput
    orderBy?: ContentUpdateTaskOrderByWithAggregationInput | ContentUpdateTaskOrderByWithAggregationInput[]
    by: ContentUpdateTaskScalarFieldEnum[] | ContentUpdateTaskScalarFieldEnum
    having?: ContentUpdateTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentUpdateTaskCountAggregateInputType | true
    _min?: ContentUpdateTaskMinAggregateInputType
    _max?: ContentUpdateTaskMaxAggregateInputType
  }

  export type ContentUpdateTaskGroupByOutputType = {
    id: string
    taskType: $Enums.TaskType
    entityType: string | null
    entityId: string | null
    priority: $Enums.Priority
    status: $Enums.TaskStatus
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ContentUpdateTaskCountAggregateOutputType | null
    _min: ContentUpdateTaskMinAggregateOutputType | null
    _max: ContentUpdateTaskMaxAggregateOutputType | null
  }

  type GetContentUpdateTaskGroupByPayload<T extends ContentUpdateTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentUpdateTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentUpdateTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentUpdateTaskGroupByOutputType[P]>
            : GetScalarType<T[P], ContentUpdateTaskGroupByOutputType[P]>
        }
      >
    >


  export type ContentUpdateTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskType?: boolean
    entityType?: boolean
    entityId?: boolean
    priority?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contentUpdateTask"]>

  export type ContentUpdateTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskType?: boolean
    entityType?: boolean
    entityId?: boolean
    priority?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contentUpdateTask"]>

  export type ContentUpdateTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskType?: boolean
    entityType?: boolean
    entityId?: boolean
    priority?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contentUpdateTask"]>

  export type ContentUpdateTaskSelectScalar = {
    id?: boolean
    taskType?: boolean
    entityType?: boolean
    entityId?: boolean
    priority?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContentUpdateTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskType" | "entityType" | "entityId" | "priority" | "status" | "scheduledAt" | "startedAt" | "completedAt" | "errorMessage" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["contentUpdateTask"]>

  export type $ContentUpdateTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentUpdateTask"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskType: $Enums.TaskType
      entityType: string | null
      entityId: string | null
      priority: $Enums.Priority
      status: $Enums.TaskStatus
      scheduledAt: Date | null
      startedAt: Date | null
      completedAt: Date | null
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contentUpdateTask"]>
    composites: {}
  }

  type ContentUpdateTaskGetPayload<S extends boolean | null | undefined | ContentUpdateTaskDefaultArgs> = $Result.GetResult<Prisma.$ContentUpdateTaskPayload, S>

  type ContentUpdateTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentUpdateTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentUpdateTaskCountAggregateInputType | true
    }

  export interface ContentUpdateTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentUpdateTask'], meta: { name: 'ContentUpdateTask' } }
    /**
     * Find zero or one ContentUpdateTask that matches the filter.
     * @param {ContentUpdateTaskFindUniqueArgs} args - Arguments to find a ContentUpdateTask
     * @example
     * // Get one ContentUpdateTask
     * const contentUpdateTask = await prisma.contentUpdateTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentUpdateTaskFindUniqueArgs>(args: SelectSubset<T, ContentUpdateTaskFindUniqueArgs<ExtArgs>>): Prisma__ContentUpdateTaskClient<$Result.GetResult<Prisma.$ContentUpdateTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentUpdateTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentUpdateTaskFindUniqueOrThrowArgs} args - Arguments to find a ContentUpdateTask
     * @example
     * // Get one ContentUpdateTask
     * const contentUpdateTask = await prisma.contentUpdateTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentUpdateTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentUpdateTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentUpdateTaskClient<$Result.GetResult<Prisma.$ContentUpdateTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentUpdateTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateTaskFindFirstArgs} args - Arguments to find a ContentUpdateTask
     * @example
     * // Get one ContentUpdateTask
     * const contentUpdateTask = await prisma.contentUpdateTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentUpdateTaskFindFirstArgs>(args?: SelectSubset<T, ContentUpdateTaskFindFirstArgs<ExtArgs>>): Prisma__ContentUpdateTaskClient<$Result.GetResult<Prisma.$ContentUpdateTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentUpdateTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateTaskFindFirstOrThrowArgs} args - Arguments to find a ContentUpdateTask
     * @example
     * // Get one ContentUpdateTask
     * const contentUpdateTask = await prisma.contentUpdateTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentUpdateTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentUpdateTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentUpdateTaskClient<$Result.GetResult<Prisma.$ContentUpdateTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentUpdateTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentUpdateTasks
     * const contentUpdateTasks = await prisma.contentUpdateTask.findMany()
     * 
     * // Get first 10 ContentUpdateTasks
     * const contentUpdateTasks = await prisma.contentUpdateTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentUpdateTaskWithIdOnly = await prisma.contentUpdateTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentUpdateTaskFindManyArgs>(args?: SelectSubset<T, ContentUpdateTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentUpdateTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentUpdateTask.
     * @param {ContentUpdateTaskCreateArgs} args - Arguments to create a ContentUpdateTask.
     * @example
     * // Create one ContentUpdateTask
     * const ContentUpdateTask = await prisma.contentUpdateTask.create({
     *   data: {
     *     // ... data to create a ContentUpdateTask
     *   }
     * })
     * 
     */
    create<T extends ContentUpdateTaskCreateArgs>(args: SelectSubset<T, ContentUpdateTaskCreateArgs<ExtArgs>>): Prisma__ContentUpdateTaskClient<$Result.GetResult<Prisma.$ContentUpdateTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentUpdateTasks.
     * @param {ContentUpdateTaskCreateManyArgs} args - Arguments to create many ContentUpdateTasks.
     * @example
     * // Create many ContentUpdateTasks
     * const contentUpdateTask = await prisma.contentUpdateTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentUpdateTaskCreateManyArgs>(args?: SelectSubset<T, ContentUpdateTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentUpdateTasks and returns the data saved in the database.
     * @param {ContentUpdateTaskCreateManyAndReturnArgs} args - Arguments to create many ContentUpdateTasks.
     * @example
     * // Create many ContentUpdateTasks
     * const contentUpdateTask = await prisma.contentUpdateTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentUpdateTasks and only return the `id`
     * const contentUpdateTaskWithIdOnly = await prisma.contentUpdateTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentUpdateTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentUpdateTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentUpdateTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentUpdateTask.
     * @param {ContentUpdateTaskDeleteArgs} args - Arguments to delete one ContentUpdateTask.
     * @example
     * // Delete one ContentUpdateTask
     * const ContentUpdateTask = await prisma.contentUpdateTask.delete({
     *   where: {
     *     // ... filter to delete one ContentUpdateTask
     *   }
     * })
     * 
     */
    delete<T extends ContentUpdateTaskDeleteArgs>(args: SelectSubset<T, ContentUpdateTaskDeleteArgs<ExtArgs>>): Prisma__ContentUpdateTaskClient<$Result.GetResult<Prisma.$ContentUpdateTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentUpdateTask.
     * @param {ContentUpdateTaskUpdateArgs} args - Arguments to update one ContentUpdateTask.
     * @example
     * // Update one ContentUpdateTask
     * const contentUpdateTask = await prisma.contentUpdateTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentUpdateTaskUpdateArgs>(args: SelectSubset<T, ContentUpdateTaskUpdateArgs<ExtArgs>>): Prisma__ContentUpdateTaskClient<$Result.GetResult<Prisma.$ContentUpdateTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentUpdateTasks.
     * @param {ContentUpdateTaskDeleteManyArgs} args - Arguments to filter ContentUpdateTasks to delete.
     * @example
     * // Delete a few ContentUpdateTasks
     * const { count } = await prisma.contentUpdateTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentUpdateTaskDeleteManyArgs>(args?: SelectSubset<T, ContentUpdateTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentUpdateTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentUpdateTasks
     * const contentUpdateTask = await prisma.contentUpdateTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentUpdateTaskUpdateManyArgs>(args: SelectSubset<T, ContentUpdateTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentUpdateTasks and returns the data updated in the database.
     * @param {ContentUpdateTaskUpdateManyAndReturnArgs} args - Arguments to update many ContentUpdateTasks.
     * @example
     * // Update many ContentUpdateTasks
     * const contentUpdateTask = await prisma.contentUpdateTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentUpdateTasks and only return the `id`
     * const contentUpdateTaskWithIdOnly = await prisma.contentUpdateTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentUpdateTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentUpdateTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentUpdateTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentUpdateTask.
     * @param {ContentUpdateTaskUpsertArgs} args - Arguments to update or create a ContentUpdateTask.
     * @example
     * // Update or create a ContentUpdateTask
     * const contentUpdateTask = await prisma.contentUpdateTask.upsert({
     *   create: {
     *     // ... data to create a ContentUpdateTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentUpdateTask we want to update
     *   }
     * })
     */
    upsert<T extends ContentUpdateTaskUpsertArgs>(args: SelectSubset<T, ContentUpdateTaskUpsertArgs<ExtArgs>>): Prisma__ContentUpdateTaskClient<$Result.GetResult<Prisma.$ContentUpdateTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentUpdateTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateTaskCountArgs} args - Arguments to filter ContentUpdateTasks to count.
     * @example
     * // Count the number of ContentUpdateTasks
     * const count = await prisma.contentUpdateTask.count({
     *   where: {
     *     // ... the filter for the ContentUpdateTasks we want to count
     *   }
     * })
    **/
    count<T extends ContentUpdateTaskCountArgs>(
      args?: Subset<T, ContentUpdateTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentUpdateTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentUpdateTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentUpdateTaskAggregateArgs>(args: Subset<T, ContentUpdateTaskAggregateArgs>): Prisma.PrismaPromise<GetContentUpdateTaskAggregateType<T>>

    /**
     * Group by ContentUpdateTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentUpdateTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentUpdateTaskGroupByArgs['orderBy'] }
        : { orderBy?: ContentUpdateTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentUpdateTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentUpdateTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentUpdateTask model
   */
  readonly fields: ContentUpdateTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentUpdateTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentUpdateTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentUpdateTask model
   */
  interface ContentUpdateTaskFieldRefs {
    readonly id: FieldRef<"ContentUpdateTask", 'String'>
    readonly taskType: FieldRef<"ContentUpdateTask", 'TaskType'>
    readonly entityType: FieldRef<"ContentUpdateTask", 'String'>
    readonly entityId: FieldRef<"ContentUpdateTask", 'String'>
    readonly priority: FieldRef<"ContentUpdateTask", 'Priority'>
    readonly status: FieldRef<"ContentUpdateTask", 'TaskStatus'>
    readonly scheduledAt: FieldRef<"ContentUpdateTask", 'DateTime'>
    readonly startedAt: FieldRef<"ContentUpdateTask", 'DateTime'>
    readonly completedAt: FieldRef<"ContentUpdateTask", 'DateTime'>
    readonly errorMessage: FieldRef<"ContentUpdateTask", 'String'>
    readonly metadata: FieldRef<"ContentUpdateTask", 'Json'>
    readonly createdAt: FieldRef<"ContentUpdateTask", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentUpdateTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentUpdateTask findUnique
   */
  export type ContentUpdateTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUpdateTask
     */
    select?: ContentUpdateTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUpdateTask
     */
    omit?: ContentUpdateTaskOmit<ExtArgs> | null
    /**
     * Filter, which ContentUpdateTask to fetch.
     */
    where: ContentUpdateTaskWhereUniqueInput
  }

  /**
   * ContentUpdateTask findUniqueOrThrow
   */
  export type ContentUpdateTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUpdateTask
     */
    select?: ContentUpdateTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUpdateTask
     */
    omit?: ContentUpdateTaskOmit<ExtArgs> | null
    /**
     * Filter, which ContentUpdateTask to fetch.
     */
    where: ContentUpdateTaskWhereUniqueInput
  }

  /**
   * ContentUpdateTask findFirst
   */
  export type ContentUpdateTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUpdateTask
     */
    select?: ContentUpdateTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUpdateTask
     */
    omit?: ContentUpdateTaskOmit<ExtArgs> | null
    /**
     * Filter, which ContentUpdateTask to fetch.
     */
    where?: ContentUpdateTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentUpdateTasks to fetch.
     */
    orderBy?: ContentUpdateTaskOrderByWithRelationInput | ContentUpdateTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentUpdateTasks.
     */
    cursor?: ContentUpdateTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentUpdateTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentUpdateTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentUpdateTasks.
     */
    distinct?: ContentUpdateTaskScalarFieldEnum | ContentUpdateTaskScalarFieldEnum[]
  }

  /**
   * ContentUpdateTask findFirstOrThrow
   */
  export type ContentUpdateTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUpdateTask
     */
    select?: ContentUpdateTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUpdateTask
     */
    omit?: ContentUpdateTaskOmit<ExtArgs> | null
    /**
     * Filter, which ContentUpdateTask to fetch.
     */
    where?: ContentUpdateTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentUpdateTasks to fetch.
     */
    orderBy?: ContentUpdateTaskOrderByWithRelationInput | ContentUpdateTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentUpdateTasks.
     */
    cursor?: ContentUpdateTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentUpdateTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentUpdateTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentUpdateTasks.
     */
    distinct?: ContentUpdateTaskScalarFieldEnum | ContentUpdateTaskScalarFieldEnum[]
  }

  /**
   * ContentUpdateTask findMany
   */
  export type ContentUpdateTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUpdateTask
     */
    select?: ContentUpdateTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUpdateTask
     */
    omit?: ContentUpdateTaskOmit<ExtArgs> | null
    /**
     * Filter, which ContentUpdateTasks to fetch.
     */
    where?: ContentUpdateTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentUpdateTasks to fetch.
     */
    orderBy?: ContentUpdateTaskOrderByWithRelationInput | ContentUpdateTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentUpdateTasks.
     */
    cursor?: ContentUpdateTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentUpdateTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentUpdateTasks.
     */
    skip?: number
    distinct?: ContentUpdateTaskScalarFieldEnum | ContentUpdateTaskScalarFieldEnum[]
  }

  /**
   * ContentUpdateTask create
   */
  export type ContentUpdateTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUpdateTask
     */
    select?: ContentUpdateTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUpdateTask
     */
    omit?: ContentUpdateTaskOmit<ExtArgs> | null
    /**
     * The data needed to create a ContentUpdateTask.
     */
    data: XOR<ContentUpdateTaskCreateInput, ContentUpdateTaskUncheckedCreateInput>
  }

  /**
   * ContentUpdateTask createMany
   */
  export type ContentUpdateTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentUpdateTasks.
     */
    data: ContentUpdateTaskCreateManyInput | ContentUpdateTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentUpdateTask createManyAndReturn
   */
  export type ContentUpdateTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUpdateTask
     */
    select?: ContentUpdateTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUpdateTask
     */
    omit?: ContentUpdateTaskOmit<ExtArgs> | null
    /**
     * The data used to create many ContentUpdateTasks.
     */
    data: ContentUpdateTaskCreateManyInput | ContentUpdateTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentUpdateTask update
   */
  export type ContentUpdateTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUpdateTask
     */
    select?: ContentUpdateTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUpdateTask
     */
    omit?: ContentUpdateTaskOmit<ExtArgs> | null
    /**
     * The data needed to update a ContentUpdateTask.
     */
    data: XOR<ContentUpdateTaskUpdateInput, ContentUpdateTaskUncheckedUpdateInput>
    /**
     * Choose, which ContentUpdateTask to update.
     */
    where: ContentUpdateTaskWhereUniqueInput
  }

  /**
   * ContentUpdateTask updateMany
   */
  export type ContentUpdateTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentUpdateTasks.
     */
    data: XOR<ContentUpdateTaskUpdateManyMutationInput, ContentUpdateTaskUncheckedUpdateManyInput>
    /**
     * Filter which ContentUpdateTasks to update
     */
    where?: ContentUpdateTaskWhereInput
    /**
     * Limit how many ContentUpdateTasks to update.
     */
    limit?: number
  }

  /**
   * ContentUpdateTask updateManyAndReturn
   */
  export type ContentUpdateTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUpdateTask
     */
    select?: ContentUpdateTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUpdateTask
     */
    omit?: ContentUpdateTaskOmit<ExtArgs> | null
    /**
     * The data used to update ContentUpdateTasks.
     */
    data: XOR<ContentUpdateTaskUpdateManyMutationInput, ContentUpdateTaskUncheckedUpdateManyInput>
    /**
     * Filter which ContentUpdateTasks to update
     */
    where?: ContentUpdateTaskWhereInput
    /**
     * Limit how many ContentUpdateTasks to update.
     */
    limit?: number
  }

  /**
   * ContentUpdateTask upsert
   */
  export type ContentUpdateTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUpdateTask
     */
    select?: ContentUpdateTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUpdateTask
     */
    omit?: ContentUpdateTaskOmit<ExtArgs> | null
    /**
     * The filter to search for the ContentUpdateTask to update in case it exists.
     */
    where: ContentUpdateTaskWhereUniqueInput
    /**
     * In case the ContentUpdateTask found by the `where` argument doesn't exist, create a new ContentUpdateTask with this data.
     */
    create: XOR<ContentUpdateTaskCreateInput, ContentUpdateTaskUncheckedCreateInput>
    /**
     * In case the ContentUpdateTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentUpdateTaskUpdateInput, ContentUpdateTaskUncheckedUpdateInput>
  }

  /**
   * ContentUpdateTask delete
   */
  export type ContentUpdateTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUpdateTask
     */
    select?: ContentUpdateTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUpdateTask
     */
    omit?: ContentUpdateTaskOmit<ExtArgs> | null
    /**
     * Filter which ContentUpdateTask to delete.
     */
    where: ContentUpdateTaskWhereUniqueInput
  }

  /**
   * ContentUpdateTask deleteMany
   */
  export type ContentUpdateTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentUpdateTasks to delete
     */
    where?: ContentUpdateTaskWhereInput
    /**
     * Limit how many ContentUpdateTasks to delete.
     */
    limit?: number
  }

  /**
   * ContentUpdateTask without action
   */
  export type ContentUpdateTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUpdateTask
     */
    select?: ContentUpdateTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUpdateTask
     */
    omit?: ContentUpdateTaskOmit<ExtArgs> | null
  }


  /**
   * Model ContentQualityMetric
   */

  export type AggregateContentQualityMetric = {
    _count: ContentQualityMetricCountAggregateOutputType | null
    _avg: ContentQualityMetricAvgAggregateOutputType | null
    _sum: ContentQualityMetricSumAggregateOutputType | null
    _min: ContentQualityMetricMinAggregateOutputType | null
    _max: ContentQualityMetricMaxAggregateOutputType | null
  }

  export type ContentQualityMetricAvgAggregateOutputType = {
    score: number | null
  }

  export type ContentQualityMetricSumAggregateOutputType = {
    score: number | null
  }

  export type ContentQualityMetricMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    metricType: string | null
    score: number | null
    measuredAt: Date | null
  }

  export type ContentQualityMetricMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    metricType: string | null
    score: number | null
    measuredAt: Date | null
  }

  export type ContentQualityMetricCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    metricType: number
    score: number
    details: number
    measuredAt: number
    _all: number
  }


  export type ContentQualityMetricAvgAggregateInputType = {
    score?: true
  }

  export type ContentQualityMetricSumAggregateInputType = {
    score?: true
  }

  export type ContentQualityMetricMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    metricType?: true
    score?: true
    measuredAt?: true
  }

  export type ContentQualityMetricMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    metricType?: true
    score?: true
    measuredAt?: true
  }

  export type ContentQualityMetricCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    metricType?: true
    score?: true
    details?: true
    measuredAt?: true
    _all?: true
  }

  export type ContentQualityMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentQualityMetric to aggregate.
     */
    where?: ContentQualityMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentQualityMetrics to fetch.
     */
    orderBy?: ContentQualityMetricOrderByWithRelationInput | ContentQualityMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentQualityMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentQualityMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentQualityMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentQualityMetrics
    **/
    _count?: true | ContentQualityMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentQualityMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentQualityMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentQualityMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentQualityMetricMaxAggregateInputType
  }

  export type GetContentQualityMetricAggregateType<T extends ContentQualityMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateContentQualityMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentQualityMetric[P]>
      : GetScalarType<T[P], AggregateContentQualityMetric[P]>
  }




  export type ContentQualityMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentQualityMetricWhereInput
    orderBy?: ContentQualityMetricOrderByWithAggregationInput | ContentQualityMetricOrderByWithAggregationInput[]
    by: ContentQualityMetricScalarFieldEnum[] | ContentQualityMetricScalarFieldEnum
    having?: ContentQualityMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentQualityMetricCountAggregateInputType | true
    _avg?: ContentQualityMetricAvgAggregateInputType
    _sum?: ContentQualityMetricSumAggregateInputType
    _min?: ContentQualityMetricMinAggregateInputType
    _max?: ContentQualityMetricMaxAggregateInputType
  }

  export type ContentQualityMetricGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    metricType: string
    score: number
    details: JsonValue | null
    measuredAt: Date
    _count: ContentQualityMetricCountAggregateOutputType | null
    _avg: ContentQualityMetricAvgAggregateOutputType | null
    _sum: ContentQualityMetricSumAggregateOutputType | null
    _min: ContentQualityMetricMinAggregateOutputType | null
    _max: ContentQualityMetricMaxAggregateOutputType | null
  }

  type GetContentQualityMetricGroupByPayload<T extends ContentQualityMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentQualityMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentQualityMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentQualityMetricGroupByOutputType[P]>
            : GetScalarType<T[P], ContentQualityMetricGroupByOutputType[P]>
        }
      >
    >


  export type ContentQualityMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    metricType?: boolean
    score?: boolean
    details?: boolean
    measuredAt?: boolean
  }, ExtArgs["result"]["contentQualityMetric"]>

  export type ContentQualityMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    metricType?: boolean
    score?: boolean
    details?: boolean
    measuredAt?: boolean
  }, ExtArgs["result"]["contentQualityMetric"]>

  export type ContentQualityMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    metricType?: boolean
    score?: boolean
    details?: boolean
    measuredAt?: boolean
  }, ExtArgs["result"]["contentQualityMetric"]>

  export type ContentQualityMetricSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    metricType?: boolean
    score?: boolean
    details?: boolean
    measuredAt?: boolean
  }

  export type ContentQualityMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "metricType" | "score" | "details" | "measuredAt", ExtArgs["result"]["contentQualityMetric"]>

  export type $ContentQualityMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentQualityMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      metricType: string
      score: number
      details: Prisma.JsonValue | null
      measuredAt: Date
    }, ExtArgs["result"]["contentQualityMetric"]>
    composites: {}
  }

  type ContentQualityMetricGetPayload<S extends boolean | null | undefined | ContentQualityMetricDefaultArgs> = $Result.GetResult<Prisma.$ContentQualityMetricPayload, S>

  type ContentQualityMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentQualityMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentQualityMetricCountAggregateInputType | true
    }

  export interface ContentQualityMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentQualityMetric'], meta: { name: 'ContentQualityMetric' } }
    /**
     * Find zero or one ContentQualityMetric that matches the filter.
     * @param {ContentQualityMetricFindUniqueArgs} args - Arguments to find a ContentQualityMetric
     * @example
     * // Get one ContentQualityMetric
     * const contentQualityMetric = await prisma.contentQualityMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentQualityMetricFindUniqueArgs>(args: SelectSubset<T, ContentQualityMetricFindUniqueArgs<ExtArgs>>): Prisma__ContentQualityMetricClient<$Result.GetResult<Prisma.$ContentQualityMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentQualityMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentQualityMetricFindUniqueOrThrowArgs} args - Arguments to find a ContentQualityMetric
     * @example
     * // Get one ContentQualityMetric
     * const contentQualityMetric = await prisma.contentQualityMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentQualityMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentQualityMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentQualityMetricClient<$Result.GetResult<Prisma.$ContentQualityMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentQualityMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentQualityMetricFindFirstArgs} args - Arguments to find a ContentQualityMetric
     * @example
     * // Get one ContentQualityMetric
     * const contentQualityMetric = await prisma.contentQualityMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentQualityMetricFindFirstArgs>(args?: SelectSubset<T, ContentQualityMetricFindFirstArgs<ExtArgs>>): Prisma__ContentQualityMetricClient<$Result.GetResult<Prisma.$ContentQualityMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentQualityMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentQualityMetricFindFirstOrThrowArgs} args - Arguments to find a ContentQualityMetric
     * @example
     * // Get one ContentQualityMetric
     * const contentQualityMetric = await prisma.contentQualityMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentQualityMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentQualityMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentQualityMetricClient<$Result.GetResult<Prisma.$ContentQualityMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentQualityMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentQualityMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentQualityMetrics
     * const contentQualityMetrics = await prisma.contentQualityMetric.findMany()
     * 
     * // Get first 10 ContentQualityMetrics
     * const contentQualityMetrics = await prisma.contentQualityMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentQualityMetricWithIdOnly = await prisma.contentQualityMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentQualityMetricFindManyArgs>(args?: SelectSubset<T, ContentQualityMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentQualityMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentQualityMetric.
     * @param {ContentQualityMetricCreateArgs} args - Arguments to create a ContentQualityMetric.
     * @example
     * // Create one ContentQualityMetric
     * const ContentQualityMetric = await prisma.contentQualityMetric.create({
     *   data: {
     *     // ... data to create a ContentQualityMetric
     *   }
     * })
     * 
     */
    create<T extends ContentQualityMetricCreateArgs>(args: SelectSubset<T, ContentQualityMetricCreateArgs<ExtArgs>>): Prisma__ContentQualityMetricClient<$Result.GetResult<Prisma.$ContentQualityMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentQualityMetrics.
     * @param {ContentQualityMetricCreateManyArgs} args - Arguments to create many ContentQualityMetrics.
     * @example
     * // Create many ContentQualityMetrics
     * const contentQualityMetric = await prisma.contentQualityMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentQualityMetricCreateManyArgs>(args?: SelectSubset<T, ContentQualityMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentQualityMetrics and returns the data saved in the database.
     * @param {ContentQualityMetricCreateManyAndReturnArgs} args - Arguments to create many ContentQualityMetrics.
     * @example
     * // Create many ContentQualityMetrics
     * const contentQualityMetric = await prisma.contentQualityMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentQualityMetrics and only return the `id`
     * const contentQualityMetricWithIdOnly = await prisma.contentQualityMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentQualityMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentQualityMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentQualityMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentQualityMetric.
     * @param {ContentQualityMetricDeleteArgs} args - Arguments to delete one ContentQualityMetric.
     * @example
     * // Delete one ContentQualityMetric
     * const ContentQualityMetric = await prisma.contentQualityMetric.delete({
     *   where: {
     *     // ... filter to delete one ContentQualityMetric
     *   }
     * })
     * 
     */
    delete<T extends ContentQualityMetricDeleteArgs>(args: SelectSubset<T, ContentQualityMetricDeleteArgs<ExtArgs>>): Prisma__ContentQualityMetricClient<$Result.GetResult<Prisma.$ContentQualityMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentQualityMetric.
     * @param {ContentQualityMetricUpdateArgs} args - Arguments to update one ContentQualityMetric.
     * @example
     * // Update one ContentQualityMetric
     * const contentQualityMetric = await prisma.contentQualityMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentQualityMetricUpdateArgs>(args: SelectSubset<T, ContentQualityMetricUpdateArgs<ExtArgs>>): Prisma__ContentQualityMetricClient<$Result.GetResult<Prisma.$ContentQualityMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentQualityMetrics.
     * @param {ContentQualityMetricDeleteManyArgs} args - Arguments to filter ContentQualityMetrics to delete.
     * @example
     * // Delete a few ContentQualityMetrics
     * const { count } = await prisma.contentQualityMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentQualityMetricDeleteManyArgs>(args?: SelectSubset<T, ContentQualityMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentQualityMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentQualityMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentQualityMetrics
     * const contentQualityMetric = await prisma.contentQualityMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentQualityMetricUpdateManyArgs>(args: SelectSubset<T, ContentQualityMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentQualityMetrics and returns the data updated in the database.
     * @param {ContentQualityMetricUpdateManyAndReturnArgs} args - Arguments to update many ContentQualityMetrics.
     * @example
     * // Update many ContentQualityMetrics
     * const contentQualityMetric = await prisma.contentQualityMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentQualityMetrics and only return the `id`
     * const contentQualityMetricWithIdOnly = await prisma.contentQualityMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentQualityMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentQualityMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentQualityMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentQualityMetric.
     * @param {ContentQualityMetricUpsertArgs} args - Arguments to update or create a ContentQualityMetric.
     * @example
     * // Update or create a ContentQualityMetric
     * const contentQualityMetric = await prisma.contentQualityMetric.upsert({
     *   create: {
     *     // ... data to create a ContentQualityMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentQualityMetric we want to update
     *   }
     * })
     */
    upsert<T extends ContentQualityMetricUpsertArgs>(args: SelectSubset<T, ContentQualityMetricUpsertArgs<ExtArgs>>): Prisma__ContentQualityMetricClient<$Result.GetResult<Prisma.$ContentQualityMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentQualityMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentQualityMetricCountArgs} args - Arguments to filter ContentQualityMetrics to count.
     * @example
     * // Count the number of ContentQualityMetrics
     * const count = await prisma.contentQualityMetric.count({
     *   where: {
     *     // ... the filter for the ContentQualityMetrics we want to count
     *   }
     * })
    **/
    count<T extends ContentQualityMetricCountArgs>(
      args?: Subset<T, ContentQualityMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentQualityMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentQualityMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentQualityMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentQualityMetricAggregateArgs>(args: Subset<T, ContentQualityMetricAggregateArgs>): Prisma.PrismaPromise<GetContentQualityMetricAggregateType<T>>

    /**
     * Group by ContentQualityMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentQualityMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentQualityMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentQualityMetricGroupByArgs['orderBy'] }
        : { orderBy?: ContentQualityMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentQualityMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentQualityMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentQualityMetric model
   */
  readonly fields: ContentQualityMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentQualityMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentQualityMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentQualityMetric model
   */
  interface ContentQualityMetricFieldRefs {
    readonly id: FieldRef<"ContentQualityMetric", 'String'>
    readonly entityType: FieldRef<"ContentQualityMetric", 'String'>
    readonly entityId: FieldRef<"ContentQualityMetric", 'String'>
    readonly metricType: FieldRef<"ContentQualityMetric", 'String'>
    readonly score: FieldRef<"ContentQualityMetric", 'Float'>
    readonly details: FieldRef<"ContentQualityMetric", 'Json'>
    readonly measuredAt: FieldRef<"ContentQualityMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentQualityMetric findUnique
   */
  export type ContentQualityMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentQualityMetric
     */
    select?: ContentQualityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentQualityMetric
     */
    omit?: ContentQualityMetricOmit<ExtArgs> | null
    /**
     * Filter, which ContentQualityMetric to fetch.
     */
    where: ContentQualityMetricWhereUniqueInput
  }

  /**
   * ContentQualityMetric findUniqueOrThrow
   */
  export type ContentQualityMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentQualityMetric
     */
    select?: ContentQualityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentQualityMetric
     */
    omit?: ContentQualityMetricOmit<ExtArgs> | null
    /**
     * Filter, which ContentQualityMetric to fetch.
     */
    where: ContentQualityMetricWhereUniqueInput
  }

  /**
   * ContentQualityMetric findFirst
   */
  export type ContentQualityMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentQualityMetric
     */
    select?: ContentQualityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentQualityMetric
     */
    omit?: ContentQualityMetricOmit<ExtArgs> | null
    /**
     * Filter, which ContentQualityMetric to fetch.
     */
    where?: ContentQualityMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentQualityMetrics to fetch.
     */
    orderBy?: ContentQualityMetricOrderByWithRelationInput | ContentQualityMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentQualityMetrics.
     */
    cursor?: ContentQualityMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentQualityMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentQualityMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentQualityMetrics.
     */
    distinct?: ContentQualityMetricScalarFieldEnum | ContentQualityMetricScalarFieldEnum[]
  }

  /**
   * ContentQualityMetric findFirstOrThrow
   */
  export type ContentQualityMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentQualityMetric
     */
    select?: ContentQualityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentQualityMetric
     */
    omit?: ContentQualityMetricOmit<ExtArgs> | null
    /**
     * Filter, which ContentQualityMetric to fetch.
     */
    where?: ContentQualityMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentQualityMetrics to fetch.
     */
    orderBy?: ContentQualityMetricOrderByWithRelationInput | ContentQualityMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentQualityMetrics.
     */
    cursor?: ContentQualityMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentQualityMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentQualityMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentQualityMetrics.
     */
    distinct?: ContentQualityMetricScalarFieldEnum | ContentQualityMetricScalarFieldEnum[]
  }

  /**
   * ContentQualityMetric findMany
   */
  export type ContentQualityMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentQualityMetric
     */
    select?: ContentQualityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentQualityMetric
     */
    omit?: ContentQualityMetricOmit<ExtArgs> | null
    /**
     * Filter, which ContentQualityMetrics to fetch.
     */
    where?: ContentQualityMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentQualityMetrics to fetch.
     */
    orderBy?: ContentQualityMetricOrderByWithRelationInput | ContentQualityMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentQualityMetrics.
     */
    cursor?: ContentQualityMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentQualityMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentQualityMetrics.
     */
    skip?: number
    distinct?: ContentQualityMetricScalarFieldEnum | ContentQualityMetricScalarFieldEnum[]
  }

  /**
   * ContentQualityMetric create
   */
  export type ContentQualityMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentQualityMetric
     */
    select?: ContentQualityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentQualityMetric
     */
    omit?: ContentQualityMetricOmit<ExtArgs> | null
    /**
     * The data needed to create a ContentQualityMetric.
     */
    data: XOR<ContentQualityMetricCreateInput, ContentQualityMetricUncheckedCreateInput>
  }

  /**
   * ContentQualityMetric createMany
   */
  export type ContentQualityMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentQualityMetrics.
     */
    data: ContentQualityMetricCreateManyInput | ContentQualityMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentQualityMetric createManyAndReturn
   */
  export type ContentQualityMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentQualityMetric
     */
    select?: ContentQualityMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentQualityMetric
     */
    omit?: ContentQualityMetricOmit<ExtArgs> | null
    /**
     * The data used to create many ContentQualityMetrics.
     */
    data: ContentQualityMetricCreateManyInput | ContentQualityMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentQualityMetric update
   */
  export type ContentQualityMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentQualityMetric
     */
    select?: ContentQualityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentQualityMetric
     */
    omit?: ContentQualityMetricOmit<ExtArgs> | null
    /**
     * The data needed to update a ContentQualityMetric.
     */
    data: XOR<ContentQualityMetricUpdateInput, ContentQualityMetricUncheckedUpdateInput>
    /**
     * Choose, which ContentQualityMetric to update.
     */
    where: ContentQualityMetricWhereUniqueInput
  }

  /**
   * ContentQualityMetric updateMany
   */
  export type ContentQualityMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentQualityMetrics.
     */
    data: XOR<ContentQualityMetricUpdateManyMutationInput, ContentQualityMetricUncheckedUpdateManyInput>
    /**
     * Filter which ContentQualityMetrics to update
     */
    where?: ContentQualityMetricWhereInput
    /**
     * Limit how many ContentQualityMetrics to update.
     */
    limit?: number
  }

  /**
   * ContentQualityMetric updateManyAndReturn
   */
  export type ContentQualityMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentQualityMetric
     */
    select?: ContentQualityMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentQualityMetric
     */
    omit?: ContentQualityMetricOmit<ExtArgs> | null
    /**
     * The data used to update ContentQualityMetrics.
     */
    data: XOR<ContentQualityMetricUpdateManyMutationInput, ContentQualityMetricUncheckedUpdateManyInput>
    /**
     * Filter which ContentQualityMetrics to update
     */
    where?: ContentQualityMetricWhereInput
    /**
     * Limit how many ContentQualityMetrics to update.
     */
    limit?: number
  }

  /**
   * ContentQualityMetric upsert
   */
  export type ContentQualityMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentQualityMetric
     */
    select?: ContentQualityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentQualityMetric
     */
    omit?: ContentQualityMetricOmit<ExtArgs> | null
    /**
     * The filter to search for the ContentQualityMetric to update in case it exists.
     */
    where: ContentQualityMetricWhereUniqueInput
    /**
     * In case the ContentQualityMetric found by the `where` argument doesn't exist, create a new ContentQualityMetric with this data.
     */
    create: XOR<ContentQualityMetricCreateInput, ContentQualityMetricUncheckedCreateInput>
    /**
     * In case the ContentQualityMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentQualityMetricUpdateInput, ContentQualityMetricUncheckedUpdateInput>
  }

  /**
   * ContentQualityMetric delete
   */
  export type ContentQualityMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentQualityMetric
     */
    select?: ContentQualityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentQualityMetric
     */
    omit?: ContentQualityMetricOmit<ExtArgs> | null
    /**
     * Filter which ContentQualityMetric to delete.
     */
    where: ContentQualityMetricWhereUniqueInput
  }

  /**
   * ContentQualityMetric deleteMany
   */
  export type ContentQualityMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentQualityMetrics to delete
     */
    where?: ContentQualityMetricWhereInput
    /**
     * Limit how many ContentQualityMetrics to delete.
     */
    limit?: number
  }

  /**
   * ContentQualityMetric without action
   */
  export type ContentQualityMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentQualityMetric
     */
    select?: ContentQualityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentQualityMetric
     */
    omit?: ContentQualityMetricOmit<ExtArgs> | null
  }


  /**
   * Model UserFeedback
   */

  export type AggregateUserFeedback = {
    _count: UserFeedbackCountAggregateOutputType | null
    _min: UserFeedbackMinAggregateOutputType | null
    _max: UserFeedbackMaxAggregateOutputType | null
  }

  export type UserFeedbackMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    feedbackType: $Enums.FeedbackType | null
    content: string | null
    userAgent: string | null
    ipAddress: string | null
    isResolved: boolean | null
    resolvedAt: Date | null
    createdAt: Date | null
  }

  export type UserFeedbackMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    feedbackType: $Enums.FeedbackType | null
    content: string | null
    userAgent: string | null
    ipAddress: string | null
    isResolved: boolean | null
    resolvedAt: Date | null
    createdAt: Date | null
  }

  export type UserFeedbackCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    feedbackType: number
    content: number
    userAgent: number
    ipAddress: number
    isResolved: number
    resolvedAt: number
    createdAt: number
    _all: number
  }


  export type UserFeedbackMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    feedbackType?: true
    content?: true
    userAgent?: true
    ipAddress?: true
    isResolved?: true
    resolvedAt?: true
    createdAt?: true
  }

  export type UserFeedbackMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    feedbackType?: true
    content?: true
    userAgent?: true
    ipAddress?: true
    isResolved?: true
    resolvedAt?: true
    createdAt?: true
  }

  export type UserFeedbackCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    feedbackType?: true
    content?: true
    userAgent?: true
    ipAddress?: true
    isResolved?: true
    resolvedAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeedback to aggregate.
     */
    where?: UserFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeedbacks to fetch.
     */
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFeedbacks
    **/
    _count?: true | UserFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFeedbackMaxAggregateInputType
  }

  export type GetUserFeedbackAggregateType<T extends UserFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFeedback[P]>
      : GetScalarType<T[P], AggregateUserFeedback[P]>
  }




  export type UserFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeedbackWhereInput
    orderBy?: UserFeedbackOrderByWithAggregationInput | UserFeedbackOrderByWithAggregationInput[]
    by: UserFeedbackScalarFieldEnum[] | UserFeedbackScalarFieldEnum
    having?: UserFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFeedbackCountAggregateInputType | true
    _min?: UserFeedbackMinAggregateInputType
    _max?: UserFeedbackMaxAggregateInputType
  }

  export type UserFeedbackGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    feedbackType: $Enums.FeedbackType
    content: string
    userAgent: string | null
    ipAddress: string | null
    isResolved: boolean
    resolvedAt: Date | null
    createdAt: Date
    _count: UserFeedbackCountAggregateOutputType | null
    _min: UserFeedbackMinAggregateOutputType | null
    _max: UserFeedbackMaxAggregateOutputType | null
  }

  type GetUserFeedbackGroupByPayload<T extends UserFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], UserFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type UserFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    feedbackType?: boolean
    content?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userFeedback"]>

  export type UserFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    feedbackType?: boolean
    content?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userFeedback"]>

  export type UserFeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    feedbackType?: boolean
    content?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userFeedback"]>

  export type UserFeedbackSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    feedbackType?: boolean
    content?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
  }

  export type UserFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "feedbackType" | "content" | "userAgent" | "ipAddress" | "isResolved" | "resolvedAt" | "createdAt", ExtArgs["result"]["userFeedback"]>

  export type $UserFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFeedback"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      feedbackType: $Enums.FeedbackType
      content: string
      userAgent: string | null
      ipAddress: string | null
      isResolved: boolean
      resolvedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["userFeedback"]>
    composites: {}
  }

  type UserFeedbackGetPayload<S extends boolean | null | undefined | UserFeedbackDefaultArgs> = $Result.GetResult<Prisma.$UserFeedbackPayload, S>

  type UserFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFeedbackCountAggregateInputType | true
    }

  export interface UserFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFeedback'], meta: { name: 'UserFeedback' } }
    /**
     * Find zero or one UserFeedback that matches the filter.
     * @param {UserFeedbackFindUniqueArgs} args - Arguments to find a UserFeedback
     * @example
     * // Get one UserFeedback
     * const userFeedback = await prisma.userFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFeedbackFindUniqueArgs>(args: SelectSubset<T, UserFeedbackFindUniqueArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFeedbackFindUniqueOrThrowArgs} args - Arguments to find a UserFeedback
     * @example
     * // Get one UserFeedback
     * const userFeedback = await prisma.userFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackFindFirstArgs} args - Arguments to find a UserFeedback
     * @example
     * // Get one UserFeedback
     * const userFeedback = await prisma.userFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFeedbackFindFirstArgs>(args?: SelectSubset<T, UserFeedbackFindFirstArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackFindFirstOrThrowArgs} args - Arguments to find a UserFeedback
     * @example
     * // Get one UserFeedback
     * const userFeedback = await prisma.userFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFeedbacks
     * const userFeedbacks = await prisma.userFeedback.findMany()
     * 
     * // Get first 10 UserFeedbacks
     * const userFeedbacks = await prisma.userFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFeedbackWithIdOnly = await prisma.userFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFeedbackFindManyArgs>(args?: SelectSubset<T, UserFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFeedback.
     * @param {UserFeedbackCreateArgs} args - Arguments to create a UserFeedback.
     * @example
     * // Create one UserFeedback
     * const UserFeedback = await prisma.userFeedback.create({
     *   data: {
     *     // ... data to create a UserFeedback
     *   }
     * })
     * 
     */
    create<T extends UserFeedbackCreateArgs>(args: SelectSubset<T, UserFeedbackCreateArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFeedbacks.
     * @param {UserFeedbackCreateManyArgs} args - Arguments to create many UserFeedbacks.
     * @example
     * // Create many UserFeedbacks
     * const userFeedback = await prisma.userFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFeedbackCreateManyArgs>(args?: SelectSubset<T, UserFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFeedbacks and returns the data saved in the database.
     * @param {UserFeedbackCreateManyAndReturnArgs} args - Arguments to create many UserFeedbacks.
     * @example
     * // Create many UserFeedbacks
     * const userFeedback = await prisma.userFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFeedbacks and only return the `id`
     * const userFeedbackWithIdOnly = await prisma.userFeedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFeedback.
     * @param {UserFeedbackDeleteArgs} args - Arguments to delete one UserFeedback.
     * @example
     * // Delete one UserFeedback
     * const UserFeedback = await prisma.userFeedback.delete({
     *   where: {
     *     // ... filter to delete one UserFeedback
     *   }
     * })
     * 
     */
    delete<T extends UserFeedbackDeleteArgs>(args: SelectSubset<T, UserFeedbackDeleteArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFeedback.
     * @param {UserFeedbackUpdateArgs} args - Arguments to update one UserFeedback.
     * @example
     * // Update one UserFeedback
     * const userFeedback = await prisma.userFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFeedbackUpdateArgs>(args: SelectSubset<T, UserFeedbackUpdateArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFeedbacks.
     * @param {UserFeedbackDeleteManyArgs} args - Arguments to filter UserFeedbacks to delete.
     * @example
     * // Delete a few UserFeedbacks
     * const { count } = await prisma.userFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFeedbackDeleteManyArgs>(args?: SelectSubset<T, UserFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFeedbacks
     * const userFeedback = await prisma.userFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFeedbackUpdateManyArgs>(args: SelectSubset<T, UserFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFeedbacks and returns the data updated in the database.
     * @param {UserFeedbackUpdateManyAndReturnArgs} args - Arguments to update many UserFeedbacks.
     * @example
     * // Update many UserFeedbacks
     * const userFeedback = await prisma.userFeedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFeedbacks and only return the `id`
     * const userFeedbackWithIdOnly = await prisma.userFeedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFeedback.
     * @param {UserFeedbackUpsertArgs} args - Arguments to update or create a UserFeedback.
     * @example
     * // Update or create a UserFeedback
     * const userFeedback = await prisma.userFeedback.upsert({
     *   create: {
     *     // ... data to create a UserFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFeedback we want to update
     *   }
     * })
     */
    upsert<T extends UserFeedbackUpsertArgs>(args: SelectSubset<T, UserFeedbackUpsertArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackCountArgs} args - Arguments to filter UserFeedbacks to count.
     * @example
     * // Count the number of UserFeedbacks
     * const count = await prisma.userFeedback.count({
     *   where: {
     *     // ... the filter for the UserFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends UserFeedbackCountArgs>(
      args?: Subset<T, UserFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFeedbackAggregateArgs>(args: Subset<T, UserFeedbackAggregateArgs>): Prisma.PrismaPromise<GetUserFeedbackAggregateType<T>>

    /**
     * Group by UserFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: UserFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFeedback model
   */
  readonly fields: UserFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFeedback model
   */
  interface UserFeedbackFieldRefs {
    readonly id: FieldRef<"UserFeedback", 'String'>
    readonly entityType: FieldRef<"UserFeedback", 'String'>
    readonly entityId: FieldRef<"UserFeedback", 'String'>
    readonly feedbackType: FieldRef<"UserFeedback", 'FeedbackType'>
    readonly content: FieldRef<"UserFeedback", 'String'>
    readonly userAgent: FieldRef<"UserFeedback", 'String'>
    readonly ipAddress: FieldRef<"UserFeedback", 'String'>
    readonly isResolved: FieldRef<"UserFeedback", 'Boolean'>
    readonly resolvedAt: FieldRef<"UserFeedback", 'DateTime'>
    readonly createdAt: FieldRef<"UserFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFeedback findUnique
   */
  export type UserFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeedback
     */
    omit?: UserFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which UserFeedback to fetch.
     */
    where: UserFeedbackWhereUniqueInput
  }

  /**
   * UserFeedback findUniqueOrThrow
   */
  export type UserFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeedback
     */
    omit?: UserFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which UserFeedback to fetch.
     */
    where: UserFeedbackWhereUniqueInput
  }

  /**
   * UserFeedback findFirst
   */
  export type UserFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeedback
     */
    omit?: UserFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which UserFeedback to fetch.
     */
    where?: UserFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeedbacks to fetch.
     */
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeedbacks.
     */
    cursor?: UserFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeedbacks.
     */
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * UserFeedback findFirstOrThrow
   */
  export type UserFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeedback
     */
    omit?: UserFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which UserFeedback to fetch.
     */
    where?: UserFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeedbacks to fetch.
     */
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeedbacks.
     */
    cursor?: UserFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeedbacks.
     */
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * UserFeedback findMany
   */
  export type UserFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeedback
     */
    omit?: UserFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which UserFeedbacks to fetch.
     */
    where?: UserFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeedbacks to fetch.
     */
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFeedbacks.
     */
    cursor?: UserFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeedbacks.
     */
    skip?: number
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * UserFeedback create
   */
  export type UserFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeedback
     */
    omit?: UserFeedbackOmit<ExtArgs> | null
    /**
     * The data needed to create a UserFeedback.
     */
    data: XOR<UserFeedbackCreateInput, UserFeedbackUncheckedCreateInput>
  }

  /**
   * UserFeedback createMany
   */
  export type UserFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFeedbacks.
     */
    data: UserFeedbackCreateManyInput | UserFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFeedback createManyAndReturn
   */
  export type UserFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeedback
     */
    omit?: UserFeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many UserFeedbacks.
     */
    data: UserFeedbackCreateManyInput | UserFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFeedback update
   */
  export type UserFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeedback
     */
    omit?: UserFeedbackOmit<ExtArgs> | null
    /**
     * The data needed to update a UserFeedback.
     */
    data: XOR<UserFeedbackUpdateInput, UserFeedbackUncheckedUpdateInput>
    /**
     * Choose, which UserFeedback to update.
     */
    where: UserFeedbackWhereUniqueInput
  }

  /**
   * UserFeedback updateMany
   */
  export type UserFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFeedbacks.
     */
    data: XOR<UserFeedbackUpdateManyMutationInput, UserFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which UserFeedbacks to update
     */
    where?: UserFeedbackWhereInput
    /**
     * Limit how many UserFeedbacks to update.
     */
    limit?: number
  }

  /**
   * UserFeedback updateManyAndReturn
   */
  export type UserFeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeedback
     */
    omit?: UserFeedbackOmit<ExtArgs> | null
    /**
     * The data used to update UserFeedbacks.
     */
    data: XOR<UserFeedbackUpdateManyMutationInput, UserFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which UserFeedbacks to update
     */
    where?: UserFeedbackWhereInput
    /**
     * Limit how many UserFeedbacks to update.
     */
    limit?: number
  }

  /**
   * UserFeedback upsert
   */
  export type UserFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeedback
     */
    omit?: UserFeedbackOmit<ExtArgs> | null
    /**
     * The filter to search for the UserFeedback to update in case it exists.
     */
    where: UserFeedbackWhereUniqueInput
    /**
     * In case the UserFeedback found by the `where` argument doesn't exist, create a new UserFeedback with this data.
     */
    create: XOR<UserFeedbackCreateInput, UserFeedbackUncheckedCreateInput>
    /**
     * In case the UserFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFeedbackUpdateInput, UserFeedbackUncheckedUpdateInput>
  }

  /**
   * UserFeedback delete
   */
  export type UserFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeedback
     */
    omit?: UserFeedbackOmit<ExtArgs> | null
    /**
     * Filter which UserFeedback to delete.
     */
    where: UserFeedbackWhereUniqueInput
  }

  /**
   * UserFeedback deleteMany
   */
  export type UserFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeedbacks to delete
     */
    where?: UserFeedbackWhereInput
    /**
     * Limit how many UserFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * UserFeedback without action
   */
  export type UserFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeedback
     */
    omit?: UserFeedbackOmit<ExtArgs> | null
  }


  /**
   * Model ContentSyncLog
   */

  export type AggregateContentSyncLog = {
    _count: ContentSyncLogCountAggregateOutputType | null
    _avg: ContentSyncLogAvgAggregateOutputType | null
    _sum: ContentSyncLogSumAggregateOutputType | null
    _min: ContentSyncLogMinAggregateOutputType | null
    _max: ContentSyncLogMaxAggregateOutputType | null
  }

  export type ContentSyncLogAvgAggregateOutputType = {
    recordsProcessed: number | null
    recordsUpdated: number | null
    recordsCreated: number | null
    recordsFailed: number | null
  }

  export type ContentSyncLogSumAggregateOutputType = {
    recordsProcessed: number | null
    recordsUpdated: number | null
    recordsCreated: number | null
    recordsFailed: number | null
  }

  export type ContentSyncLogMinAggregateOutputType = {
    id: string | null
    source: string | null
    syncType: $Enums.SyncType | null
    status: $Enums.SyncStatus | null
    recordsProcessed: number | null
    recordsUpdated: number | null
    recordsCreated: number | null
    recordsFailed: number | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type ContentSyncLogMaxAggregateOutputType = {
    id: string | null
    source: string | null
    syncType: $Enums.SyncType | null
    status: $Enums.SyncStatus | null
    recordsProcessed: number | null
    recordsUpdated: number | null
    recordsCreated: number | null
    recordsFailed: number | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type ContentSyncLogCountAggregateOutputType = {
    id: number
    source: number
    syncType: number
    status: number
    recordsProcessed: number
    recordsUpdated: number
    recordsCreated: number
    recordsFailed: number
    errorDetails: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type ContentSyncLogAvgAggregateInputType = {
    recordsProcessed?: true
    recordsUpdated?: true
    recordsCreated?: true
    recordsFailed?: true
  }

  export type ContentSyncLogSumAggregateInputType = {
    recordsProcessed?: true
    recordsUpdated?: true
    recordsCreated?: true
    recordsFailed?: true
  }

  export type ContentSyncLogMinAggregateInputType = {
    id?: true
    source?: true
    syncType?: true
    status?: true
    recordsProcessed?: true
    recordsUpdated?: true
    recordsCreated?: true
    recordsFailed?: true
    startedAt?: true
    completedAt?: true
  }

  export type ContentSyncLogMaxAggregateInputType = {
    id?: true
    source?: true
    syncType?: true
    status?: true
    recordsProcessed?: true
    recordsUpdated?: true
    recordsCreated?: true
    recordsFailed?: true
    startedAt?: true
    completedAt?: true
  }

  export type ContentSyncLogCountAggregateInputType = {
    id?: true
    source?: true
    syncType?: true
    status?: true
    recordsProcessed?: true
    recordsUpdated?: true
    recordsCreated?: true
    recordsFailed?: true
    errorDetails?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type ContentSyncLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentSyncLog to aggregate.
     */
    where?: ContentSyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSyncLogs to fetch.
     */
    orderBy?: ContentSyncLogOrderByWithRelationInput | ContentSyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentSyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentSyncLogs
    **/
    _count?: true | ContentSyncLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentSyncLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentSyncLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentSyncLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentSyncLogMaxAggregateInputType
  }

  export type GetContentSyncLogAggregateType<T extends ContentSyncLogAggregateArgs> = {
        [P in keyof T & keyof AggregateContentSyncLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentSyncLog[P]>
      : GetScalarType<T[P], AggregateContentSyncLog[P]>
  }




  export type ContentSyncLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentSyncLogWhereInput
    orderBy?: ContentSyncLogOrderByWithAggregationInput | ContentSyncLogOrderByWithAggregationInput[]
    by: ContentSyncLogScalarFieldEnum[] | ContentSyncLogScalarFieldEnum
    having?: ContentSyncLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentSyncLogCountAggregateInputType | true
    _avg?: ContentSyncLogAvgAggregateInputType
    _sum?: ContentSyncLogSumAggregateInputType
    _min?: ContentSyncLogMinAggregateInputType
    _max?: ContentSyncLogMaxAggregateInputType
  }

  export type ContentSyncLogGroupByOutputType = {
    id: string
    source: string
    syncType: $Enums.SyncType
    status: $Enums.SyncStatus
    recordsProcessed: number
    recordsUpdated: number
    recordsCreated: number
    recordsFailed: number
    errorDetails: JsonValue | null
    startedAt: Date
    completedAt: Date | null
    _count: ContentSyncLogCountAggregateOutputType | null
    _avg: ContentSyncLogAvgAggregateOutputType | null
    _sum: ContentSyncLogSumAggregateOutputType | null
    _min: ContentSyncLogMinAggregateOutputType | null
    _max: ContentSyncLogMaxAggregateOutputType | null
  }

  type GetContentSyncLogGroupByPayload<T extends ContentSyncLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentSyncLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentSyncLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentSyncLogGroupByOutputType[P]>
            : GetScalarType<T[P], ContentSyncLogGroupByOutputType[P]>
        }
      >
    >


  export type ContentSyncLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    syncType?: boolean
    status?: boolean
    recordsProcessed?: boolean
    recordsUpdated?: boolean
    recordsCreated?: boolean
    recordsFailed?: boolean
    errorDetails?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["contentSyncLog"]>

  export type ContentSyncLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    syncType?: boolean
    status?: boolean
    recordsProcessed?: boolean
    recordsUpdated?: boolean
    recordsCreated?: boolean
    recordsFailed?: boolean
    errorDetails?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["contentSyncLog"]>

  export type ContentSyncLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    syncType?: boolean
    status?: boolean
    recordsProcessed?: boolean
    recordsUpdated?: boolean
    recordsCreated?: boolean
    recordsFailed?: boolean
    errorDetails?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["contentSyncLog"]>

  export type ContentSyncLogSelectScalar = {
    id?: boolean
    source?: boolean
    syncType?: boolean
    status?: boolean
    recordsProcessed?: boolean
    recordsUpdated?: boolean
    recordsCreated?: boolean
    recordsFailed?: boolean
    errorDetails?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type ContentSyncLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "source" | "syncType" | "status" | "recordsProcessed" | "recordsUpdated" | "recordsCreated" | "recordsFailed" | "errorDetails" | "startedAt" | "completedAt", ExtArgs["result"]["contentSyncLog"]>

  export type $ContentSyncLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentSyncLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      source: string
      syncType: $Enums.SyncType
      status: $Enums.SyncStatus
      recordsProcessed: number
      recordsUpdated: number
      recordsCreated: number
      recordsFailed: number
      errorDetails: Prisma.JsonValue | null
      startedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["contentSyncLog"]>
    composites: {}
  }

  type ContentSyncLogGetPayload<S extends boolean | null | undefined | ContentSyncLogDefaultArgs> = $Result.GetResult<Prisma.$ContentSyncLogPayload, S>

  type ContentSyncLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentSyncLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentSyncLogCountAggregateInputType | true
    }

  export interface ContentSyncLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentSyncLog'], meta: { name: 'ContentSyncLog' } }
    /**
     * Find zero or one ContentSyncLog that matches the filter.
     * @param {ContentSyncLogFindUniqueArgs} args - Arguments to find a ContentSyncLog
     * @example
     * // Get one ContentSyncLog
     * const contentSyncLog = await prisma.contentSyncLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentSyncLogFindUniqueArgs>(args: SelectSubset<T, ContentSyncLogFindUniqueArgs<ExtArgs>>): Prisma__ContentSyncLogClient<$Result.GetResult<Prisma.$ContentSyncLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentSyncLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentSyncLogFindUniqueOrThrowArgs} args - Arguments to find a ContentSyncLog
     * @example
     * // Get one ContentSyncLog
     * const contentSyncLog = await prisma.contentSyncLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentSyncLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentSyncLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentSyncLogClient<$Result.GetResult<Prisma.$ContentSyncLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentSyncLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSyncLogFindFirstArgs} args - Arguments to find a ContentSyncLog
     * @example
     * // Get one ContentSyncLog
     * const contentSyncLog = await prisma.contentSyncLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentSyncLogFindFirstArgs>(args?: SelectSubset<T, ContentSyncLogFindFirstArgs<ExtArgs>>): Prisma__ContentSyncLogClient<$Result.GetResult<Prisma.$ContentSyncLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentSyncLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSyncLogFindFirstOrThrowArgs} args - Arguments to find a ContentSyncLog
     * @example
     * // Get one ContentSyncLog
     * const contentSyncLog = await prisma.contentSyncLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentSyncLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentSyncLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentSyncLogClient<$Result.GetResult<Prisma.$ContentSyncLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentSyncLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSyncLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentSyncLogs
     * const contentSyncLogs = await prisma.contentSyncLog.findMany()
     * 
     * // Get first 10 ContentSyncLogs
     * const contentSyncLogs = await prisma.contentSyncLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentSyncLogWithIdOnly = await prisma.contentSyncLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentSyncLogFindManyArgs>(args?: SelectSubset<T, ContentSyncLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSyncLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentSyncLog.
     * @param {ContentSyncLogCreateArgs} args - Arguments to create a ContentSyncLog.
     * @example
     * // Create one ContentSyncLog
     * const ContentSyncLog = await prisma.contentSyncLog.create({
     *   data: {
     *     // ... data to create a ContentSyncLog
     *   }
     * })
     * 
     */
    create<T extends ContentSyncLogCreateArgs>(args: SelectSubset<T, ContentSyncLogCreateArgs<ExtArgs>>): Prisma__ContentSyncLogClient<$Result.GetResult<Prisma.$ContentSyncLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentSyncLogs.
     * @param {ContentSyncLogCreateManyArgs} args - Arguments to create many ContentSyncLogs.
     * @example
     * // Create many ContentSyncLogs
     * const contentSyncLog = await prisma.contentSyncLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentSyncLogCreateManyArgs>(args?: SelectSubset<T, ContentSyncLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentSyncLogs and returns the data saved in the database.
     * @param {ContentSyncLogCreateManyAndReturnArgs} args - Arguments to create many ContentSyncLogs.
     * @example
     * // Create many ContentSyncLogs
     * const contentSyncLog = await prisma.contentSyncLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentSyncLogs and only return the `id`
     * const contentSyncLogWithIdOnly = await prisma.contentSyncLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentSyncLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentSyncLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSyncLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentSyncLog.
     * @param {ContentSyncLogDeleteArgs} args - Arguments to delete one ContentSyncLog.
     * @example
     * // Delete one ContentSyncLog
     * const ContentSyncLog = await prisma.contentSyncLog.delete({
     *   where: {
     *     // ... filter to delete one ContentSyncLog
     *   }
     * })
     * 
     */
    delete<T extends ContentSyncLogDeleteArgs>(args: SelectSubset<T, ContentSyncLogDeleteArgs<ExtArgs>>): Prisma__ContentSyncLogClient<$Result.GetResult<Prisma.$ContentSyncLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentSyncLog.
     * @param {ContentSyncLogUpdateArgs} args - Arguments to update one ContentSyncLog.
     * @example
     * // Update one ContentSyncLog
     * const contentSyncLog = await prisma.contentSyncLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentSyncLogUpdateArgs>(args: SelectSubset<T, ContentSyncLogUpdateArgs<ExtArgs>>): Prisma__ContentSyncLogClient<$Result.GetResult<Prisma.$ContentSyncLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentSyncLogs.
     * @param {ContentSyncLogDeleteManyArgs} args - Arguments to filter ContentSyncLogs to delete.
     * @example
     * // Delete a few ContentSyncLogs
     * const { count } = await prisma.contentSyncLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentSyncLogDeleteManyArgs>(args?: SelectSubset<T, ContentSyncLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentSyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSyncLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentSyncLogs
     * const contentSyncLog = await prisma.contentSyncLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentSyncLogUpdateManyArgs>(args: SelectSubset<T, ContentSyncLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentSyncLogs and returns the data updated in the database.
     * @param {ContentSyncLogUpdateManyAndReturnArgs} args - Arguments to update many ContentSyncLogs.
     * @example
     * // Update many ContentSyncLogs
     * const contentSyncLog = await prisma.contentSyncLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentSyncLogs and only return the `id`
     * const contentSyncLogWithIdOnly = await prisma.contentSyncLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentSyncLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentSyncLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSyncLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentSyncLog.
     * @param {ContentSyncLogUpsertArgs} args - Arguments to update or create a ContentSyncLog.
     * @example
     * // Update or create a ContentSyncLog
     * const contentSyncLog = await prisma.contentSyncLog.upsert({
     *   create: {
     *     // ... data to create a ContentSyncLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentSyncLog we want to update
     *   }
     * })
     */
    upsert<T extends ContentSyncLogUpsertArgs>(args: SelectSubset<T, ContentSyncLogUpsertArgs<ExtArgs>>): Prisma__ContentSyncLogClient<$Result.GetResult<Prisma.$ContentSyncLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentSyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSyncLogCountArgs} args - Arguments to filter ContentSyncLogs to count.
     * @example
     * // Count the number of ContentSyncLogs
     * const count = await prisma.contentSyncLog.count({
     *   where: {
     *     // ... the filter for the ContentSyncLogs we want to count
     *   }
     * })
    **/
    count<T extends ContentSyncLogCountArgs>(
      args?: Subset<T, ContentSyncLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentSyncLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentSyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSyncLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentSyncLogAggregateArgs>(args: Subset<T, ContentSyncLogAggregateArgs>): Prisma.PrismaPromise<GetContentSyncLogAggregateType<T>>

    /**
     * Group by ContentSyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSyncLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentSyncLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentSyncLogGroupByArgs['orderBy'] }
        : { orderBy?: ContentSyncLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentSyncLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentSyncLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentSyncLog model
   */
  readonly fields: ContentSyncLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentSyncLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentSyncLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentSyncLog model
   */
  interface ContentSyncLogFieldRefs {
    readonly id: FieldRef<"ContentSyncLog", 'String'>
    readonly source: FieldRef<"ContentSyncLog", 'String'>
    readonly syncType: FieldRef<"ContentSyncLog", 'SyncType'>
    readonly status: FieldRef<"ContentSyncLog", 'SyncStatus'>
    readonly recordsProcessed: FieldRef<"ContentSyncLog", 'Int'>
    readonly recordsUpdated: FieldRef<"ContentSyncLog", 'Int'>
    readonly recordsCreated: FieldRef<"ContentSyncLog", 'Int'>
    readonly recordsFailed: FieldRef<"ContentSyncLog", 'Int'>
    readonly errorDetails: FieldRef<"ContentSyncLog", 'Json'>
    readonly startedAt: FieldRef<"ContentSyncLog", 'DateTime'>
    readonly completedAt: FieldRef<"ContentSyncLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentSyncLog findUnique
   */
  export type ContentSyncLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSyncLog
     */
    select?: ContentSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSyncLog
     */
    omit?: ContentSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which ContentSyncLog to fetch.
     */
    where: ContentSyncLogWhereUniqueInput
  }

  /**
   * ContentSyncLog findUniqueOrThrow
   */
  export type ContentSyncLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSyncLog
     */
    select?: ContentSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSyncLog
     */
    omit?: ContentSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which ContentSyncLog to fetch.
     */
    where: ContentSyncLogWhereUniqueInput
  }

  /**
   * ContentSyncLog findFirst
   */
  export type ContentSyncLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSyncLog
     */
    select?: ContentSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSyncLog
     */
    omit?: ContentSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which ContentSyncLog to fetch.
     */
    where?: ContentSyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSyncLogs to fetch.
     */
    orderBy?: ContentSyncLogOrderByWithRelationInput | ContentSyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentSyncLogs.
     */
    cursor?: ContentSyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentSyncLogs.
     */
    distinct?: ContentSyncLogScalarFieldEnum | ContentSyncLogScalarFieldEnum[]
  }

  /**
   * ContentSyncLog findFirstOrThrow
   */
  export type ContentSyncLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSyncLog
     */
    select?: ContentSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSyncLog
     */
    omit?: ContentSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which ContentSyncLog to fetch.
     */
    where?: ContentSyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSyncLogs to fetch.
     */
    orderBy?: ContentSyncLogOrderByWithRelationInput | ContentSyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentSyncLogs.
     */
    cursor?: ContentSyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentSyncLogs.
     */
    distinct?: ContentSyncLogScalarFieldEnum | ContentSyncLogScalarFieldEnum[]
  }

  /**
   * ContentSyncLog findMany
   */
  export type ContentSyncLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSyncLog
     */
    select?: ContentSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSyncLog
     */
    omit?: ContentSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which ContentSyncLogs to fetch.
     */
    where?: ContentSyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSyncLogs to fetch.
     */
    orderBy?: ContentSyncLogOrderByWithRelationInput | ContentSyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentSyncLogs.
     */
    cursor?: ContentSyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSyncLogs.
     */
    skip?: number
    distinct?: ContentSyncLogScalarFieldEnum | ContentSyncLogScalarFieldEnum[]
  }

  /**
   * ContentSyncLog create
   */
  export type ContentSyncLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSyncLog
     */
    select?: ContentSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSyncLog
     */
    omit?: ContentSyncLogOmit<ExtArgs> | null
    /**
     * The data needed to create a ContentSyncLog.
     */
    data: XOR<ContentSyncLogCreateInput, ContentSyncLogUncheckedCreateInput>
  }

  /**
   * ContentSyncLog createMany
   */
  export type ContentSyncLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentSyncLogs.
     */
    data: ContentSyncLogCreateManyInput | ContentSyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentSyncLog createManyAndReturn
   */
  export type ContentSyncLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSyncLog
     */
    select?: ContentSyncLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSyncLog
     */
    omit?: ContentSyncLogOmit<ExtArgs> | null
    /**
     * The data used to create many ContentSyncLogs.
     */
    data: ContentSyncLogCreateManyInput | ContentSyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentSyncLog update
   */
  export type ContentSyncLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSyncLog
     */
    select?: ContentSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSyncLog
     */
    omit?: ContentSyncLogOmit<ExtArgs> | null
    /**
     * The data needed to update a ContentSyncLog.
     */
    data: XOR<ContentSyncLogUpdateInput, ContentSyncLogUncheckedUpdateInput>
    /**
     * Choose, which ContentSyncLog to update.
     */
    where: ContentSyncLogWhereUniqueInput
  }

  /**
   * ContentSyncLog updateMany
   */
  export type ContentSyncLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentSyncLogs.
     */
    data: XOR<ContentSyncLogUpdateManyMutationInput, ContentSyncLogUncheckedUpdateManyInput>
    /**
     * Filter which ContentSyncLogs to update
     */
    where?: ContentSyncLogWhereInput
    /**
     * Limit how many ContentSyncLogs to update.
     */
    limit?: number
  }

  /**
   * ContentSyncLog updateManyAndReturn
   */
  export type ContentSyncLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSyncLog
     */
    select?: ContentSyncLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSyncLog
     */
    omit?: ContentSyncLogOmit<ExtArgs> | null
    /**
     * The data used to update ContentSyncLogs.
     */
    data: XOR<ContentSyncLogUpdateManyMutationInput, ContentSyncLogUncheckedUpdateManyInput>
    /**
     * Filter which ContentSyncLogs to update
     */
    where?: ContentSyncLogWhereInput
    /**
     * Limit how many ContentSyncLogs to update.
     */
    limit?: number
  }

  /**
   * ContentSyncLog upsert
   */
  export type ContentSyncLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSyncLog
     */
    select?: ContentSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSyncLog
     */
    omit?: ContentSyncLogOmit<ExtArgs> | null
    /**
     * The filter to search for the ContentSyncLog to update in case it exists.
     */
    where: ContentSyncLogWhereUniqueInput
    /**
     * In case the ContentSyncLog found by the `where` argument doesn't exist, create a new ContentSyncLog with this data.
     */
    create: XOR<ContentSyncLogCreateInput, ContentSyncLogUncheckedCreateInput>
    /**
     * In case the ContentSyncLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentSyncLogUpdateInput, ContentSyncLogUncheckedUpdateInput>
  }

  /**
   * ContentSyncLog delete
   */
  export type ContentSyncLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSyncLog
     */
    select?: ContentSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSyncLog
     */
    omit?: ContentSyncLogOmit<ExtArgs> | null
    /**
     * Filter which ContentSyncLog to delete.
     */
    where: ContentSyncLogWhereUniqueInput
  }

  /**
   * ContentSyncLog deleteMany
   */
  export type ContentSyncLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentSyncLogs to delete
     */
    where?: ContentSyncLogWhereInput
    /**
     * Limit how many ContentSyncLogs to delete.
     */
    limit?: number
  }

  /**
   * ContentSyncLog without action
   */
  export type ContentSyncLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSyncLog
     */
    select?: ContentSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSyncLog
     */
    omit?: ContentSyncLogOmit<ExtArgs> | null
  }


  /**
   * Model Character
   */

  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameJa: string | null
    nameZh: string | null
    description: string | null
    imageUrl: string | null
    isMainCharacter: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameJa: string | null
    nameZh: string | null
    description: string | null
    imageUrl: string | null
    isMainCharacter: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterCountAggregateOutputType = {
    id: number
    name: number
    nameJa: number
    nameZh: number
    description: number
    imageUrl: number
    isMainCharacter: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CharacterMinAggregateInputType = {
    id?: true
    name?: true
    nameJa?: true
    nameZh?: true
    description?: true
    imageUrl?: true
    isMainCharacter?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterMaxAggregateInputType = {
    id?: true
    name?: true
    nameJa?: true
    nameZh?: true
    description?: true
    imageUrl?: true
    isMainCharacter?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterCountAggregateInputType = {
    id?: true
    name?: true
    nameJa?: true
    nameZh?: true
    description?: true
    imageUrl?: true
    isMainCharacter?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character to aggregate.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithAggregationInput | CharacterOrderByWithAggregationInput[]
    by: CharacterScalarFieldEnum[] | CharacterScalarFieldEnum
    having?: CharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }

  export type CharacterGroupByOutputType = {
    id: string
    name: string
    nameJa: string | null
    nameZh: string | null
    description: string | null
    imageUrl: string | null
    isMainCharacter: boolean
    createdAt: Date
    updatedAt: Date
    _count: CharacterCountAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameJa?: boolean
    nameZh?: boolean
    description?: boolean
    imageUrl?: boolean
    isMainCharacter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movieCharacters?: boolean | Character$movieCharactersArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameJa?: boolean
    nameZh?: boolean
    description?: boolean
    imageUrl?: boolean
    isMainCharacter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameJa?: boolean
    nameZh?: boolean
    description?: boolean
    imageUrl?: boolean
    isMainCharacter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectScalar = {
    id?: boolean
    name?: boolean
    nameJa?: boolean
    nameZh?: boolean
    description?: boolean
    imageUrl?: boolean
    isMainCharacter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CharacterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "nameJa" | "nameZh" | "description" | "imageUrl" | "isMainCharacter" | "createdAt" | "updatedAt", ExtArgs["result"]["character"]>
  export type CharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movieCharacters?: boolean | Character$movieCharactersArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharacterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CharacterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Character"
    objects: {
      movieCharacters: Prisma.$MovieCharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      nameJa: string | null
      nameZh: string | null
      description: string | null
      imageUrl: string | null
      isMainCharacter: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["character"]>
    composites: {}
  }

  type CharacterGetPayload<S extends boolean | null | undefined | CharacterDefaultArgs> = $Result.GetResult<Prisma.$CharacterPayload, S>

  type CharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterCountAggregateInputType | true
    }

  export interface CharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Character'], meta: { name: 'Character' } }
    /**
     * Find zero or one Character that matches the filter.
     * @param {CharacterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterFindUniqueArgs>(args: SelectSubset<T, CharacterFindUniqueArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterFindUniqueOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterFindFirstArgs>(args?: SelectSubset<T, CharacterFindFirstArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterWithIdOnly = await prisma.character.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterFindManyArgs>(args?: SelectSubset<T, CharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character.
     * @param {CharacterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
     */
    create<T extends CharacterCreateArgs>(args: SelectSubset<T, CharacterCreateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Characters.
     * @param {CharacterCreateManyArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterCreateManyArgs>(args?: SelectSubset<T, CharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Characters and returns the data saved in the database.
     * @param {CharacterCreateManyAndReturnArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Characters and only return the `id`
     * const characterWithIdOnly = await prisma.character.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character.
     * @param {CharacterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
     */
    delete<T extends CharacterDeleteArgs>(args: SelectSubset<T, CharacterDeleteArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character.
     * @param {CharacterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterUpdateArgs>(args: SelectSubset<T, CharacterUpdateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Characters.
     * @param {CharacterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterDeleteManyArgs>(args?: SelectSubset<T, CharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterUpdateManyArgs>(args: SelectSubset<T, CharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters and returns the data updated in the database.
     * @param {CharacterUpdateManyAndReturnArgs} args - Arguments to update many Characters.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Characters and only return the `id`
     * const characterWithIdOnly = await prisma.character.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character.
     * @param {CharacterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
     */
    upsert<T extends CharacterUpsertArgs>(args: SelectSubset<T, CharacterUpsertArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharacterCountArgs>(
      args?: Subset<T, CharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): Prisma.PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Character model
   */
  readonly fields: CharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movieCharacters<T extends Character$movieCharactersArgs<ExtArgs> = {}>(args?: Subset<T, Character$movieCharactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Character model
   */
  interface CharacterFieldRefs {
    readonly id: FieldRef<"Character", 'String'>
    readonly name: FieldRef<"Character", 'String'>
    readonly nameJa: FieldRef<"Character", 'String'>
    readonly nameZh: FieldRef<"Character", 'String'>
    readonly description: FieldRef<"Character", 'String'>
    readonly imageUrl: FieldRef<"Character", 'String'>
    readonly isMainCharacter: FieldRef<"Character", 'Boolean'>
    readonly createdAt: FieldRef<"Character", 'DateTime'>
    readonly updatedAt: FieldRef<"Character", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Character findUnique
   */
  export type CharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findUniqueOrThrow
   */
  export type CharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findFirst
   */
  export type CharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findFirstOrThrow
   */
  export type CharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findMany
   */
  export type CharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character create
   */
  export type CharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a Character.
     */
    data: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
  }

  /**
   * Character createMany
   */
  export type CharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Character createManyAndReturn
   */
  export type CharacterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Character update
   */
  export type CharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a Character.
     */
    data: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
    /**
     * Choose, which Character to update.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character updateMany
   */
  export type CharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
  }

  /**
   * Character updateManyAndReturn
   */
  export type CharacterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
  }

  /**
   * Character upsert
   */
  export type CharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the Character to update in case it exists.
     */
    where: CharacterWhereUniqueInput
    /**
     * In case the Character found by the `where` argument doesn't exist, create a new Character with this data.
     */
    create: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
    /**
     * In case the Character was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
  }

  /**
   * Character delete
   */
  export type CharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter which Character to delete.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character deleteMany
   */
  export type CharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to delete
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to delete.
     */
    limit?: number
  }

  /**
   * Character.movieCharacters
   */
  export type Character$movieCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterInclude<ExtArgs> | null
    where?: MovieCharacterWhereInput
    orderBy?: MovieCharacterOrderByWithRelationInput | MovieCharacterOrderByWithRelationInput[]
    cursor?: MovieCharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieCharacterScalarFieldEnum | MovieCharacterScalarFieldEnum[]
  }

  /**
   * Character without action
   */
  export type CharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
  }


  /**
   * Model MovieCharacter
   */

  export type AggregateMovieCharacter = {
    _count: MovieCharacterCountAggregateOutputType | null
    _avg: MovieCharacterAvgAggregateOutputType | null
    _sum: MovieCharacterSumAggregateOutputType | null
    _min: MovieCharacterMinAggregateOutputType | null
    _max: MovieCharacterMaxAggregateOutputType | null
  }

  export type MovieCharacterAvgAggregateOutputType = {
    importance: number | null
  }

  export type MovieCharacterSumAggregateOutputType = {
    importance: number | null
  }

  export type MovieCharacterMinAggregateOutputType = {
    id: string | null
    movieId: string | null
    characterId: string | null
    voiceActor: string | null
    voiceActorJa: string | null
    importance: number | null
    createdAt: Date | null
  }

  export type MovieCharacterMaxAggregateOutputType = {
    id: string | null
    movieId: string | null
    characterId: string | null
    voiceActor: string | null
    voiceActorJa: string | null
    importance: number | null
    createdAt: Date | null
  }

  export type MovieCharacterCountAggregateOutputType = {
    id: number
    movieId: number
    characterId: number
    voiceActor: number
    voiceActorJa: number
    importance: number
    createdAt: number
    _all: number
  }


  export type MovieCharacterAvgAggregateInputType = {
    importance?: true
  }

  export type MovieCharacterSumAggregateInputType = {
    importance?: true
  }

  export type MovieCharacterMinAggregateInputType = {
    id?: true
    movieId?: true
    characterId?: true
    voiceActor?: true
    voiceActorJa?: true
    importance?: true
    createdAt?: true
  }

  export type MovieCharacterMaxAggregateInputType = {
    id?: true
    movieId?: true
    characterId?: true
    voiceActor?: true
    voiceActorJa?: true
    importance?: true
    createdAt?: true
  }

  export type MovieCharacterCountAggregateInputType = {
    id?: true
    movieId?: true
    characterId?: true
    voiceActor?: true
    voiceActorJa?: true
    importance?: true
    createdAt?: true
    _all?: true
  }

  export type MovieCharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieCharacter to aggregate.
     */
    where?: MovieCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieCharacters to fetch.
     */
    orderBy?: MovieCharacterOrderByWithRelationInput | MovieCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieCharacters
    **/
    _count?: true | MovieCharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieCharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieCharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieCharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieCharacterMaxAggregateInputType
  }

  export type GetMovieCharacterAggregateType<T extends MovieCharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieCharacter[P]>
      : GetScalarType<T[P], AggregateMovieCharacter[P]>
  }




  export type MovieCharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieCharacterWhereInput
    orderBy?: MovieCharacterOrderByWithAggregationInput | MovieCharacterOrderByWithAggregationInput[]
    by: MovieCharacterScalarFieldEnum[] | MovieCharacterScalarFieldEnum
    having?: MovieCharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieCharacterCountAggregateInputType | true
    _avg?: MovieCharacterAvgAggregateInputType
    _sum?: MovieCharacterSumAggregateInputType
    _min?: MovieCharacterMinAggregateInputType
    _max?: MovieCharacterMaxAggregateInputType
  }

  export type MovieCharacterGroupByOutputType = {
    id: string
    movieId: string
    characterId: string
    voiceActor: string | null
    voiceActorJa: string | null
    importance: number
    createdAt: Date
    _count: MovieCharacterCountAggregateOutputType | null
    _avg: MovieCharacterAvgAggregateOutputType | null
    _sum: MovieCharacterSumAggregateOutputType | null
    _min: MovieCharacterMinAggregateOutputType | null
    _max: MovieCharacterMaxAggregateOutputType | null
  }

  type GetMovieCharacterGroupByPayload<T extends MovieCharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieCharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieCharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieCharacterGroupByOutputType[P]>
            : GetScalarType<T[P], MovieCharacterGroupByOutputType[P]>
        }
      >
    >


  export type MovieCharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    characterId?: boolean
    voiceActor?: boolean
    voiceActorJa?: boolean
    importance?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieCharacter"]>

  export type MovieCharacterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    characterId?: boolean
    voiceActor?: boolean
    voiceActorJa?: boolean
    importance?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieCharacter"]>

  export type MovieCharacterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    characterId?: boolean
    voiceActor?: boolean
    voiceActorJa?: boolean
    importance?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieCharacter"]>

  export type MovieCharacterSelectScalar = {
    id?: boolean
    movieId?: boolean
    characterId?: boolean
    voiceActor?: boolean
    voiceActorJa?: boolean
    importance?: boolean
    createdAt?: boolean
  }

  export type MovieCharacterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "movieId" | "characterId" | "voiceActor" | "voiceActorJa" | "importance" | "createdAt", ExtArgs["result"]["movieCharacter"]>
  export type MovieCharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }
  export type MovieCharacterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }
  export type MovieCharacterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }

  export type $MovieCharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieCharacter"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
      character: Prisma.$CharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      movieId: string
      characterId: string
      voiceActor: string | null
      voiceActorJa: string | null
      importance: number
      createdAt: Date
    }, ExtArgs["result"]["movieCharacter"]>
    composites: {}
  }

  type MovieCharacterGetPayload<S extends boolean | null | undefined | MovieCharacterDefaultArgs> = $Result.GetResult<Prisma.$MovieCharacterPayload, S>

  type MovieCharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MovieCharacterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MovieCharacterCountAggregateInputType | true
    }

  export interface MovieCharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieCharacter'], meta: { name: 'MovieCharacter' } }
    /**
     * Find zero or one MovieCharacter that matches the filter.
     * @param {MovieCharacterFindUniqueArgs} args - Arguments to find a MovieCharacter
     * @example
     * // Get one MovieCharacter
     * const movieCharacter = await prisma.movieCharacter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieCharacterFindUniqueArgs>(args: SelectSubset<T, MovieCharacterFindUniqueArgs<ExtArgs>>): Prisma__MovieCharacterClient<$Result.GetResult<Prisma.$MovieCharacterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MovieCharacter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MovieCharacterFindUniqueOrThrowArgs} args - Arguments to find a MovieCharacter
     * @example
     * // Get one MovieCharacter
     * const movieCharacter = await prisma.movieCharacter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieCharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieCharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieCharacterClient<$Result.GetResult<Prisma.$MovieCharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MovieCharacter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCharacterFindFirstArgs} args - Arguments to find a MovieCharacter
     * @example
     * // Get one MovieCharacter
     * const movieCharacter = await prisma.movieCharacter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieCharacterFindFirstArgs>(args?: SelectSubset<T, MovieCharacterFindFirstArgs<ExtArgs>>): Prisma__MovieCharacterClient<$Result.GetResult<Prisma.$MovieCharacterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MovieCharacter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCharacterFindFirstOrThrowArgs} args - Arguments to find a MovieCharacter
     * @example
     * // Get one MovieCharacter
     * const movieCharacter = await prisma.movieCharacter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieCharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieCharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieCharacterClient<$Result.GetResult<Prisma.$MovieCharacterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MovieCharacters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieCharacters
     * const movieCharacters = await prisma.movieCharacter.findMany()
     * 
     * // Get first 10 MovieCharacters
     * const movieCharacters = await prisma.movieCharacter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieCharacterWithIdOnly = await prisma.movieCharacter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieCharacterFindManyArgs>(args?: SelectSubset<T, MovieCharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MovieCharacter.
     * @param {MovieCharacterCreateArgs} args - Arguments to create a MovieCharacter.
     * @example
     * // Create one MovieCharacter
     * const MovieCharacter = await prisma.movieCharacter.create({
     *   data: {
     *     // ... data to create a MovieCharacter
     *   }
     * })
     * 
     */
    create<T extends MovieCharacterCreateArgs>(args: SelectSubset<T, MovieCharacterCreateArgs<ExtArgs>>): Prisma__MovieCharacterClient<$Result.GetResult<Prisma.$MovieCharacterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MovieCharacters.
     * @param {MovieCharacterCreateManyArgs} args - Arguments to create many MovieCharacters.
     * @example
     * // Create many MovieCharacters
     * const movieCharacter = await prisma.movieCharacter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieCharacterCreateManyArgs>(args?: SelectSubset<T, MovieCharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieCharacters and returns the data saved in the database.
     * @param {MovieCharacterCreateManyAndReturnArgs} args - Arguments to create many MovieCharacters.
     * @example
     * // Create many MovieCharacters
     * const movieCharacter = await prisma.movieCharacter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieCharacters and only return the `id`
     * const movieCharacterWithIdOnly = await prisma.movieCharacter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieCharacterCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieCharacterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCharacterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MovieCharacter.
     * @param {MovieCharacterDeleteArgs} args - Arguments to delete one MovieCharacter.
     * @example
     * // Delete one MovieCharacter
     * const MovieCharacter = await prisma.movieCharacter.delete({
     *   where: {
     *     // ... filter to delete one MovieCharacter
     *   }
     * })
     * 
     */
    delete<T extends MovieCharacterDeleteArgs>(args: SelectSubset<T, MovieCharacterDeleteArgs<ExtArgs>>): Prisma__MovieCharacterClient<$Result.GetResult<Prisma.$MovieCharacterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MovieCharacter.
     * @param {MovieCharacterUpdateArgs} args - Arguments to update one MovieCharacter.
     * @example
     * // Update one MovieCharacter
     * const movieCharacter = await prisma.movieCharacter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieCharacterUpdateArgs>(args: SelectSubset<T, MovieCharacterUpdateArgs<ExtArgs>>): Prisma__MovieCharacterClient<$Result.GetResult<Prisma.$MovieCharacterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MovieCharacters.
     * @param {MovieCharacterDeleteManyArgs} args - Arguments to filter MovieCharacters to delete.
     * @example
     * // Delete a few MovieCharacters
     * const { count } = await prisma.movieCharacter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieCharacterDeleteManyArgs>(args?: SelectSubset<T, MovieCharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieCharacters
     * const movieCharacter = await prisma.movieCharacter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieCharacterUpdateManyArgs>(args: SelectSubset<T, MovieCharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieCharacters and returns the data updated in the database.
     * @param {MovieCharacterUpdateManyAndReturnArgs} args - Arguments to update many MovieCharacters.
     * @example
     * // Update many MovieCharacters
     * const movieCharacter = await prisma.movieCharacter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MovieCharacters and only return the `id`
     * const movieCharacterWithIdOnly = await prisma.movieCharacter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MovieCharacterUpdateManyAndReturnArgs>(args: SelectSubset<T, MovieCharacterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCharacterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MovieCharacter.
     * @param {MovieCharacterUpsertArgs} args - Arguments to update or create a MovieCharacter.
     * @example
     * // Update or create a MovieCharacter
     * const movieCharacter = await prisma.movieCharacter.upsert({
     *   create: {
     *     // ... data to create a MovieCharacter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieCharacter we want to update
     *   }
     * })
     */
    upsert<T extends MovieCharacterUpsertArgs>(args: SelectSubset<T, MovieCharacterUpsertArgs<ExtArgs>>): Prisma__MovieCharacterClient<$Result.GetResult<Prisma.$MovieCharacterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MovieCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCharacterCountArgs} args - Arguments to filter MovieCharacters to count.
     * @example
     * // Count the number of MovieCharacters
     * const count = await prisma.movieCharacter.count({
     *   where: {
     *     // ... the filter for the MovieCharacters we want to count
     *   }
     * })
    **/
    count<T extends MovieCharacterCountArgs>(
      args?: Subset<T, MovieCharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieCharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieCharacterAggregateArgs>(args: Subset<T, MovieCharacterAggregateArgs>): Prisma.PrismaPromise<GetMovieCharacterAggregateType<T>>

    /**
     * Group by MovieCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieCharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieCharacterGroupByArgs['orderBy'] }
        : { orderBy?: MovieCharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieCharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieCharacter model
   */
  readonly fields: MovieCharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieCharacter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieCharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieCharacter model
   */
  interface MovieCharacterFieldRefs {
    readonly id: FieldRef<"MovieCharacter", 'String'>
    readonly movieId: FieldRef<"MovieCharacter", 'String'>
    readonly characterId: FieldRef<"MovieCharacter", 'String'>
    readonly voiceActor: FieldRef<"MovieCharacter", 'String'>
    readonly voiceActorJa: FieldRef<"MovieCharacter", 'String'>
    readonly importance: FieldRef<"MovieCharacter", 'Int'>
    readonly createdAt: FieldRef<"MovieCharacter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MovieCharacter findUnique
   */
  export type MovieCharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterInclude<ExtArgs> | null
    /**
     * Filter, which MovieCharacter to fetch.
     */
    where: MovieCharacterWhereUniqueInput
  }

  /**
   * MovieCharacter findUniqueOrThrow
   */
  export type MovieCharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterInclude<ExtArgs> | null
    /**
     * Filter, which MovieCharacter to fetch.
     */
    where: MovieCharacterWhereUniqueInput
  }

  /**
   * MovieCharacter findFirst
   */
  export type MovieCharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterInclude<ExtArgs> | null
    /**
     * Filter, which MovieCharacter to fetch.
     */
    where?: MovieCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieCharacters to fetch.
     */
    orderBy?: MovieCharacterOrderByWithRelationInput | MovieCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieCharacters.
     */
    cursor?: MovieCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieCharacters.
     */
    distinct?: MovieCharacterScalarFieldEnum | MovieCharacterScalarFieldEnum[]
  }

  /**
   * MovieCharacter findFirstOrThrow
   */
  export type MovieCharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterInclude<ExtArgs> | null
    /**
     * Filter, which MovieCharacter to fetch.
     */
    where?: MovieCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieCharacters to fetch.
     */
    orderBy?: MovieCharacterOrderByWithRelationInput | MovieCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieCharacters.
     */
    cursor?: MovieCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieCharacters.
     */
    distinct?: MovieCharacterScalarFieldEnum | MovieCharacterScalarFieldEnum[]
  }

  /**
   * MovieCharacter findMany
   */
  export type MovieCharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterInclude<ExtArgs> | null
    /**
     * Filter, which MovieCharacters to fetch.
     */
    where?: MovieCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieCharacters to fetch.
     */
    orderBy?: MovieCharacterOrderByWithRelationInput | MovieCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieCharacters.
     */
    cursor?: MovieCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieCharacters.
     */
    skip?: number
    distinct?: MovieCharacterScalarFieldEnum | MovieCharacterScalarFieldEnum[]
  }

  /**
   * MovieCharacter create
   */
  export type MovieCharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieCharacter.
     */
    data: XOR<MovieCharacterCreateInput, MovieCharacterUncheckedCreateInput>
  }

  /**
   * MovieCharacter createMany
   */
  export type MovieCharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieCharacters.
     */
    data: MovieCharacterCreateManyInput | MovieCharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovieCharacter createManyAndReturn
   */
  export type MovieCharacterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * The data used to create many MovieCharacters.
     */
    data: MovieCharacterCreateManyInput | MovieCharacterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieCharacter update
   */
  export type MovieCharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieCharacter.
     */
    data: XOR<MovieCharacterUpdateInput, MovieCharacterUncheckedUpdateInput>
    /**
     * Choose, which MovieCharacter to update.
     */
    where: MovieCharacterWhereUniqueInput
  }

  /**
   * MovieCharacter updateMany
   */
  export type MovieCharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieCharacters.
     */
    data: XOR<MovieCharacterUpdateManyMutationInput, MovieCharacterUncheckedUpdateManyInput>
    /**
     * Filter which MovieCharacters to update
     */
    where?: MovieCharacterWhereInput
    /**
     * Limit how many MovieCharacters to update.
     */
    limit?: number
  }

  /**
   * MovieCharacter updateManyAndReturn
   */
  export type MovieCharacterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * The data used to update MovieCharacters.
     */
    data: XOR<MovieCharacterUpdateManyMutationInput, MovieCharacterUncheckedUpdateManyInput>
    /**
     * Filter which MovieCharacters to update
     */
    where?: MovieCharacterWhereInput
    /**
     * Limit how many MovieCharacters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieCharacter upsert
   */
  export type MovieCharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieCharacter to update in case it exists.
     */
    where: MovieCharacterWhereUniqueInput
    /**
     * In case the MovieCharacter found by the `where` argument doesn't exist, create a new MovieCharacter with this data.
     */
    create: XOR<MovieCharacterCreateInput, MovieCharacterUncheckedCreateInput>
    /**
     * In case the MovieCharacter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieCharacterUpdateInput, MovieCharacterUncheckedUpdateInput>
  }

  /**
   * MovieCharacter delete
   */
  export type MovieCharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterInclude<ExtArgs> | null
    /**
     * Filter which MovieCharacter to delete.
     */
    where: MovieCharacterWhereUniqueInput
  }

  /**
   * MovieCharacter deleteMany
   */
  export type MovieCharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieCharacters to delete
     */
    where?: MovieCharacterWhereInput
    /**
     * Limit how many MovieCharacters to delete.
     */
    limit?: number
  }

  /**
   * MovieCharacter without action
   */
  export type MovieCharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCharacter
     */
    select?: MovieCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCharacter
     */
    omit?: MovieCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCharacterInclude<ExtArgs> | null
  }


  /**
   * Model CrewMember
   */

  export type AggregateCrewMember = {
    _count: CrewMemberCountAggregateOutputType | null
    _min: CrewMemberMinAggregateOutputType | null
    _max: CrewMemberMaxAggregateOutputType | null
  }

  export type CrewMemberMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameJa: string | null
    biography: string | null
    imageUrl: string | null
    birthDate: Date | null
    nationality: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrewMemberMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameJa: string | null
    biography: string | null
    imageUrl: string | null
    birthDate: Date | null
    nationality: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrewMemberCountAggregateOutputType = {
    id: number
    name: number
    nameJa: number
    biography: number
    imageUrl: number
    birthDate: number
    nationality: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CrewMemberMinAggregateInputType = {
    id?: true
    name?: true
    nameJa?: true
    biography?: true
    imageUrl?: true
    birthDate?: true
    nationality?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrewMemberMaxAggregateInputType = {
    id?: true
    name?: true
    nameJa?: true
    biography?: true
    imageUrl?: true
    birthDate?: true
    nationality?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrewMemberCountAggregateInputType = {
    id?: true
    name?: true
    nameJa?: true
    biography?: true
    imageUrl?: true
    birthDate?: true
    nationality?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CrewMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewMember to aggregate.
     */
    where?: CrewMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewMembers to fetch.
     */
    orderBy?: CrewMemberOrderByWithRelationInput | CrewMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrewMembers
    **/
    _count?: true | CrewMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewMemberMaxAggregateInputType
  }

  export type GetCrewMemberAggregateType<T extends CrewMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateCrewMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrewMember[P]>
      : GetScalarType<T[P], AggregateCrewMember[P]>
  }




  export type CrewMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewMemberWhereInput
    orderBy?: CrewMemberOrderByWithAggregationInput | CrewMemberOrderByWithAggregationInput[]
    by: CrewMemberScalarFieldEnum[] | CrewMemberScalarFieldEnum
    having?: CrewMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewMemberCountAggregateInputType | true
    _min?: CrewMemberMinAggregateInputType
    _max?: CrewMemberMaxAggregateInputType
  }

  export type CrewMemberGroupByOutputType = {
    id: string
    name: string
    nameJa: string | null
    biography: string | null
    imageUrl: string | null
    birthDate: Date | null
    nationality: string | null
    createdAt: Date
    updatedAt: Date
    _count: CrewMemberCountAggregateOutputType | null
    _min: CrewMemberMinAggregateOutputType | null
    _max: CrewMemberMaxAggregateOutputType | null
  }

  type GetCrewMemberGroupByPayload<T extends CrewMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewMemberGroupByOutputType[P]>
            : GetScalarType<T[P], CrewMemberGroupByOutputType[P]>
        }
      >
    >


  export type CrewMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameJa?: boolean
    biography?: boolean
    imageUrl?: boolean
    birthDate?: boolean
    nationality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movieCrew?: boolean | CrewMember$movieCrewArgs<ExtArgs>
    _count?: boolean | CrewMemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crewMember"]>

  export type CrewMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameJa?: boolean
    biography?: boolean
    imageUrl?: boolean
    birthDate?: boolean
    nationality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crewMember"]>

  export type CrewMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameJa?: boolean
    biography?: boolean
    imageUrl?: boolean
    birthDate?: boolean
    nationality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crewMember"]>

  export type CrewMemberSelectScalar = {
    id?: boolean
    name?: boolean
    nameJa?: boolean
    biography?: boolean
    imageUrl?: boolean
    birthDate?: boolean
    nationality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CrewMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "nameJa" | "biography" | "imageUrl" | "birthDate" | "nationality" | "createdAt" | "updatedAt", ExtArgs["result"]["crewMember"]>
  export type CrewMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movieCrew?: boolean | CrewMember$movieCrewArgs<ExtArgs>
    _count?: boolean | CrewMemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CrewMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CrewMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CrewMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrewMember"
    objects: {
      movieCrew: Prisma.$MovieCrewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      nameJa: string | null
      biography: string | null
      imageUrl: string | null
      birthDate: Date | null
      nationality: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["crewMember"]>
    composites: {}
  }

  type CrewMemberGetPayload<S extends boolean | null | undefined | CrewMemberDefaultArgs> = $Result.GetResult<Prisma.$CrewMemberPayload, S>

  type CrewMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CrewMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CrewMemberCountAggregateInputType | true
    }

  export interface CrewMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrewMember'], meta: { name: 'CrewMember' } }
    /**
     * Find zero or one CrewMember that matches the filter.
     * @param {CrewMemberFindUniqueArgs} args - Arguments to find a CrewMember
     * @example
     * // Get one CrewMember
     * const crewMember = await prisma.crewMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrewMemberFindUniqueArgs>(args: SelectSubset<T, CrewMemberFindUniqueArgs<ExtArgs>>): Prisma__CrewMemberClient<$Result.GetResult<Prisma.$CrewMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CrewMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CrewMemberFindUniqueOrThrowArgs} args - Arguments to find a CrewMember
     * @example
     * // Get one CrewMember
     * const crewMember = await prisma.crewMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrewMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, CrewMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrewMemberClient<$Result.GetResult<Prisma.$CrewMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrewMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewMemberFindFirstArgs} args - Arguments to find a CrewMember
     * @example
     * // Get one CrewMember
     * const crewMember = await prisma.crewMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrewMemberFindFirstArgs>(args?: SelectSubset<T, CrewMemberFindFirstArgs<ExtArgs>>): Prisma__CrewMemberClient<$Result.GetResult<Prisma.$CrewMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrewMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewMemberFindFirstOrThrowArgs} args - Arguments to find a CrewMember
     * @example
     * // Get one CrewMember
     * const crewMember = await prisma.crewMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrewMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, CrewMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrewMemberClient<$Result.GetResult<Prisma.$CrewMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CrewMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrewMembers
     * const crewMembers = await prisma.crewMember.findMany()
     * 
     * // Get first 10 CrewMembers
     * const crewMembers = await prisma.crewMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crewMemberWithIdOnly = await prisma.crewMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrewMemberFindManyArgs>(args?: SelectSubset<T, CrewMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CrewMember.
     * @param {CrewMemberCreateArgs} args - Arguments to create a CrewMember.
     * @example
     * // Create one CrewMember
     * const CrewMember = await prisma.crewMember.create({
     *   data: {
     *     // ... data to create a CrewMember
     *   }
     * })
     * 
     */
    create<T extends CrewMemberCreateArgs>(args: SelectSubset<T, CrewMemberCreateArgs<ExtArgs>>): Prisma__CrewMemberClient<$Result.GetResult<Prisma.$CrewMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CrewMembers.
     * @param {CrewMemberCreateManyArgs} args - Arguments to create many CrewMembers.
     * @example
     * // Create many CrewMembers
     * const crewMember = await prisma.crewMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrewMemberCreateManyArgs>(args?: SelectSubset<T, CrewMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrewMembers and returns the data saved in the database.
     * @param {CrewMemberCreateManyAndReturnArgs} args - Arguments to create many CrewMembers.
     * @example
     * // Create many CrewMembers
     * const crewMember = await prisma.crewMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrewMembers and only return the `id`
     * const crewMemberWithIdOnly = await prisma.crewMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrewMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, CrewMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CrewMember.
     * @param {CrewMemberDeleteArgs} args - Arguments to delete one CrewMember.
     * @example
     * // Delete one CrewMember
     * const CrewMember = await prisma.crewMember.delete({
     *   where: {
     *     // ... filter to delete one CrewMember
     *   }
     * })
     * 
     */
    delete<T extends CrewMemberDeleteArgs>(args: SelectSubset<T, CrewMemberDeleteArgs<ExtArgs>>): Prisma__CrewMemberClient<$Result.GetResult<Prisma.$CrewMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CrewMember.
     * @param {CrewMemberUpdateArgs} args - Arguments to update one CrewMember.
     * @example
     * // Update one CrewMember
     * const crewMember = await prisma.crewMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrewMemberUpdateArgs>(args: SelectSubset<T, CrewMemberUpdateArgs<ExtArgs>>): Prisma__CrewMemberClient<$Result.GetResult<Prisma.$CrewMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CrewMembers.
     * @param {CrewMemberDeleteManyArgs} args - Arguments to filter CrewMembers to delete.
     * @example
     * // Delete a few CrewMembers
     * const { count } = await prisma.crewMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrewMemberDeleteManyArgs>(args?: SelectSubset<T, CrewMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrewMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrewMembers
     * const crewMember = await prisma.crewMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrewMemberUpdateManyArgs>(args: SelectSubset<T, CrewMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrewMembers and returns the data updated in the database.
     * @param {CrewMemberUpdateManyAndReturnArgs} args - Arguments to update many CrewMembers.
     * @example
     * // Update many CrewMembers
     * const crewMember = await prisma.crewMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CrewMembers and only return the `id`
     * const crewMemberWithIdOnly = await prisma.crewMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CrewMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, CrewMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CrewMember.
     * @param {CrewMemberUpsertArgs} args - Arguments to update or create a CrewMember.
     * @example
     * // Update or create a CrewMember
     * const crewMember = await prisma.crewMember.upsert({
     *   create: {
     *     // ... data to create a CrewMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrewMember we want to update
     *   }
     * })
     */
    upsert<T extends CrewMemberUpsertArgs>(args: SelectSubset<T, CrewMemberUpsertArgs<ExtArgs>>): Prisma__CrewMemberClient<$Result.GetResult<Prisma.$CrewMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CrewMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewMemberCountArgs} args - Arguments to filter CrewMembers to count.
     * @example
     * // Count the number of CrewMembers
     * const count = await prisma.crewMember.count({
     *   where: {
     *     // ... the filter for the CrewMembers we want to count
     *   }
     * })
    **/
    count<T extends CrewMemberCountArgs>(
      args?: Subset<T, CrewMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrewMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewMemberAggregateArgs>(args: Subset<T, CrewMemberAggregateArgs>): Prisma.PrismaPromise<GetCrewMemberAggregateType<T>>

    /**
     * Group by CrewMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewMemberGroupByArgs['orderBy'] }
        : { orderBy?: CrewMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrewMember model
   */
  readonly fields: CrewMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrewMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movieCrew<T extends CrewMember$movieCrewArgs<ExtArgs> = {}>(args?: Subset<T, CrewMember$movieCrewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCrewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrewMember model
   */
  interface CrewMemberFieldRefs {
    readonly id: FieldRef<"CrewMember", 'String'>
    readonly name: FieldRef<"CrewMember", 'String'>
    readonly nameJa: FieldRef<"CrewMember", 'String'>
    readonly biography: FieldRef<"CrewMember", 'String'>
    readonly imageUrl: FieldRef<"CrewMember", 'String'>
    readonly birthDate: FieldRef<"CrewMember", 'DateTime'>
    readonly nationality: FieldRef<"CrewMember", 'String'>
    readonly createdAt: FieldRef<"CrewMember", 'DateTime'>
    readonly updatedAt: FieldRef<"CrewMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CrewMember findUnique
   */
  export type CrewMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewMember
     */
    select?: CrewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrewMember
     */
    omit?: CrewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewMemberInclude<ExtArgs> | null
    /**
     * Filter, which CrewMember to fetch.
     */
    where: CrewMemberWhereUniqueInput
  }

  /**
   * CrewMember findUniqueOrThrow
   */
  export type CrewMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewMember
     */
    select?: CrewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrewMember
     */
    omit?: CrewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewMemberInclude<ExtArgs> | null
    /**
     * Filter, which CrewMember to fetch.
     */
    where: CrewMemberWhereUniqueInput
  }

  /**
   * CrewMember findFirst
   */
  export type CrewMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewMember
     */
    select?: CrewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrewMember
     */
    omit?: CrewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewMemberInclude<ExtArgs> | null
    /**
     * Filter, which CrewMember to fetch.
     */
    where?: CrewMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewMembers to fetch.
     */
    orderBy?: CrewMemberOrderByWithRelationInput | CrewMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewMembers.
     */
    cursor?: CrewMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewMembers.
     */
    distinct?: CrewMemberScalarFieldEnum | CrewMemberScalarFieldEnum[]
  }

  /**
   * CrewMember findFirstOrThrow
   */
  export type CrewMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewMember
     */
    select?: CrewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrewMember
     */
    omit?: CrewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewMemberInclude<ExtArgs> | null
    /**
     * Filter, which CrewMember to fetch.
     */
    where?: CrewMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewMembers to fetch.
     */
    orderBy?: CrewMemberOrderByWithRelationInput | CrewMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewMembers.
     */
    cursor?: CrewMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewMembers.
     */
    distinct?: CrewMemberScalarFieldEnum | CrewMemberScalarFieldEnum[]
  }

  /**
   * CrewMember findMany
   */
  export type CrewMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewMember
     */
    select?: CrewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrewMember
     */
    omit?: CrewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewMemberInclude<ExtArgs> | null
    /**
     * Filter, which CrewMembers to fetch.
     */
    where?: CrewMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewMembers to fetch.
     */
    orderBy?: CrewMemberOrderByWithRelationInput | CrewMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrewMembers.
     */
    cursor?: CrewMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewMembers.
     */
    skip?: number
    distinct?: CrewMemberScalarFieldEnum | CrewMemberScalarFieldEnum[]
  }

  /**
   * CrewMember create
   */
  export type CrewMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewMember
     */
    select?: CrewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrewMember
     */
    omit?: CrewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a CrewMember.
     */
    data: XOR<CrewMemberCreateInput, CrewMemberUncheckedCreateInput>
  }

  /**
   * CrewMember createMany
   */
  export type CrewMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrewMembers.
     */
    data: CrewMemberCreateManyInput | CrewMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrewMember createManyAndReturn
   */
  export type CrewMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewMember
     */
    select?: CrewMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrewMember
     */
    omit?: CrewMemberOmit<ExtArgs> | null
    /**
     * The data used to create many CrewMembers.
     */
    data: CrewMemberCreateManyInput | CrewMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrewMember update
   */
  export type CrewMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewMember
     */
    select?: CrewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrewMember
     */
    omit?: CrewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a CrewMember.
     */
    data: XOR<CrewMemberUpdateInput, CrewMemberUncheckedUpdateInput>
    /**
     * Choose, which CrewMember to update.
     */
    where: CrewMemberWhereUniqueInput
  }

  /**
   * CrewMember updateMany
   */
  export type CrewMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrewMembers.
     */
    data: XOR<CrewMemberUpdateManyMutationInput, CrewMemberUncheckedUpdateManyInput>
    /**
     * Filter which CrewMembers to update
     */
    where?: CrewMemberWhereInput
    /**
     * Limit how many CrewMembers to update.
     */
    limit?: number
  }

  /**
   * CrewMember updateManyAndReturn
   */
  export type CrewMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewMember
     */
    select?: CrewMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrewMember
     */
    omit?: CrewMemberOmit<ExtArgs> | null
    /**
     * The data used to update CrewMembers.
     */
    data: XOR<CrewMemberUpdateManyMutationInput, CrewMemberUncheckedUpdateManyInput>
    /**
     * Filter which CrewMembers to update
     */
    where?: CrewMemberWhereInput
    /**
     * Limit how many CrewMembers to update.
     */
    limit?: number
  }

  /**
   * CrewMember upsert
   */
  export type CrewMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewMember
     */
    select?: CrewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrewMember
     */
    omit?: CrewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the CrewMember to update in case it exists.
     */
    where: CrewMemberWhereUniqueInput
    /**
     * In case the CrewMember found by the `where` argument doesn't exist, create a new CrewMember with this data.
     */
    create: XOR<CrewMemberCreateInput, CrewMemberUncheckedCreateInput>
    /**
     * In case the CrewMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewMemberUpdateInput, CrewMemberUncheckedUpdateInput>
  }

  /**
   * CrewMember delete
   */
  export type CrewMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewMember
     */
    select?: CrewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrewMember
     */
    omit?: CrewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewMemberInclude<ExtArgs> | null
    /**
     * Filter which CrewMember to delete.
     */
    where: CrewMemberWhereUniqueInput
  }

  /**
   * CrewMember deleteMany
   */
  export type CrewMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewMembers to delete
     */
    where?: CrewMemberWhereInput
    /**
     * Limit how many CrewMembers to delete.
     */
    limit?: number
  }

  /**
   * CrewMember.movieCrew
   */
  export type CrewMember$movieCrewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewInclude<ExtArgs> | null
    where?: MovieCrewWhereInput
    orderBy?: MovieCrewOrderByWithRelationInput | MovieCrewOrderByWithRelationInput[]
    cursor?: MovieCrewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieCrewScalarFieldEnum | MovieCrewScalarFieldEnum[]
  }

  /**
   * CrewMember without action
   */
  export type CrewMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewMember
     */
    select?: CrewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrewMember
     */
    omit?: CrewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewMemberInclude<ExtArgs> | null
  }


  /**
   * Model MovieCrew
   */

  export type AggregateMovieCrew = {
    _count: MovieCrewCountAggregateOutputType | null
    _min: MovieCrewMinAggregateOutputType | null
    _max: MovieCrewMaxAggregateOutputType | null
  }

  export type MovieCrewMinAggregateOutputType = {
    id: string | null
    movieId: string | null
    crewMemberId: string | null
    role: $Enums.CrewRole | null
    department: string | null
    createdAt: Date | null
  }

  export type MovieCrewMaxAggregateOutputType = {
    id: string | null
    movieId: string | null
    crewMemberId: string | null
    role: $Enums.CrewRole | null
    department: string | null
    createdAt: Date | null
  }

  export type MovieCrewCountAggregateOutputType = {
    id: number
    movieId: number
    crewMemberId: number
    role: number
    department: number
    createdAt: number
    _all: number
  }


  export type MovieCrewMinAggregateInputType = {
    id?: true
    movieId?: true
    crewMemberId?: true
    role?: true
    department?: true
    createdAt?: true
  }

  export type MovieCrewMaxAggregateInputType = {
    id?: true
    movieId?: true
    crewMemberId?: true
    role?: true
    department?: true
    createdAt?: true
  }

  export type MovieCrewCountAggregateInputType = {
    id?: true
    movieId?: true
    crewMemberId?: true
    role?: true
    department?: true
    createdAt?: true
    _all?: true
  }

  export type MovieCrewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieCrew to aggregate.
     */
    where?: MovieCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieCrews to fetch.
     */
    orderBy?: MovieCrewOrderByWithRelationInput | MovieCrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieCrews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieCrews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieCrews
    **/
    _count?: true | MovieCrewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieCrewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieCrewMaxAggregateInputType
  }

  export type GetMovieCrewAggregateType<T extends MovieCrewAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieCrew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieCrew[P]>
      : GetScalarType<T[P], AggregateMovieCrew[P]>
  }




  export type MovieCrewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieCrewWhereInput
    orderBy?: MovieCrewOrderByWithAggregationInput | MovieCrewOrderByWithAggregationInput[]
    by: MovieCrewScalarFieldEnum[] | MovieCrewScalarFieldEnum
    having?: MovieCrewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieCrewCountAggregateInputType | true
    _min?: MovieCrewMinAggregateInputType
    _max?: MovieCrewMaxAggregateInputType
  }

  export type MovieCrewGroupByOutputType = {
    id: string
    movieId: string
    crewMemberId: string
    role: $Enums.CrewRole
    department: string | null
    createdAt: Date
    _count: MovieCrewCountAggregateOutputType | null
    _min: MovieCrewMinAggregateOutputType | null
    _max: MovieCrewMaxAggregateOutputType | null
  }

  type GetMovieCrewGroupByPayload<T extends MovieCrewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieCrewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieCrewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieCrewGroupByOutputType[P]>
            : GetScalarType<T[P], MovieCrewGroupByOutputType[P]>
        }
      >
    >


  export type MovieCrewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    crewMemberId?: boolean
    role?: boolean
    department?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    crewMember?: boolean | CrewMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieCrew"]>

  export type MovieCrewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    crewMemberId?: boolean
    role?: boolean
    department?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    crewMember?: boolean | CrewMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieCrew"]>

  export type MovieCrewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    crewMemberId?: boolean
    role?: boolean
    department?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    crewMember?: boolean | CrewMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieCrew"]>

  export type MovieCrewSelectScalar = {
    id?: boolean
    movieId?: boolean
    crewMemberId?: boolean
    role?: boolean
    department?: boolean
    createdAt?: boolean
  }

  export type MovieCrewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "movieId" | "crewMemberId" | "role" | "department" | "createdAt", ExtArgs["result"]["movieCrew"]>
  export type MovieCrewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    crewMember?: boolean | CrewMemberDefaultArgs<ExtArgs>
  }
  export type MovieCrewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    crewMember?: boolean | CrewMemberDefaultArgs<ExtArgs>
  }
  export type MovieCrewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    crewMember?: boolean | CrewMemberDefaultArgs<ExtArgs>
  }

  export type $MovieCrewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieCrew"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
      crewMember: Prisma.$CrewMemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      movieId: string
      crewMemberId: string
      role: $Enums.CrewRole
      department: string | null
      createdAt: Date
    }, ExtArgs["result"]["movieCrew"]>
    composites: {}
  }

  type MovieCrewGetPayload<S extends boolean | null | undefined | MovieCrewDefaultArgs> = $Result.GetResult<Prisma.$MovieCrewPayload, S>

  type MovieCrewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MovieCrewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MovieCrewCountAggregateInputType | true
    }

  export interface MovieCrewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieCrew'], meta: { name: 'MovieCrew' } }
    /**
     * Find zero or one MovieCrew that matches the filter.
     * @param {MovieCrewFindUniqueArgs} args - Arguments to find a MovieCrew
     * @example
     * // Get one MovieCrew
     * const movieCrew = await prisma.movieCrew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieCrewFindUniqueArgs>(args: SelectSubset<T, MovieCrewFindUniqueArgs<ExtArgs>>): Prisma__MovieCrewClient<$Result.GetResult<Prisma.$MovieCrewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MovieCrew that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MovieCrewFindUniqueOrThrowArgs} args - Arguments to find a MovieCrew
     * @example
     * // Get one MovieCrew
     * const movieCrew = await prisma.movieCrew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieCrewFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieCrewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieCrewClient<$Result.GetResult<Prisma.$MovieCrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MovieCrew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCrewFindFirstArgs} args - Arguments to find a MovieCrew
     * @example
     * // Get one MovieCrew
     * const movieCrew = await prisma.movieCrew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieCrewFindFirstArgs>(args?: SelectSubset<T, MovieCrewFindFirstArgs<ExtArgs>>): Prisma__MovieCrewClient<$Result.GetResult<Prisma.$MovieCrewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MovieCrew that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCrewFindFirstOrThrowArgs} args - Arguments to find a MovieCrew
     * @example
     * // Get one MovieCrew
     * const movieCrew = await prisma.movieCrew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieCrewFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieCrewFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieCrewClient<$Result.GetResult<Prisma.$MovieCrewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MovieCrews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCrewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieCrews
     * const movieCrews = await prisma.movieCrew.findMany()
     * 
     * // Get first 10 MovieCrews
     * const movieCrews = await prisma.movieCrew.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieCrewWithIdOnly = await prisma.movieCrew.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieCrewFindManyArgs>(args?: SelectSubset<T, MovieCrewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCrewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MovieCrew.
     * @param {MovieCrewCreateArgs} args - Arguments to create a MovieCrew.
     * @example
     * // Create one MovieCrew
     * const MovieCrew = await prisma.movieCrew.create({
     *   data: {
     *     // ... data to create a MovieCrew
     *   }
     * })
     * 
     */
    create<T extends MovieCrewCreateArgs>(args: SelectSubset<T, MovieCrewCreateArgs<ExtArgs>>): Prisma__MovieCrewClient<$Result.GetResult<Prisma.$MovieCrewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MovieCrews.
     * @param {MovieCrewCreateManyArgs} args - Arguments to create many MovieCrews.
     * @example
     * // Create many MovieCrews
     * const movieCrew = await prisma.movieCrew.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieCrewCreateManyArgs>(args?: SelectSubset<T, MovieCrewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieCrews and returns the data saved in the database.
     * @param {MovieCrewCreateManyAndReturnArgs} args - Arguments to create many MovieCrews.
     * @example
     * // Create many MovieCrews
     * const movieCrew = await prisma.movieCrew.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieCrews and only return the `id`
     * const movieCrewWithIdOnly = await prisma.movieCrew.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieCrewCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieCrewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCrewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MovieCrew.
     * @param {MovieCrewDeleteArgs} args - Arguments to delete one MovieCrew.
     * @example
     * // Delete one MovieCrew
     * const MovieCrew = await prisma.movieCrew.delete({
     *   where: {
     *     // ... filter to delete one MovieCrew
     *   }
     * })
     * 
     */
    delete<T extends MovieCrewDeleteArgs>(args: SelectSubset<T, MovieCrewDeleteArgs<ExtArgs>>): Prisma__MovieCrewClient<$Result.GetResult<Prisma.$MovieCrewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MovieCrew.
     * @param {MovieCrewUpdateArgs} args - Arguments to update one MovieCrew.
     * @example
     * // Update one MovieCrew
     * const movieCrew = await prisma.movieCrew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieCrewUpdateArgs>(args: SelectSubset<T, MovieCrewUpdateArgs<ExtArgs>>): Prisma__MovieCrewClient<$Result.GetResult<Prisma.$MovieCrewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MovieCrews.
     * @param {MovieCrewDeleteManyArgs} args - Arguments to filter MovieCrews to delete.
     * @example
     * // Delete a few MovieCrews
     * const { count } = await prisma.movieCrew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieCrewDeleteManyArgs>(args?: SelectSubset<T, MovieCrewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieCrews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCrewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieCrews
     * const movieCrew = await prisma.movieCrew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieCrewUpdateManyArgs>(args: SelectSubset<T, MovieCrewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieCrews and returns the data updated in the database.
     * @param {MovieCrewUpdateManyAndReturnArgs} args - Arguments to update many MovieCrews.
     * @example
     * // Update many MovieCrews
     * const movieCrew = await prisma.movieCrew.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MovieCrews and only return the `id`
     * const movieCrewWithIdOnly = await prisma.movieCrew.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MovieCrewUpdateManyAndReturnArgs>(args: SelectSubset<T, MovieCrewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCrewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MovieCrew.
     * @param {MovieCrewUpsertArgs} args - Arguments to update or create a MovieCrew.
     * @example
     * // Update or create a MovieCrew
     * const movieCrew = await prisma.movieCrew.upsert({
     *   create: {
     *     // ... data to create a MovieCrew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieCrew we want to update
     *   }
     * })
     */
    upsert<T extends MovieCrewUpsertArgs>(args: SelectSubset<T, MovieCrewUpsertArgs<ExtArgs>>): Prisma__MovieCrewClient<$Result.GetResult<Prisma.$MovieCrewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MovieCrews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCrewCountArgs} args - Arguments to filter MovieCrews to count.
     * @example
     * // Count the number of MovieCrews
     * const count = await prisma.movieCrew.count({
     *   where: {
     *     // ... the filter for the MovieCrews we want to count
     *   }
     * })
    **/
    count<T extends MovieCrewCountArgs>(
      args?: Subset<T, MovieCrewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieCrewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieCrew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCrewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieCrewAggregateArgs>(args: Subset<T, MovieCrewAggregateArgs>): Prisma.PrismaPromise<GetMovieCrewAggregateType<T>>

    /**
     * Group by MovieCrew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCrewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieCrewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieCrewGroupByArgs['orderBy'] }
        : { orderBy?: MovieCrewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieCrewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieCrewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieCrew model
   */
  readonly fields: MovieCrewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieCrew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieCrewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    crewMember<T extends CrewMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrewMemberDefaultArgs<ExtArgs>>): Prisma__CrewMemberClient<$Result.GetResult<Prisma.$CrewMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieCrew model
   */
  interface MovieCrewFieldRefs {
    readonly id: FieldRef<"MovieCrew", 'String'>
    readonly movieId: FieldRef<"MovieCrew", 'String'>
    readonly crewMemberId: FieldRef<"MovieCrew", 'String'>
    readonly role: FieldRef<"MovieCrew", 'CrewRole'>
    readonly department: FieldRef<"MovieCrew", 'String'>
    readonly createdAt: FieldRef<"MovieCrew", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MovieCrew findUnique
   */
  export type MovieCrewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewInclude<ExtArgs> | null
    /**
     * Filter, which MovieCrew to fetch.
     */
    where: MovieCrewWhereUniqueInput
  }

  /**
   * MovieCrew findUniqueOrThrow
   */
  export type MovieCrewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewInclude<ExtArgs> | null
    /**
     * Filter, which MovieCrew to fetch.
     */
    where: MovieCrewWhereUniqueInput
  }

  /**
   * MovieCrew findFirst
   */
  export type MovieCrewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewInclude<ExtArgs> | null
    /**
     * Filter, which MovieCrew to fetch.
     */
    where?: MovieCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieCrews to fetch.
     */
    orderBy?: MovieCrewOrderByWithRelationInput | MovieCrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieCrews.
     */
    cursor?: MovieCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieCrews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieCrews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieCrews.
     */
    distinct?: MovieCrewScalarFieldEnum | MovieCrewScalarFieldEnum[]
  }

  /**
   * MovieCrew findFirstOrThrow
   */
  export type MovieCrewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewInclude<ExtArgs> | null
    /**
     * Filter, which MovieCrew to fetch.
     */
    where?: MovieCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieCrews to fetch.
     */
    orderBy?: MovieCrewOrderByWithRelationInput | MovieCrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieCrews.
     */
    cursor?: MovieCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieCrews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieCrews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieCrews.
     */
    distinct?: MovieCrewScalarFieldEnum | MovieCrewScalarFieldEnum[]
  }

  /**
   * MovieCrew findMany
   */
  export type MovieCrewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewInclude<ExtArgs> | null
    /**
     * Filter, which MovieCrews to fetch.
     */
    where?: MovieCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieCrews to fetch.
     */
    orderBy?: MovieCrewOrderByWithRelationInput | MovieCrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieCrews.
     */
    cursor?: MovieCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieCrews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieCrews.
     */
    skip?: number
    distinct?: MovieCrewScalarFieldEnum | MovieCrewScalarFieldEnum[]
  }

  /**
   * MovieCrew create
   */
  export type MovieCrewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieCrew.
     */
    data: XOR<MovieCrewCreateInput, MovieCrewUncheckedCreateInput>
  }

  /**
   * MovieCrew createMany
   */
  export type MovieCrewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieCrews.
     */
    data: MovieCrewCreateManyInput | MovieCrewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovieCrew createManyAndReturn
   */
  export type MovieCrewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * The data used to create many MovieCrews.
     */
    data: MovieCrewCreateManyInput | MovieCrewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieCrew update
   */
  export type MovieCrewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieCrew.
     */
    data: XOR<MovieCrewUpdateInput, MovieCrewUncheckedUpdateInput>
    /**
     * Choose, which MovieCrew to update.
     */
    where: MovieCrewWhereUniqueInput
  }

  /**
   * MovieCrew updateMany
   */
  export type MovieCrewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieCrews.
     */
    data: XOR<MovieCrewUpdateManyMutationInput, MovieCrewUncheckedUpdateManyInput>
    /**
     * Filter which MovieCrews to update
     */
    where?: MovieCrewWhereInput
    /**
     * Limit how many MovieCrews to update.
     */
    limit?: number
  }

  /**
   * MovieCrew updateManyAndReturn
   */
  export type MovieCrewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * The data used to update MovieCrews.
     */
    data: XOR<MovieCrewUpdateManyMutationInput, MovieCrewUncheckedUpdateManyInput>
    /**
     * Filter which MovieCrews to update
     */
    where?: MovieCrewWhereInput
    /**
     * Limit how many MovieCrews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieCrew upsert
   */
  export type MovieCrewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieCrew to update in case it exists.
     */
    where: MovieCrewWhereUniqueInput
    /**
     * In case the MovieCrew found by the `where` argument doesn't exist, create a new MovieCrew with this data.
     */
    create: XOR<MovieCrewCreateInput, MovieCrewUncheckedCreateInput>
    /**
     * In case the MovieCrew was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieCrewUpdateInput, MovieCrewUncheckedUpdateInput>
  }

  /**
   * MovieCrew delete
   */
  export type MovieCrewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewInclude<ExtArgs> | null
    /**
     * Filter which MovieCrew to delete.
     */
    where: MovieCrewWhereUniqueInput
  }

  /**
   * MovieCrew deleteMany
   */
  export type MovieCrewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieCrews to delete
     */
    where?: MovieCrewWhereInput
    /**
     * Limit how many MovieCrews to delete.
     */
    limit?: number
  }

  /**
   * MovieCrew without action
   */
  export type MovieCrewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCrew
     */
    select?: MovieCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieCrew
     */
    omit?: MovieCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCrewInclude<ExtArgs> | null
  }


  /**
   * Model MovieReview
   */

  export type AggregateMovieReview = {
    _count: MovieReviewCountAggregateOutputType | null
    _avg: MovieReviewAvgAggregateOutputType | null
    _sum: MovieReviewSumAggregateOutputType | null
    _min: MovieReviewMinAggregateOutputType | null
    _max: MovieReviewMaxAggregateOutputType | null
  }

  export type MovieReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type MovieReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type MovieReviewMinAggregateOutputType = {
    id: string | null
    movieId: string | null
    title: string | null
    content: string | null
    author: string | null
    rating: number | null
    reviewType: $Enums.ReviewType | null
    language: string | null
    isPublished: boolean | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovieReviewMaxAggregateOutputType = {
    id: string | null
    movieId: string | null
    title: string | null
    content: string | null
    author: string | null
    rating: number | null
    reviewType: $Enums.ReviewType | null
    language: string | null
    isPublished: boolean | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovieReviewCountAggregateOutputType = {
    id: number
    movieId: number
    title: number
    content: number
    author: number
    rating: number
    reviewType: number
    language: number
    isPublished: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MovieReviewAvgAggregateInputType = {
    rating?: true
  }

  export type MovieReviewSumAggregateInputType = {
    rating?: true
  }

  export type MovieReviewMinAggregateInputType = {
    id?: true
    movieId?: true
    title?: true
    content?: true
    author?: true
    rating?: true
    reviewType?: true
    language?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovieReviewMaxAggregateInputType = {
    id?: true
    movieId?: true
    title?: true
    content?: true
    author?: true
    rating?: true
    reviewType?: true
    language?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovieReviewCountAggregateInputType = {
    id?: true
    movieId?: true
    title?: true
    content?: true
    author?: true
    rating?: true
    reviewType?: true
    language?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MovieReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieReview to aggregate.
     */
    where?: MovieReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieReviews to fetch.
     */
    orderBy?: MovieReviewOrderByWithRelationInput | MovieReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieReviews
    **/
    _count?: true | MovieReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieReviewMaxAggregateInputType
  }

  export type GetMovieReviewAggregateType<T extends MovieReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieReview[P]>
      : GetScalarType<T[P], AggregateMovieReview[P]>
  }




  export type MovieReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieReviewWhereInput
    orderBy?: MovieReviewOrderByWithAggregationInput | MovieReviewOrderByWithAggregationInput[]
    by: MovieReviewScalarFieldEnum[] | MovieReviewScalarFieldEnum
    having?: MovieReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieReviewCountAggregateInputType | true
    _avg?: MovieReviewAvgAggregateInputType
    _sum?: MovieReviewSumAggregateInputType
    _min?: MovieReviewMinAggregateInputType
    _max?: MovieReviewMaxAggregateInputType
  }

  export type MovieReviewGroupByOutputType = {
    id: string
    movieId: string
    title: string
    content: string
    author: string
    rating: number | null
    reviewType: $Enums.ReviewType
    language: string
    isPublished: boolean
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MovieReviewCountAggregateOutputType | null
    _avg: MovieReviewAvgAggregateOutputType | null
    _sum: MovieReviewSumAggregateOutputType | null
    _min: MovieReviewMinAggregateOutputType | null
    _max: MovieReviewMaxAggregateOutputType | null
  }

  type GetMovieReviewGroupByPayload<T extends MovieReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieReviewGroupByOutputType[P]>
            : GetScalarType<T[P], MovieReviewGroupByOutputType[P]>
        }
      >
    >


  export type MovieReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    title?: boolean
    content?: boolean
    author?: boolean
    rating?: boolean
    reviewType?: boolean
    language?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieReview"]>

  export type MovieReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    title?: boolean
    content?: boolean
    author?: boolean
    rating?: boolean
    reviewType?: boolean
    language?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieReview"]>

  export type MovieReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    title?: boolean
    content?: boolean
    author?: boolean
    rating?: boolean
    reviewType?: boolean
    language?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieReview"]>

  export type MovieReviewSelectScalar = {
    id?: boolean
    movieId?: boolean
    title?: boolean
    content?: boolean
    author?: boolean
    rating?: boolean
    reviewType?: boolean
    language?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MovieReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "movieId" | "title" | "content" | "author" | "rating" | "reviewType" | "language" | "isPublished" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["movieReview"]>
  export type MovieReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }
  export type MovieReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }
  export type MovieReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }

  export type $MovieReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieReview"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      movieId: string
      title: string
      content: string
      author: string
      rating: number | null
      reviewType: $Enums.ReviewType
      language: string
      isPublished: boolean
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["movieReview"]>
    composites: {}
  }

  type MovieReviewGetPayload<S extends boolean | null | undefined | MovieReviewDefaultArgs> = $Result.GetResult<Prisma.$MovieReviewPayload, S>

  type MovieReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MovieReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MovieReviewCountAggregateInputType | true
    }

  export interface MovieReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieReview'], meta: { name: 'MovieReview' } }
    /**
     * Find zero or one MovieReview that matches the filter.
     * @param {MovieReviewFindUniqueArgs} args - Arguments to find a MovieReview
     * @example
     * // Get one MovieReview
     * const movieReview = await prisma.movieReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieReviewFindUniqueArgs>(args: SelectSubset<T, MovieReviewFindUniqueArgs<ExtArgs>>): Prisma__MovieReviewClient<$Result.GetResult<Prisma.$MovieReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MovieReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MovieReviewFindUniqueOrThrowArgs} args - Arguments to find a MovieReview
     * @example
     * // Get one MovieReview
     * const movieReview = await prisma.movieReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieReviewClient<$Result.GetResult<Prisma.$MovieReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MovieReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieReviewFindFirstArgs} args - Arguments to find a MovieReview
     * @example
     * // Get one MovieReview
     * const movieReview = await prisma.movieReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieReviewFindFirstArgs>(args?: SelectSubset<T, MovieReviewFindFirstArgs<ExtArgs>>): Prisma__MovieReviewClient<$Result.GetResult<Prisma.$MovieReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MovieReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieReviewFindFirstOrThrowArgs} args - Arguments to find a MovieReview
     * @example
     * // Get one MovieReview
     * const movieReview = await prisma.movieReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieReviewClient<$Result.GetResult<Prisma.$MovieReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MovieReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieReviews
     * const movieReviews = await prisma.movieReview.findMany()
     * 
     * // Get first 10 MovieReviews
     * const movieReviews = await prisma.movieReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieReviewWithIdOnly = await prisma.movieReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieReviewFindManyArgs>(args?: SelectSubset<T, MovieReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MovieReview.
     * @param {MovieReviewCreateArgs} args - Arguments to create a MovieReview.
     * @example
     * // Create one MovieReview
     * const MovieReview = await prisma.movieReview.create({
     *   data: {
     *     // ... data to create a MovieReview
     *   }
     * })
     * 
     */
    create<T extends MovieReviewCreateArgs>(args: SelectSubset<T, MovieReviewCreateArgs<ExtArgs>>): Prisma__MovieReviewClient<$Result.GetResult<Prisma.$MovieReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MovieReviews.
     * @param {MovieReviewCreateManyArgs} args - Arguments to create many MovieReviews.
     * @example
     * // Create many MovieReviews
     * const movieReview = await prisma.movieReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieReviewCreateManyArgs>(args?: SelectSubset<T, MovieReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieReviews and returns the data saved in the database.
     * @param {MovieReviewCreateManyAndReturnArgs} args - Arguments to create many MovieReviews.
     * @example
     * // Create many MovieReviews
     * const movieReview = await prisma.movieReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieReviews and only return the `id`
     * const movieReviewWithIdOnly = await prisma.movieReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MovieReview.
     * @param {MovieReviewDeleteArgs} args - Arguments to delete one MovieReview.
     * @example
     * // Delete one MovieReview
     * const MovieReview = await prisma.movieReview.delete({
     *   where: {
     *     // ... filter to delete one MovieReview
     *   }
     * })
     * 
     */
    delete<T extends MovieReviewDeleteArgs>(args: SelectSubset<T, MovieReviewDeleteArgs<ExtArgs>>): Prisma__MovieReviewClient<$Result.GetResult<Prisma.$MovieReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MovieReview.
     * @param {MovieReviewUpdateArgs} args - Arguments to update one MovieReview.
     * @example
     * // Update one MovieReview
     * const movieReview = await prisma.movieReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieReviewUpdateArgs>(args: SelectSubset<T, MovieReviewUpdateArgs<ExtArgs>>): Prisma__MovieReviewClient<$Result.GetResult<Prisma.$MovieReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MovieReviews.
     * @param {MovieReviewDeleteManyArgs} args - Arguments to filter MovieReviews to delete.
     * @example
     * // Delete a few MovieReviews
     * const { count } = await prisma.movieReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieReviewDeleteManyArgs>(args?: SelectSubset<T, MovieReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieReviews
     * const movieReview = await prisma.movieReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieReviewUpdateManyArgs>(args: SelectSubset<T, MovieReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieReviews and returns the data updated in the database.
     * @param {MovieReviewUpdateManyAndReturnArgs} args - Arguments to update many MovieReviews.
     * @example
     * // Update many MovieReviews
     * const movieReview = await prisma.movieReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MovieReviews and only return the `id`
     * const movieReviewWithIdOnly = await prisma.movieReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MovieReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, MovieReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MovieReview.
     * @param {MovieReviewUpsertArgs} args - Arguments to update or create a MovieReview.
     * @example
     * // Update or create a MovieReview
     * const movieReview = await prisma.movieReview.upsert({
     *   create: {
     *     // ... data to create a MovieReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieReview we want to update
     *   }
     * })
     */
    upsert<T extends MovieReviewUpsertArgs>(args: SelectSubset<T, MovieReviewUpsertArgs<ExtArgs>>): Prisma__MovieReviewClient<$Result.GetResult<Prisma.$MovieReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MovieReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieReviewCountArgs} args - Arguments to filter MovieReviews to count.
     * @example
     * // Count the number of MovieReviews
     * const count = await prisma.movieReview.count({
     *   where: {
     *     // ... the filter for the MovieReviews we want to count
     *   }
     * })
    **/
    count<T extends MovieReviewCountArgs>(
      args?: Subset<T, MovieReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieReviewAggregateArgs>(args: Subset<T, MovieReviewAggregateArgs>): Prisma.PrismaPromise<GetMovieReviewAggregateType<T>>

    /**
     * Group by MovieReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieReviewGroupByArgs['orderBy'] }
        : { orderBy?: MovieReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieReview model
   */
  readonly fields: MovieReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieReview model
   */
  interface MovieReviewFieldRefs {
    readonly id: FieldRef<"MovieReview", 'String'>
    readonly movieId: FieldRef<"MovieReview", 'String'>
    readonly title: FieldRef<"MovieReview", 'String'>
    readonly content: FieldRef<"MovieReview", 'String'>
    readonly author: FieldRef<"MovieReview", 'String'>
    readonly rating: FieldRef<"MovieReview", 'Float'>
    readonly reviewType: FieldRef<"MovieReview", 'ReviewType'>
    readonly language: FieldRef<"MovieReview", 'String'>
    readonly isPublished: FieldRef<"MovieReview", 'Boolean'>
    readonly publishedAt: FieldRef<"MovieReview", 'DateTime'>
    readonly createdAt: FieldRef<"MovieReview", 'DateTime'>
    readonly updatedAt: FieldRef<"MovieReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MovieReview findUnique
   */
  export type MovieReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieReview
     */
    select?: MovieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieReview
     */
    omit?: MovieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieReviewInclude<ExtArgs> | null
    /**
     * Filter, which MovieReview to fetch.
     */
    where: MovieReviewWhereUniqueInput
  }

  /**
   * MovieReview findUniqueOrThrow
   */
  export type MovieReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieReview
     */
    select?: MovieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieReview
     */
    omit?: MovieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieReviewInclude<ExtArgs> | null
    /**
     * Filter, which MovieReview to fetch.
     */
    where: MovieReviewWhereUniqueInput
  }

  /**
   * MovieReview findFirst
   */
  export type MovieReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieReview
     */
    select?: MovieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieReview
     */
    omit?: MovieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieReviewInclude<ExtArgs> | null
    /**
     * Filter, which MovieReview to fetch.
     */
    where?: MovieReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieReviews to fetch.
     */
    orderBy?: MovieReviewOrderByWithRelationInput | MovieReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieReviews.
     */
    cursor?: MovieReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieReviews.
     */
    distinct?: MovieReviewScalarFieldEnum | MovieReviewScalarFieldEnum[]
  }

  /**
   * MovieReview findFirstOrThrow
   */
  export type MovieReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieReview
     */
    select?: MovieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieReview
     */
    omit?: MovieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieReviewInclude<ExtArgs> | null
    /**
     * Filter, which MovieReview to fetch.
     */
    where?: MovieReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieReviews to fetch.
     */
    orderBy?: MovieReviewOrderByWithRelationInput | MovieReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieReviews.
     */
    cursor?: MovieReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieReviews.
     */
    distinct?: MovieReviewScalarFieldEnum | MovieReviewScalarFieldEnum[]
  }

  /**
   * MovieReview findMany
   */
  export type MovieReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieReview
     */
    select?: MovieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieReview
     */
    omit?: MovieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieReviewInclude<ExtArgs> | null
    /**
     * Filter, which MovieReviews to fetch.
     */
    where?: MovieReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieReviews to fetch.
     */
    orderBy?: MovieReviewOrderByWithRelationInput | MovieReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieReviews.
     */
    cursor?: MovieReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieReviews.
     */
    skip?: number
    distinct?: MovieReviewScalarFieldEnum | MovieReviewScalarFieldEnum[]
  }

  /**
   * MovieReview create
   */
  export type MovieReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieReview
     */
    select?: MovieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieReview
     */
    omit?: MovieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieReview.
     */
    data: XOR<MovieReviewCreateInput, MovieReviewUncheckedCreateInput>
  }

  /**
   * MovieReview createMany
   */
  export type MovieReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieReviews.
     */
    data: MovieReviewCreateManyInput | MovieReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovieReview createManyAndReturn
   */
  export type MovieReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieReview
     */
    select?: MovieReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MovieReview
     */
    omit?: MovieReviewOmit<ExtArgs> | null
    /**
     * The data used to create many MovieReviews.
     */
    data: MovieReviewCreateManyInput | MovieReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieReview update
   */
  export type MovieReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieReview
     */
    select?: MovieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieReview
     */
    omit?: MovieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieReview.
     */
    data: XOR<MovieReviewUpdateInput, MovieReviewUncheckedUpdateInput>
    /**
     * Choose, which MovieReview to update.
     */
    where: MovieReviewWhereUniqueInput
  }

  /**
   * MovieReview updateMany
   */
  export type MovieReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieReviews.
     */
    data: XOR<MovieReviewUpdateManyMutationInput, MovieReviewUncheckedUpdateManyInput>
    /**
     * Filter which MovieReviews to update
     */
    where?: MovieReviewWhereInput
    /**
     * Limit how many MovieReviews to update.
     */
    limit?: number
  }

  /**
   * MovieReview updateManyAndReturn
   */
  export type MovieReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieReview
     */
    select?: MovieReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MovieReview
     */
    omit?: MovieReviewOmit<ExtArgs> | null
    /**
     * The data used to update MovieReviews.
     */
    data: XOR<MovieReviewUpdateManyMutationInput, MovieReviewUncheckedUpdateManyInput>
    /**
     * Filter which MovieReviews to update
     */
    where?: MovieReviewWhereInput
    /**
     * Limit how many MovieReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieReview upsert
   */
  export type MovieReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieReview
     */
    select?: MovieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieReview
     */
    omit?: MovieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieReview to update in case it exists.
     */
    where: MovieReviewWhereUniqueInput
    /**
     * In case the MovieReview found by the `where` argument doesn't exist, create a new MovieReview with this data.
     */
    create: XOR<MovieReviewCreateInput, MovieReviewUncheckedCreateInput>
    /**
     * In case the MovieReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieReviewUpdateInput, MovieReviewUncheckedUpdateInput>
  }

  /**
   * MovieReview delete
   */
  export type MovieReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieReview
     */
    select?: MovieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieReview
     */
    omit?: MovieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieReviewInclude<ExtArgs> | null
    /**
     * Filter which MovieReview to delete.
     */
    where: MovieReviewWhereUniqueInput
  }

  /**
   * MovieReview deleteMany
   */
  export type MovieReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieReviews to delete
     */
    where?: MovieReviewWhereInput
    /**
     * Limit how many MovieReviews to delete.
     */
    limit?: number
  }

  /**
   * MovieReview without action
   */
  export type MovieReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieReview
     */
    select?: MovieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieReview
     */
    omit?: MovieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieReviewInclude<ExtArgs> | null
  }


  /**
   * Model WatchGuide
   */

  export type AggregateWatchGuide = {
    _count: WatchGuideCountAggregateOutputType | null
    _avg: WatchGuideAvgAggregateOutputType | null
    _sum: WatchGuideSumAggregateOutputType | null
    _min: WatchGuideMinAggregateOutputType | null
    _max: WatchGuideMaxAggregateOutputType | null
  }

  export type WatchGuideAvgAggregateOutputType = {
    order: number | null
  }

  export type WatchGuideSumAggregateOutputType = {
    order: number | null
  }

  export type WatchGuideMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    guideType: $Enums.GuideType | null
    order: number | null
    isPublished: boolean | null
    language: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WatchGuideMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    guideType: $Enums.GuideType | null
    order: number | null
    isPublished: boolean | null
    language: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WatchGuideCountAggregateOutputType = {
    id: number
    title: number
    description: number
    guideType: number
    content: number
    order: number
    isPublished: number
    language: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WatchGuideAvgAggregateInputType = {
    order?: true
  }

  export type WatchGuideSumAggregateInputType = {
    order?: true
  }

  export type WatchGuideMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    guideType?: true
    order?: true
    isPublished?: true
    language?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WatchGuideMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    guideType?: true
    order?: true
    isPublished?: true
    language?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WatchGuideCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    guideType?: true
    content?: true
    order?: true
    isPublished?: true
    language?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WatchGuideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchGuide to aggregate.
     */
    where?: WatchGuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchGuides to fetch.
     */
    orderBy?: WatchGuideOrderByWithRelationInput | WatchGuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchGuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchGuides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchGuides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchGuides
    **/
    _count?: true | WatchGuideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchGuideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchGuideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchGuideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchGuideMaxAggregateInputType
  }

  export type GetWatchGuideAggregateType<T extends WatchGuideAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchGuide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchGuide[P]>
      : GetScalarType<T[P], AggregateWatchGuide[P]>
  }




  export type WatchGuideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchGuideWhereInput
    orderBy?: WatchGuideOrderByWithAggregationInput | WatchGuideOrderByWithAggregationInput[]
    by: WatchGuideScalarFieldEnum[] | WatchGuideScalarFieldEnum
    having?: WatchGuideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchGuideCountAggregateInputType | true
    _avg?: WatchGuideAvgAggregateInputType
    _sum?: WatchGuideSumAggregateInputType
    _min?: WatchGuideMinAggregateInputType
    _max?: WatchGuideMaxAggregateInputType
  }

  export type WatchGuideGroupByOutputType = {
    id: string
    title: string
    description: string
    guideType: $Enums.GuideType
    content: JsonValue
    order: number
    isPublished: boolean
    language: string
    createdAt: Date
    updatedAt: Date
    _count: WatchGuideCountAggregateOutputType | null
    _avg: WatchGuideAvgAggregateOutputType | null
    _sum: WatchGuideSumAggregateOutputType | null
    _min: WatchGuideMinAggregateOutputType | null
    _max: WatchGuideMaxAggregateOutputType | null
  }

  type GetWatchGuideGroupByPayload<T extends WatchGuideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WatchGuideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchGuideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchGuideGroupByOutputType[P]>
            : GetScalarType<T[P], WatchGuideGroupByOutputType[P]>
        }
      >
    >


  export type WatchGuideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    guideType?: boolean
    content?: boolean
    order?: boolean
    isPublished?: boolean
    language?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movies?: boolean | WatchGuide$moviesArgs<ExtArgs>
    _count?: boolean | WatchGuideCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchGuide"]>

  export type WatchGuideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    guideType?: boolean
    content?: boolean
    order?: boolean
    isPublished?: boolean
    language?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["watchGuide"]>

  export type WatchGuideSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    guideType?: boolean
    content?: boolean
    order?: boolean
    isPublished?: boolean
    language?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["watchGuide"]>

  export type WatchGuideSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    guideType?: boolean
    content?: boolean
    order?: boolean
    isPublished?: boolean
    language?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WatchGuideOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "guideType" | "content" | "order" | "isPublished" | "language" | "createdAt" | "updatedAt", ExtArgs["result"]["watchGuide"]>
  export type WatchGuideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movies?: boolean | WatchGuide$moviesArgs<ExtArgs>
    _count?: boolean | WatchGuideCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WatchGuideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WatchGuideIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WatchGuidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WatchGuide"
    objects: {
      movies: Prisma.$WatchGuideMoviePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      guideType: $Enums.GuideType
      content: Prisma.JsonValue
      order: number
      isPublished: boolean
      language: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["watchGuide"]>
    composites: {}
  }

  type WatchGuideGetPayload<S extends boolean | null | undefined | WatchGuideDefaultArgs> = $Result.GetResult<Prisma.$WatchGuidePayload, S>

  type WatchGuideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WatchGuideFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WatchGuideCountAggregateInputType | true
    }

  export interface WatchGuideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchGuide'], meta: { name: 'WatchGuide' } }
    /**
     * Find zero or one WatchGuide that matches the filter.
     * @param {WatchGuideFindUniqueArgs} args - Arguments to find a WatchGuide
     * @example
     * // Get one WatchGuide
     * const watchGuide = await prisma.watchGuide.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WatchGuideFindUniqueArgs>(args: SelectSubset<T, WatchGuideFindUniqueArgs<ExtArgs>>): Prisma__WatchGuideClient<$Result.GetResult<Prisma.$WatchGuidePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WatchGuide that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WatchGuideFindUniqueOrThrowArgs} args - Arguments to find a WatchGuide
     * @example
     * // Get one WatchGuide
     * const watchGuide = await prisma.watchGuide.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WatchGuideFindUniqueOrThrowArgs>(args: SelectSubset<T, WatchGuideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WatchGuideClient<$Result.GetResult<Prisma.$WatchGuidePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WatchGuide that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideFindFirstArgs} args - Arguments to find a WatchGuide
     * @example
     * // Get one WatchGuide
     * const watchGuide = await prisma.watchGuide.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WatchGuideFindFirstArgs>(args?: SelectSubset<T, WatchGuideFindFirstArgs<ExtArgs>>): Prisma__WatchGuideClient<$Result.GetResult<Prisma.$WatchGuidePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WatchGuide that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideFindFirstOrThrowArgs} args - Arguments to find a WatchGuide
     * @example
     * // Get one WatchGuide
     * const watchGuide = await prisma.watchGuide.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WatchGuideFindFirstOrThrowArgs>(args?: SelectSubset<T, WatchGuideFindFirstOrThrowArgs<ExtArgs>>): Prisma__WatchGuideClient<$Result.GetResult<Prisma.$WatchGuidePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WatchGuides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchGuides
     * const watchGuides = await prisma.watchGuide.findMany()
     * 
     * // Get first 10 WatchGuides
     * const watchGuides = await prisma.watchGuide.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchGuideWithIdOnly = await prisma.watchGuide.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WatchGuideFindManyArgs>(args?: SelectSubset<T, WatchGuideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchGuidePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WatchGuide.
     * @param {WatchGuideCreateArgs} args - Arguments to create a WatchGuide.
     * @example
     * // Create one WatchGuide
     * const WatchGuide = await prisma.watchGuide.create({
     *   data: {
     *     // ... data to create a WatchGuide
     *   }
     * })
     * 
     */
    create<T extends WatchGuideCreateArgs>(args: SelectSubset<T, WatchGuideCreateArgs<ExtArgs>>): Prisma__WatchGuideClient<$Result.GetResult<Prisma.$WatchGuidePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WatchGuides.
     * @param {WatchGuideCreateManyArgs} args - Arguments to create many WatchGuides.
     * @example
     * // Create many WatchGuides
     * const watchGuide = await prisma.watchGuide.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WatchGuideCreateManyArgs>(args?: SelectSubset<T, WatchGuideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WatchGuides and returns the data saved in the database.
     * @param {WatchGuideCreateManyAndReturnArgs} args - Arguments to create many WatchGuides.
     * @example
     * // Create many WatchGuides
     * const watchGuide = await prisma.watchGuide.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WatchGuides and only return the `id`
     * const watchGuideWithIdOnly = await prisma.watchGuide.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WatchGuideCreateManyAndReturnArgs>(args?: SelectSubset<T, WatchGuideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchGuidePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WatchGuide.
     * @param {WatchGuideDeleteArgs} args - Arguments to delete one WatchGuide.
     * @example
     * // Delete one WatchGuide
     * const WatchGuide = await prisma.watchGuide.delete({
     *   where: {
     *     // ... filter to delete one WatchGuide
     *   }
     * })
     * 
     */
    delete<T extends WatchGuideDeleteArgs>(args: SelectSubset<T, WatchGuideDeleteArgs<ExtArgs>>): Prisma__WatchGuideClient<$Result.GetResult<Prisma.$WatchGuidePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WatchGuide.
     * @param {WatchGuideUpdateArgs} args - Arguments to update one WatchGuide.
     * @example
     * // Update one WatchGuide
     * const watchGuide = await prisma.watchGuide.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WatchGuideUpdateArgs>(args: SelectSubset<T, WatchGuideUpdateArgs<ExtArgs>>): Prisma__WatchGuideClient<$Result.GetResult<Prisma.$WatchGuidePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WatchGuides.
     * @param {WatchGuideDeleteManyArgs} args - Arguments to filter WatchGuides to delete.
     * @example
     * // Delete a few WatchGuides
     * const { count } = await prisma.watchGuide.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WatchGuideDeleteManyArgs>(args?: SelectSubset<T, WatchGuideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchGuides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchGuides
     * const watchGuide = await prisma.watchGuide.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WatchGuideUpdateManyArgs>(args: SelectSubset<T, WatchGuideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchGuides and returns the data updated in the database.
     * @param {WatchGuideUpdateManyAndReturnArgs} args - Arguments to update many WatchGuides.
     * @example
     * // Update many WatchGuides
     * const watchGuide = await prisma.watchGuide.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WatchGuides and only return the `id`
     * const watchGuideWithIdOnly = await prisma.watchGuide.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WatchGuideUpdateManyAndReturnArgs>(args: SelectSubset<T, WatchGuideUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchGuidePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WatchGuide.
     * @param {WatchGuideUpsertArgs} args - Arguments to update or create a WatchGuide.
     * @example
     * // Update or create a WatchGuide
     * const watchGuide = await prisma.watchGuide.upsert({
     *   create: {
     *     // ... data to create a WatchGuide
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchGuide we want to update
     *   }
     * })
     */
    upsert<T extends WatchGuideUpsertArgs>(args: SelectSubset<T, WatchGuideUpsertArgs<ExtArgs>>): Prisma__WatchGuideClient<$Result.GetResult<Prisma.$WatchGuidePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WatchGuides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideCountArgs} args - Arguments to filter WatchGuides to count.
     * @example
     * // Count the number of WatchGuides
     * const count = await prisma.watchGuide.count({
     *   where: {
     *     // ... the filter for the WatchGuides we want to count
     *   }
     * })
    **/
    count<T extends WatchGuideCountArgs>(
      args?: Subset<T, WatchGuideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchGuideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchGuide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchGuideAggregateArgs>(args: Subset<T, WatchGuideAggregateArgs>): Prisma.PrismaPromise<GetWatchGuideAggregateType<T>>

    /**
     * Group by WatchGuide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchGuideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchGuideGroupByArgs['orderBy'] }
        : { orderBy?: WatchGuideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchGuideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchGuideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WatchGuide model
   */
  readonly fields: WatchGuideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchGuide.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WatchGuideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movies<T extends WatchGuide$moviesArgs<ExtArgs> = {}>(args?: Subset<T, WatchGuide$moviesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchGuideMoviePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WatchGuide model
   */
  interface WatchGuideFieldRefs {
    readonly id: FieldRef<"WatchGuide", 'String'>
    readonly title: FieldRef<"WatchGuide", 'String'>
    readonly description: FieldRef<"WatchGuide", 'String'>
    readonly guideType: FieldRef<"WatchGuide", 'GuideType'>
    readonly content: FieldRef<"WatchGuide", 'Json'>
    readonly order: FieldRef<"WatchGuide", 'Int'>
    readonly isPublished: FieldRef<"WatchGuide", 'Boolean'>
    readonly language: FieldRef<"WatchGuide", 'String'>
    readonly createdAt: FieldRef<"WatchGuide", 'DateTime'>
    readonly updatedAt: FieldRef<"WatchGuide", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WatchGuide findUnique
   */
  export type WatchGuideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuide
     */
    select?: WatchGuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuide
     */
    omit?: WatchGuideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideInclude<ExtArgs> | null
    /**
     * Filter, which WatchGuide to fetch.
     */
    where: WatchGuideWhereUniqueInput
  }

  /**
   * WatchGuide findUniqueOrThrow
   */
  export type WatchGuideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuide
     */
    select?: WatchGuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuide
     */
    omit?: WatchGuideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideInclude<ExtArgs> | null
    /**
     * Filter, which WatchGuide to fetch.
     */
    where: WatchGuideWhereUniqueInput
  }

  /**
   * WatchGuide findFirst
   */
  export type WatchGuideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuide
     */
    select?: WatchGuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuide
     */
    omit?: WatchGuideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideInclude<ExtArgs> | null
    /**
     * Filter, which WatchGuide to fetch.
     */
    where?: WatchGuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchGuides to fetch.
     */
    orderBy?: WatchGuideOrderByWithRelationInput | WatchGuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchGuides.
     */
    cursor?: WatchGuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchGuides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchGuides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchGuides.
     */
    distinct?: WatchGuideScalarFieldEnum | WatchGuideScalarFieldEnum[]
  }

  /**
   * WatchGuide findFirstOrThrow
   */
  export type WatchGuideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuide
     */
    select?: WatchGuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuide
     */
    omit?: WatchGuideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideInclude<ExtArgs> | null
    /**
     * Filter, which WatchGuide to fetch.
     */
    where?: WatchGuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchGuides to fetch.
     */
    orderBy?: WatchGuideOrderByWithRelationInput | WatchGuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchGuides.
     */
    cursor?: WatchGuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchGuides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchGuides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchGuides.
     */
    distinct?: WatchGuideScalarFieldEnum | WatchGuideScalarFieldEnum[]
  }

  /**
   * WatchGuide findMany
   */
  export type WatchGuideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuide
     */
    select?: WatchGuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuide
     */
    omit?: WatchGuideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideInclude<ExtArgs> | null
    /**
     * Filter, which WatchGuides to fetch.
     */
    where?: WatchGuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchGuides to fetch.
     */
    orderBy?: WatchGuideOrderByWithRelationInput | WatchGuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchGuides.
     */
    cursor?: WatchGuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchGuides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchGuides.
     */
    skip?: number
    distinct?: WatchGuideScalarFieldEnum | WatchGuideScalarFieldEnum[]
  }

  /**
   * WatchGuide create
   */
  export type WatchGuideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuide
     */
    select?: WatchGuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuide
     */
    omit?: WatchGuideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchGuide.
     */
    data: XOR<WatchGuideCreateInput, WatchGuideUncheckedCreateInput>
  }

  /**
   * WatchGuide createMany
   */
  export type WatchGuideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchGuides.
     */
    data: WatchGuideCreateManyInput | WatchGuideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WatchGuide createManyAndReturn
   */
  export type WatchGuideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuide
     */
    select?: WatchGuideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuide
     */
    omit?: WatchGuideOmit<ExtArgs> | null
    /**
     * The data used to create many WatchGuides.
     */
    data: WatchGuideCreateManyInput | WatchGuideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WatchGuide update
   */
  export type WatchGuideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuide
     */
    select?: WatchGuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuide
     */
    omit?: WatchGuideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchGuide.
     */
    data: XOR<WatchGuideUpdateInput, WatchGuideUncheckedUpdateInput>
    /**
     * Choose, which WatchGuide to update.
     */
    where: WatchGuideWhereUniqueInput
  }

  /**
   * WatchGuide updateMany
   */
  export type WatchGuideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchGuides.
     */
    data: XOR<WatchGuideUpdateManyMutationInput, WatchGuideUncheckedUpdateManyInput>
    /**
     * Filter which WatchGuides to update
     */
    where?: WatchGuideWhereInput
    /**
     * Limit how many WatchGuides to update.
     */
    limit?: number
  }

  /**
   * WatchGuide updateManyAndReturn
   */
  export type WatchGuideUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuide
     */
    select?: WatchGuideSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuide
     */
    omit?: WatchGuideOmit<ExtArgs> | null
    /**
     * The data used to update WatchGuides.
     */
    data: XOR<WatchGuideUpdateManyMutationInput, WatchGuideUncheckedUpdateManyInput>
    /**
     * Filter which WatchGuides to update
     */
    where?: WatchGuideWhereInput
    /**
     * Limit how many WatchGuides to update.
     */
    limit?: number
  }

  /**
   * WatchGuide upsert
   */
  export type WatchGuideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuide
     */
    select?: WatchGuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuide
     */
    omit?: WatchGuideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchGuide to update in case it exists.
     */
    where: WatchGuideWhereUniqueInput
    /**
     * In case the WatchGuide found by the `where` argument doesn't exist, create a new WatchGuide with this data.
     */
    create: XOR<WatchGuideCreateInput, WatchGuideUncheckedCreateInput>
    /**
     * In case the WatchGuide was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchGuideUpdateInput, WatchGuideUncheckedUpdateInput>
  }

  /**
   * WatchGuide delete
   */
  export type WatchGuideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuide
     */
    select?: WatchGuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuide
     */
    omit?: WatchGuideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideInclude<ExtArgs> | null
    /**
     * Filter which WatchGuide to delete.
     */
    where: WatchGuideWhereUniqueInput
  }

  /**
   * WatchGuide deleteMany
   */
  export type WatchGuideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchGuides to delete
     */
    where?: WatchGuideWhereInput
    /**
     * Limit how many WatchGuides to delete.
     */
    limit?: number
  }

  /**
   * WatchGuide.movies
   */
  export type WatchGuide$moviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieInclude<ExtArgs> | null
    where?: WatchGuideMovieWhereInput
    orderBy?: WatchGuideMovieOrderByWithRelationInput | WatchGuideMovieOrderByWithRelationInput[]
    cursor?: WatchGuideMovieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchGuideMovieScalarFieldEnum | WatchGuideMovieScalarFieldEnum[]
  }

  /**
   * WatchGuide without action
   */
  export type WatchGuideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuide
     */
    select?: WatchGuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuide
     */
    omit?: WatchGuideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideInclude<ExtArgs> | null
  }


  /**
   * Model WatchGuideMovie
   */

  export type AggregateWatchGuideMovie = {
    _count: WatchGuideMovieCountAggregateOutputType | null
    _avg: WatchGuideMovieAvgAggregateOutputType | null
    _sum: WatchGuideMovieSumAggregateOutputType | null
    _min: WatchGuideMovieMinAggregateOutputType | null
    _max: WatchGuideMovieMaxAggregateOutputType | null
  }

  export type WatchGuideMovieAvgAggregateOutputType = {
    order: number | null
  }

  export type WatchGuideMovieSumAggregateOutputType = {
    order: number | null
  }

  export type WatchGuideMovieMinAggregateOutputType = {
    id: string | null
    guideId: string | null
    movieId: string | null
    order: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type WatchGuideMovieMaxAggregateOutputType = {
    id: string | null
    guideId: string | null
    movieId: string | null
    order: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type WatchGuideMovieCountAggregateOutputType = {
    id: number
    guideId: number
    movieId: number
    order: number
    notes: number
    createdAt: number
    _all: number
  }


  export type WatchGuideMovieAvgAggregateInputType = {
    order?: true
  }

  export type WatchGuideMovieSumAggregateInputType = {
    order?: true
  }

  export type WatchGuideMovieMinAggregateInputType = {
    id?: true
    guideId?: true
    movieId?: true
    order?: true
    notes?: true
    createdAt?: true
  }

  export type WatchGuideMovieMaxAggregateInputType = {
    id?: true
    guideId?: true
    movieId?: true
    order?: true
    notes?: true
    createdAt?: true
  }

  export type WatchGuideMovieCountAggregateInputType = {
    id?: true
    guideId?: true
    movieId?: true
    order?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type WatchGuideMovieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchGuideMovie to aggregate.
     */
    where?: WatchGuideMovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchGuideMovies to fetch.
     */
    orderBy?: WatchGuideMovieOrderByWithRelationInput | WatchGuideMovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchGuideMovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchGuideMovies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchGuideMovies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchGuideMovies
    **/
    _count?: true | WatchGuideMovieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchGuideMovieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchGuideMovieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchGuideMovieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchGuideMovieMaxAggregateInputType
  }

  export type GetWatchGuideMovieAggregateType<T extends WatchGuideMovieAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchGuideMovie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchGuideMovie[P]>
      : GetScalarType<T[P], AggregateWatchGuideMovie[P]>
  }




  export type WatchGuideMovieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchGuideMovieWhereInput
    orderBy?: WatchGuideMovieOrderByWithAggregationInput | WatchGuideMovieOrderByWithAggregationInput[]
    by: WatchGuideMovieScalarFieldEnum[] | WatchGuideMovieScalarFieldEnum
    having?: WatchGuideMovieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchGuideMovieCountAggregateInputType | true
    _avg?: WatchGuideMovieAvgAggregateInputType
    _sum?: WatchGuideMovieSumAggregateInputType
    _min?: WatchGuideMovieMinAggregateInputType
    _max?: WatchGuideMovieMaxAggregateInputType
  }

  export type WatchGuideMovieGroupByOutputType = {
    id: string
    guideId: string
    movieId: string
    order: number
    notes: string | null
    createdAt: Date
    _count: WatchGuideMovieCountAggregateOutputType | null
    _avg: WatchGuideMovieAvgAggregateOutputType | null
    _sum: WatchGuideMovieSumAggregateOutputType | null
    _min: WatchGuideMovieMinAggregateOutputType | null
    _max: WatchGuideMovieMaxAggregateOutputType | null
  }

  type GetWatchGuideMovieGroupByPayload<T extends WatchGuideMovieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WatchGuideMovieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchGuideMovieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchGuideMovieGroupByOutputType[P]>
            : GetScalarType<T[P], WatchGuideMovieGroupByOutputType[P]>
        }
      >
    >


  export type WatchGuideMovieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guideId?: boolean
    movieId?: boolean
    order?: boolean
    notes?: boolean
    createdAt?: boolean
    guide?: boolean | WatchGuideDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchGuideMovie"]>

  export type WatchGuideMovieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guideId?: boolean
    movieId?: boolean
    order?: boolean
    notes?: boolean
    createdAt?: boolean
    guide?: boolean | WatchGuideDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchGuideMovie"]>

  export type WatchGuideMovieSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guideId?: boolean
    movieId?: boolean
    order?: boolean
    notes?: boolean
    createdAt?: boolean
    guide?: boolean | WatchGuideDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchGuideMovie"]>

  export type WatchGuideMovieSelectScalar = {
    id?: boolean
    guideId?: boolean
    movieId?: boolean
    order?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type WatchGuideMovieOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "guideId" | "movieId" | "order" | "notes" | "createdAt", ExtArgs["result"]["watchGuideMovie"]>
  export type WatchGuideMovieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guide?: boolean | WatchGuideDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }
  export type WatchGuideMovieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guide?: boolean | WatchGuideDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }
  export type WatchGuideMovieIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guide?: boolean | WatchGuideDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }

  export type $WatchGuideMoviePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WatchGuideMovie"
    objects: {
      guide: Prisma.$WatchGuidePayload<ExtArgs>
      movie: Prisma.$MoviePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      guideId: string
      movieId: string
      order: number
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["watchGuideMovie"]>
    composites: {}
  }

  type WatchGuideMovieGetPayload<S extends boolean | null | undefined | WatchGuideMovieDefaultArgs> = $Result.GetResult<Prisma.$WatchGuideMoviePayload, S>

  type WatchGuideMovieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WatchGuideMovieFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WatchGuideMovieCountAggregateInputType | true
    }

  export interface WatchGuideMovieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchGuideMovie'], meta: { name: 'WatchGuideMovie' } }
    /**
     * Find zero or one WatchGuideMovie that matches the filter.
     * @param {WatchGuideMovieFindUniqueArgs} args - Arguments to find a WatchGuideMovie
     * @example
     * // Get one WatchGuideMovie
     * const watchGuideMovie = await prisma.watchGuideMovie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WatchGuideMovieFindUniqueArgs>(args: SelectSubset<T, WatchGuideMovieFindUniqueArgs<ExtArgs>>): Prisma__WatchGuideMovieClient<$Result.GetResult<Prisma.$WatchGuideMoviePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WatchGuideMovie that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WatchGuideMovieFindUniqueOrThrowArgs} args - Arguments to find a WatchGuideMovie
     * @example
     * // Get one WatchGuideMovie
     * const watchGuideMovie = await prisma.watchGuideMovie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WatchGuideMovieFindUniqueOrThrowArgs>(args: SelectSubset<T, WatchGuideMovieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WatchGuideMovieClient<$Result.GetResult<Prisma.$WatchGuideMoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WatchGuideMovie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideMovieFindFirstArgs} args - Arguments to find a WatchGuideMovie
     * @example
     * // Get one WatchGuideMovie
     * const watchGuideMovie = await prisma.watchGuideMovie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WatchGuideMovieFindFirstArgs>(args?: SelectSubset<T, WatchGuideMovieFindFirstArgs<ExtArgs>>): Prisma__WatchGuideMovieClient<$Result.GetResult<Prisma.$WatchGuideMoviePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WatchGuideMovie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideMovieFindFirstOrThrowArgs} args - Arguments to find a WatchGuideMovie
     * @example
     * // Get one WatchGuideMovie
     * const watchGuideMovie = await prisma.watchGuideMovie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WatchGuideMovieFindFirstOrThrowArgs>(args?: SelectSubset<T, WatchGuideMovieFindFirstOrThrowArgs<ExtArgs>>): Prisma__WatchGuideMovieClient<$Result.GetResult<Prisma.$WatchGuideMoviePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WatchGuideMovies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideMovieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchGuideMovies
     * const watchGuideMovies = await prisma.watchGuideMovie.findMany()
     * 
     * // Get first 10 WatchGuideMovies
     * const watchGuideMovies = await prisma.watchGuideMovie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchGuideMovieWithIdOnly = await prisma.watchGuideMovie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WatchGuideMovieFindManyArgs>(args?: SelectSubset<T, WatchGuideMovieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchGuideMoviePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WatchGuideMovie.
     * @param {WatchGuideMovieCreateArgs} args - Arguments to create a WatchGuideMovie.
     * @example
     * // Create one WatchGuideMovie
     * const WatchGuideMovie = await prisma.watchGuideMovie.create({
     *   data: {
     *     // ... data to create a WatchGuideMovie
     *   }
     * })
     * 
     */
    create<T extends WatchGuideMovieCreateArgs>(args: SelectSubset<T, WatchGuideMovieCreateArgs<ExtArgs>>): Prisma__WatchGuideMovieClient<$Result.GetResult<Prisma.$WatchGuideMoviePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WatchGuideMovies.
     * @param {WatchGuideMovieCreateManyArgs} args - Arguments to create many WatchGuideMovies.
     * @example
     * // Create many WatchGuideMovies
     * const watchGuideMovie = await prisma.watchGuideMovie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WatchGuideMovieCreateManyArgs>(args?: SelectSubset<T, WatchGuideMovieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WatchGuideMovies and returns the data saved in the database.
     * @param {WatchGuideMovieCreateManyAndReturnArgs} args - Arguments to create many WatchGuideMovies.
     * @example
     * // Create many WatchGuideMovies
     * const watchGuideMovie = await prisma.watchGuideMovie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WatchGuideMovies and only return the `id`
     * const watchGuideMovieWithIdOnly = await prisma.watchGuideMovie.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WatchGuideMovieCreateManyAndReturnArgs>(args?: SelectSubset<T, WatchGuideMovieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchGuideMoviePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WatchGuideMovie.
     * @param {WatchGuideMovieDeleteArgs} args - Arguments to delete one WatchGuideMovie.
     * @example
     * // Delete one WatchGuideMovie
     * const WatchGuideMovie = await prisma.watchGuideMovie.delete({
     *   where: {
     *     // ... filter to delete one WatchGuideMovie
     *   }
     * })
     * 
     */
    delete<T extends WatchGuideMovieDeleteArgs>(args: SelectSubset<T, WatchGuideMovieDeleteArgs<ExtArgs>>): Prisma__WatchGuideMovieClient<$Result.GetResult<Prisma.$WatchGuideMoviePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WatchGuideMovie.
     * @param {WatchGuideMovieUpdateArgs} args - Arguments to update one WatchGuideMovie.
     * @example
     * // Update one WatchGuideMovie
     * const watchGuideMovie = await prisma.watchGuideMovie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WatchGuideMovieUpdateArgs>(args: SelectSubset<T, WatchGuideMovieUpdateArgs<ExtArgs>>): Prisma__WatchGuideMovieClient<$Result.GetResult<Prisma.$WatchGuideMoviePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WatchGuideMovies.
     * @param {WatchGuideMovieDeleteManyArgs} args - Arguments to filter WatchGuideMovies to delete.
     * @example
     * // Delete a few WatchGuideMovies
     * const { count } = await prisma.watchGuideMovie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WatchGuideMovieDeleteManyArgs>(args?: SelectSubset<T, WatchGuideMovieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchGuideMovies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideMovieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchGuideMovies
     * const watchGuideMovie = await prisma.watchGuideMovie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WatchGuideMovieUpdateManyArgs>(args: SelectSubset<T, WatchGuideMovieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchGuideMovies and returns the data updated in the database.
     * @param {WatchGuideMovieUpdateManyAndReturnArgs} args - Arguments to update many WatchGuideMovies.
     * @example
     * // Update many WatchGuideMovies
     * const watchGuideMovie = await prisma.watchGuideMovie.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WatchGuideMovies and only return the `id`
     * const watchGuideMovieWithIdOnly = await prisma.watchGuideMovie.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WatchGuideMovieUpdateManyAndReturnArgs>(args: SelectSubset<T, WatchGuideMovieUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchGuideMoviePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WatchGuideMovie.
     * @param {WatchGuideMovieUpsertArgs} args - Arguments to update or create a WatchGuideMovie.
     * @example
     * // Update or create a WatchGuideMovie
     * const watchGuideMovie = await prisma.watchGuideMovie.upsert({
     *   create: {
     *     // ... data to create a WatchGuideMovie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchGuideMovie we want to update
     *   }
     * })
     */
    upsert<T extends WatchGuideMovieUpsertArgs>(args: SelectSubset<T, WatchGuideMovieUpsertArgs<ExtArgs>>): Prisma__WatchGuideMovieClient<$Result.GetResult<Prisma.$WatchGuideMoviePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WatchGuideMovies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideMovieCountArgs} args - Arguments to filter WatchGuideMovies to count.
     * @example
     * // Count the number of WatchGuideMovies
     * const count = await prisma.watchGuideMovie.count({
     *   where: {
     *     // ... the filter for the WatchGuideMovies we want to count
     *   }
     * })
    **/
    count<T extends WatchGuideMovieCountArgs>(
      args?: Subset<T, WatchGuideMovieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchGuideMovieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchGuideMovie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideMovieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchGuideMovieAggregateArgs>(args: Subset<T, WatchGuideMovieAggregateArgs>): Prisma.PrismaPromise<GetWatchGuideMovieAggregateType<T>>

    /**
     * Group by WatchGuideMovie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchGuideMovieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchGuideMovieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchGuideMovieGroupByArgs['orderBy'] }
        : { orderBy?: WatchGuideMovieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchGuideMovieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchGuideMovieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WatchGuideMovie model
   */
  readonly fields: WatchGuideMovieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchGuideMovie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WatchGuideMovieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guide<T extends WatchGuideDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WatchGuideDefaultArgs<ExtArgs>>): Prisma__WatchGuideClient<$Result.GetResult<Prisma.$WatchGuidePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WatchGuideMovie model
   */
  interface WatchGuideMovieFieldRefs {
    readonly id: FieldRef<"WatchGuideMovie", 'String'>
    readonly guideId: FieldRef<"WatchGuideMovie", 'String'>
    readonly movieId: FieldRef<"WatchGuideMovie", 'String'>
    readonly order: FieldRef<"WatchGuideMovie", 'Int'>
    readonly notes: FieldRef<"WatchGuideMovie", 'String'>
    readonly createdAt: FieldRef<"WatchGuideMovie", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WatchGuideMovie findUnique
   */
  export type WatchGuideMovieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieInclude<ExtArgs> | null
    /**
     * Filter, which WatchGuideMovie to fetch.
     */
    where: WatchGuideMovieWhereUniqueInput
  }

  /**
   * WatchGuideMovie findUniqueOrThrow
   */
  export type WatchGuideMovieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieInclude<ExtArgs> | null
    /**
     * Filter, which WatchGuideMovie to fetch.
     */
    where: WatchGuideMovieWhereUniqueInput
  }

  /**
   * WatchGuideMovie findFirst
   */
  export type WatchGuideMovieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieInclude<ExtArgs> | null
    /**
     * Filter, which WatchGuideMovie to fetch.
     */
    where?: WatchGuideMovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchGuideMovies to fetch.
     */
    orderBy?: WatchGuideMovieOrderByWithRelationInput | WatchGuideMovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchGuideMovies.
     */
    cursor?: WatchGuideMovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchGuideMovies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchGuideMovies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchGuideMovies.
     */
    distinct?: WatchGuideMovieScalarFieldEnum | WatchGuideMovieScalarFieldEnum[]
  }

  /**
   * WatchGuideMovie findFirstOrThrow
   */
  export type WatchGuideMovieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieInclude<ExtArgs> | null
    /**
     * Filter, which WatchGuideMovie to fetch.
     */
    where?: WatchGuideMovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchGuideMovies to fetch.
     */
    orderBy?: WatchGuideMovieOrderByWithRelationInput | WatchGuideMovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchGuideMovies.
     */
    cursor?: WatchGuideMovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchGuideMovies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchGuideMovies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchGuideMovies.
     */
    distinct?: WatchGuideMovieScalarFieldEnum | WatchGuideMovieScalarFieldEnum[]
  }

  /**
   * WatchGuideMovie findMany
   */
  export type WatchGuideMovieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieInclude<ExtArgs> | null
    /**
     * Filter, which WatchGuideMovies to fetch.
     */
    where?: WatchGuideMovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchGuideMovies to fetch.
     */
    orderBy?: WatchGuideMovieOrderByWithRelationInput | WatchGuideMovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchGuideMovies.
     */
    cursor?: WatchGuideMovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchGuideMovies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchGuideMovies.
     */
    skip?: number
    distinct?: WatchGuideMovieScalarFieldEnum | WatchGuideMovieScalarFieldEnum[]
  }

  /**
   * WatchGuideMovie create
   */
  export type WatchGuideMovieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchGuideMovie.
     */
    data: XOR<WatchGuideMovieCreateInput, WatchGuideMovieUncheckedCreateInput>
  }

  /**
   * WatchGuideMovie createMany
   */
  export type WatchGuideMovieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchGuideMovies.
     */
    data: WatchGuideMovieCreateManyInput | WatchGuideMovieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WatchGuideMovie createManyAndReturn
   */
  export type WatchGuideMovieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * The data used to create many WatchGuideMovies.
     */
    data: WatchGuideMovieCreateManyInput | WatchGuideMovieCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchGuideMovie update
   */
  export type WatchGuideMovieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchGuideMovie.
     */
    data: XOR<WatchGuideMovieUpdateInput, WatchGuideMovieUncheckedUpdateInput>
    /**
     * Choose, which WatchGuideMovie to update.
     */
    where: WatchGuideMovieWhereUniqueInput
  }

  /**
   * WatchGuideMovie updateMany
   */
  export type WatchGuideMovieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchGuideMovies.
     */
    data: XOR<WatchGuideMovieUpdateManyMutationInput, WatchGuideMovieUncheckedUpdateManyInput>
    /**
     * Filter which WatchGuideMovies to update
     */
    where?: WatchGuideMovieWhereInput
    /**
     * Limit how many WatchGuideMovies to update.
     */
    limit?: number
  }

  /**
   * WatchGuideMovie updateManyAndReturn
   */
  export type WatchGuideMovieUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * The data used to update WatchGuideMovies.
     */
    data: XOR<WatchGuideMovieUpdateManyMutationInput, WatchGuideMovieUncheckedUpdateManyInput>
    /**
     * Filter which WatchGuideMovies to update
     */
    where?: WatchGuideMovieWhereInput
    /**
     * Limit how many WatchGuideMovies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchGuideMovie upsert
   */
  export type WatchGuideMovieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchGuideMovie to update in case it exists.
     */
    where: WatchGuideMovieWhereUniqueInput
    /**
     * In case the WatchGuideMovie found by the `where` argument doesn't exist, create a new WatchGuideMovie with this data.
     */
    create: XOR<WatchGuideMovieCreateInput, WatchGuideMovieUncheckedCreateInput>
    /**
     * In case the WatchGuideMovie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchGuideMovieUpdateInput, WatchGuideMovieUncheckedUpdateInput>
  }

  /**
   * WatchGuideMovie delete
   */
  export type WatchGuideMovieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieInclude<ExtArgs> | null
    /**
     * Filter which WatchGuideMovie to delete.
     */
    where: WatchGuideMovieWhereUniqueInput
  }

  /**
   * WatchGuideMovie deleteMany
   */
  export type WatchGuideMovieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchGuideMovies to delete
     */
    where?: WatchGuideMovieWhereInput
    /**
     * Limit how many WatchGuideMovies to delete.
     */
    limit?: number
  }

  /**
   * WatchGuideMovie without action
   */
  export type WatchGuideMovieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchGuideMovie
     */
    select?: WatchGuideMovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchGuideMovie
     */
    omit?: WatchGuideMovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchGuideMovieInclude<ExtArgs> | null
  }


  /**
   * Model MediaContent
   */

  export type AggregateMediaContent = {
    _count: MediaContentCountAggregateOutputType | null
    _avg: MediaContentAvgAggregateOutputType | null
    _sum: MediaContentSumAggregateOutputType | null
    _min: MediaContentMinAggregateOutputType | null
    _max: MediaContentMaxAggregateOutputType | null
  }

  export type MediaContentAvgAggregateOutputType = {
    duration: number | null
    fileSize: number | null
  }

  export type MediaContentSumAggregateOutputType = {
    duration: number | null
    fileSize: number | null
  }

  export type MediaContentMinAggregateOutputType = {
    id: string | null
    movieId: string | null
    title: string | null
    description: string | null
    mediaType: $Enums.MediaType | null
    url: string | null
    thumbnailUrl: string | null
    duration: number | null
    fileSize: number | null
    language: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaContentMaxAggregateOutputType = {
    id: string | null
    movieId: string | null
    title: string | null
    description: string | null
    mediaType: $Enums.MediaType | null
    url: string | null
    thumbnailUrl: string | null
    duration: number | null
    fileSize: number | null
    language: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaContentCountAggregateOutputType = {
    id: number
    movieId: number
    title: number
    description: number
    mediaType: number
    url: number
    thumbnailUrl: number
    duration: number
    fileSize: number
    language: number
    isPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaContentAvgAggregateInputType = {
    duration?: true
    fileSize?: true
  }

  export type MediaContentSumAggregateInputType = {
    duration?: true
    fileSize?: true
  }

  export type MediaContentMinAggregateInputType = {
    id?: true
    movieId?: true
    title?: true
    description?: true
    mediaType?: true
    url?: true
    thumbnailUrl?: true
    duration?: true
    fileSize?: true
    language?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaContentMaxAggregateInputType = {
    id?: true
    movieId?: true
    title?: true
    description?: true
    mediaType?: true
    url?: true
    thumbnailUrl?: true
    duration?: true
    fileSize?: true
    language?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaContentCountAggregateInputType = {
    id?: true
    movieId?: true
    title?: true
    description?: true
    mediaType?: true
    url?: true
    thumbnailUrl?: true
    duration?: true
    fileSize?: true
    language?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaContent to aggregate.
     */
    where?: MediaContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaContents to fetch.
     */
    orderBy?: MediaContentOrderByWithRelationInput | MediaContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaContents
    **/
    _count?: true | MediaContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaContentMaxAggregateInputType
  }

  export type GetMediaContentAggregateType<T extends MediaContentAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaContent[P]>
      : GetScalarType<T[P], AggregateMediaContent[P]>
  }




  export type MediaContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaContentWhereInput
    orderBy?: MediaContentOrderByWithAggregationInput | MediaContentOrderByWithAggregationInput[]
    by: MediaContentScalarFieldEnum[] | MediaContentScalarFieldEnum
    having?: MediaContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaContentCountAggregateInputType | true
    _avg?: MediaContentAvgAggregateInputType
    _sum?: MediaContentSumAggregateInputType
    _min?: MediaContentMinAggregateInputType
    _max?: MediaContentMaxAggregateInputType
  }

  export type MediaContentGroupByOutputType = {
    id: string
    movieId: string | null
    title: string
    description: string | null
    mediaType: $Enums.MediaType
    url: string
    thumbnailUrl: string | null
    duration: number | null
    fileSize: number | null
    language: string | null
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: MediaContentCountAggregateOutputType | null
    _avg: MediaContentAvgAggregateOutputType | null
    _sum: MediaContentSumAggregateOutputType | null
    _min: MediaContentMinAggregateOutputType | null
    _max: MediaContentMaxAggregateOutputType | null
  }

  type GetMediaContentGroupByPayload<T extends MediaContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaContentGroupByOutputType[P]>
            : GetScalarType<T[P], MediaContentGroupByOutputType[P]>
        }
      >
    >


  export type MediaContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    title?: boolean
    description?: boolean
    mediaType?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    fileSize?: boolean
    language?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movie?: boolean | MediaContent$movieArgs<ExtArgs>
  }, ExtArgs["result"]["mediaContent"]>

  export type MediaContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    title?: boolean
    description?: boolean
    mediaType?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    fileSize?: boolean
    language?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movie?: boolean | MediaContent$movieArgs<ExtArgs>
  }, ExtArgs["result"]["mediaContent"]>

  export type MediaContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    title?: boolean
    description?: boolean
    mediaType?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    fileSize?: boolean
    language?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movie?: boolean | MediaContent$movieArgs<ExtArgs>
  }, ExtArgs["result"]["mediaContent"]>

  export type MediaContentSelectScalar = {
    id?: boolean
    movieId?: boolean
    title?: boolean
    description?: boolean
    mediaType?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    fileSize?: boolean
    language?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "movieId" | "title" | "description" | "mediaType" | "url" | "thumbnailUrl" | "duration" | "fileSize" | "language" | "isPublished" | "createdAt" | "updatedAt", ExtArgs["result"]["mediaContent"]>
  export type MediaContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MediaContent$movieArgs<ExtArgs>
  }
  export type MediaContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MediaContent$movieArgs<ExtArgs>
  }
  export type MediaContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MediaContent$movieArgs<ExtArgs>
  }

  export type $MediaContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaContent"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      movieId: string | null
      title: string
      description: string | null
      mediaType: $Enums.MediaType
      url: string
      thumbnailUrl: string | null
      duration: number | null
      fileSize: number | null
      language: string | null
      isPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mediaContent"]>
    composites: {}
  }

  type MediaContentGetPayload<S extends boolean | null | undefined | MediaContentDefaultArgs> = $Result.GetResult<Prisma.$MediaContentPayload, S>

  type MediaContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaContentCountAggregateInputType | true
    }

  export interface MediaContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaContent'], meta: { name: 'MediaContent' } }
    /**
     * Find zero or one MediaContent that matches the filter.
     * @param {MediaContentFindUniqueArgs} args - Arguments to find a MediaContent
     * @example
     * // Get one MediaContent
     * const mediaContent = await prisma.mediaContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaContentFindUniqueArgs>(args: SelectSubset<T, MediaContentFindUniqueArgs<ExtArgs>>): Prisma__MediaContentClient<$Result.GetResult<Prisma.$MediaContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MediaContent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaContentFindUniqueOrThrowArgs} args - Arguments to find a MediaContent
     * @example
     * // Get one MediaContent
     * const mediaContent = await prisma.mediaContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaContentFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaContentClient<$Result.GetResult<Prisma.$MediaContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaContentFindFirstArgs} args - Arguments to find a MediaContent
     * @example
     * // Get one MediaContent
     * const mediaContent = await prisma.mediaContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaContentFindFirstArgs>(args?: SelectSubset<T, MediaContentFindFirstArgs<ExtArgs>>): Prisma__MediaContentClient<$Result.GetResult<Prisma.$MediaContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaContentFindFirstOrThrowArgs} args - Arguments to find a MediaContent
     * @example
     * // Get one MediaContent
     * const mediaContent = await prisma.mediaContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaContentFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaContentClient<$Result.GetResult<Prisma.$MediaContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaContents
     * const mediaContents = await prisma.mediaContent.findMany()
     * 
     * // Get first 10 MediaContents
     * const mediaContents = await prisma.mediaContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaContentWithIdOnly = await prisma.mediaContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaContentFindManyArgs>(args?: SelectSubset<T, MediaContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MediaContent.
     * @param {MediaContentCreateArgs} args - Arguments to create a MediaContent.
     * @example
     * // Create one MediaContent
     * const MediaContent = await prisma.mediaContent.create({
     *   data: {
     *     // ... data to create a MediaContent
     *   }
     * })
     * 
     */
    create<T extends MediaContentCreateArgs>(args: SelectSubset<T, MediaContentCreateArgs<ExtArgs>>): Prisma__MediaContentClient<$Result.GetResult<Prisma.$MediaContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MediaContents.
     * @param {MediaContentCreateManyArgs} args - Arguments to create many MediaContents.
     * @example
     * // Create many MediaContents
     * const mediaContent = await prisma.mediaContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaContentCreateManyArgs>(args?: SelectSubset<T, MediaContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaContents and returns the data saved in the database.
     * @param {MediaContentCreateManyAndReturnArgs} args - Arguments to create many MediaContents.
     * @example
     * // Create many MediaContents
     * const mediaContent = await prisma.mediaContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaContents and only return the `id`
     * const mediaContentWithIdOnly = await prisma.mediaContent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaContentCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaContentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MediaContent.
     * @param {MediaContentDeleteArgs} args - Arguments to delete one MediaContent.
     * @example
     * // Delete one MediaContent
     * const MediaContent = await prisma.mediaContent.delete({
     *   where: {
     *     // ... filter to delete one MediaContent
     *   }
     * })
     * 
     */
    delete<T extends MediaContentDeleteArgs>(args: SelectSubset<T, MediaContentDeleteArgs<ExtArgs>>): Prisma__MediaContentClient<$Result.GetResult<Prisma.$MediaContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MediaContent.
     * @param {MediaContentUpdateArgs} args - Arguments to update one MediaContent.
     * @example
     * // Update one MediaContent
     * const mediaContent = await prisma.mediaContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaContentUpdateArgs>(args: SelectSubset<T, MediaContentUpdateArgs<ExtArgs>>): Prisma__MediaContentClient<$Result.GetResult<Prisma.$MediaContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MediaContents.
     * @param {MediaContentDeleteManyArgs} args - Arguments to filter MediaContents to delete.
     * @example
     * // Delete a few MediaContents
     * const { count } = await prisma.mediaContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaContentDeleteManyArgs>(args?: SelectSubset<T, MediaContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaContents
     * const mediaContent = await prisma.mediaContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaContentUpdateManyArgs>(args: SelectSubset<T, MediaContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaContents and returns the data updated in the database.
     * @param {MediaContentUpdateManyAndReturnArgs} args - Arguments to update many MediaContents.
     * @example
     * // Update many MediaContents
     * const mediaContent = await prisma.mediaContent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MediaContents and only return the `id`
     * const mediaContentWithIdOnly = await prisma.mediaContent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaContentUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaContentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MediaContent.
     * @param {MediaContentUpsertArgs} args - Arguments to update or create a MediaContent.
     * @example
     * // Update or create a MediaContent
     * const mediaContent = await prisma.mediaContent.upsert({
     *   create: {
     *     // ... data to create a MediaContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaContent we want to update
     *   }
     * })
     */
    upsert<T extends MediaContentUpsertArgs>(args: SelectSubset<T, MediaContentUpsertArgs<ExtArgs>>): Prisma__MediaContentClient<$Result.GetResult<Prisma.$MediaContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MediaContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaContentCountArgs} args - Arguments to filter MediaContents to count.
     * @example
     * // Count the number of MediaContents
     * const count = await prisma.mediaContent.count({
     *   where: {
     *     // ... the filter for the MediaContents we want to count
     *   }
     * })
    **/
    count<T extends MediaContentCountArgs>(
      args?: Subset<T, MediaContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaContentAggregateArgs>(args: Subset<T, MediaContentAggregateArgs>): Prisma.PrismaPromise<GetMediaContentAggregateType<T>>

    /**
     * Group by MediaContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaContentGroupByArgs['orderBy'] }
        : { orderBy?: MediaContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaContent model
   */
  readonly fields: MediaContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MediaContent$movieArgs<ExtArgs> = {}>(args?: Subset<T, MediaContent$movieArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaContent model
   */
  interface MediaContentFieldRefs {
    readonly id: FieldRef<"MediaContent", 'String'>
    readonly movieId: FieldRef<"MediaContent", 'String'>
    readonly title: FieldRef<"MediaContent", 'String'>
    readonly description: FieldRef<"MediaContent", 'String'>
    readonly mediaType: FieldRef<"MediaContent", 'MediaType'>
    readonly url: FieldRef<"MediaContent", 'String'>
    readonly thumbnailUrl: FieldRef<"MediaContent", 'String'>
    readonly duration: FieldRef<"MediaContent", 'Int'>
    readonly fileSize: FieldRef<"MediaContent", 'Int'>
    readonly language: FieldRef<"MediaContent", 'String'>
    readonly isPublished: FieldRef<"MediaContent", 'Boolean'>
    readonly createdAt: FieldRef<"MediaContent", 'DateTime'>
    readonly updatedAt: FieldRef<"MediaContent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaContent findUnique
   */
  export type MediaContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaContent
     */
    select?: MediaContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaContent
     */
    omit?: MediaContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaContentInclude<ExtArgs> | null
    /**
     * Filter, which MediaContent to fetch.
     */
    where: MediaContentWhereUniqueInput
  }

  /**
   * MediaContent findUniqueOrThrow
   */
  export type MediaContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaContent
     */
    select?: MediaContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaContent
     */
    omit?: MediaContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaContentInclude<ExtArgs> | null
    /**
     * Filter, which MediaContent to fetch.
     */
    where: MediaContentWhereUniqueInput
  }

  /**
   * MediaContent findFirst
   */
  export type MediaContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaContent
     */
    select?: MediaContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaContent
     */
    omit?: MediaContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaContentInclude<ExtArgs> | null
    /**
     * Filter, which MediaContent to fetch.
     */
    where?: MediaContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaContents to fetch.
     */
    orderBy?: MediaContentOrderByWithRelationInput | MediaContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaContents.
     */
    cursor?: MediaContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaContents.
     */
    distinct?: MediaContentScalarFieldEnum | MediaContentScalarFieldEnum[]
  }

  /**
   * MediaContent findFirstOrThrow
   */
  export type MediaContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaContent
     */
    select?: MediaContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaContent
     */
    omit?: MediaContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaContentInclude<ExtArgs> | null
    /**
     * Filter, which MediaContent to fetch.
     */
    where?: MediaContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaContents to fetch.
     */
    orderBy?: MediaContentOrderByWithRelationInput | MediaContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaContents.
     */
    cursor?: MediaContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaContents.
     */
    distinct?: MediaContentScalarFieldEnum | MediaContentScalarFieldEnum[]
  }

  /**
   * MediaContent findMany
   */
  export type MediaContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaContent
     */
    select?: MediaContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaContent
     */
    omit?: MediaContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaContentInclude<ExtArgs> | null
    /**
     * Filter, which MediaContents to fetch.
     */
    where?: MediaContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaContents to fetch.
     */
    orderBy?: MediaContentOrderByWithRelationInput | MediaContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaContents.
     */
    cursor?: MediaContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaContents.
     */
    skip?: number
    distinct?: MediaContentScalarFieldEnum | MediaContentScalarFieldEnum[]
  }

  /**
   * MediaContent create
   */
  export type MediaContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaContent
     */
    select?: MediaContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaContent
     */
    omit?: MediaContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaContentInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaContent.
     */
    data: XOR<MediaContentCreateInput, MediaContentUncheckedCreateInput>
  }

  /**
   * MediaContent createMany
   */
  export type MediaContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaContents.
     */
    data: MediaContentCreateManyInput | MediaContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaContent createManyAndReturn
   */
  export type MediaContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaContent
     */
    select?: MediaContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaContent
     */
    omit?: MediaContentOmit<ExtArgs> | null
    /**
     * The data used to create many MediaContents.
     */
    data: MediaContentCreateManyInput | MediaContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaContent update
   */
  export type MediaContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaContent
     */
    select?: MediaContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaContent
     */
    omit?: MediaContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaContentInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaContent.
     */
    data: XOR<MediaContentUpdateInput, MediaContentUncheckedUpdateInput>
    /**
     * Choose, which MediaContent to update.
     */
    where: MediaContentWhereUniqueInput
  }

  /**
   * MediaContent updateMany
   */
  export type MediaContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaContents.
     */
    data: XOR<MediaContentUpdateManyMutationInput, MediaContentUncheckedUpdateManyInput>
    /**
     * Filter which MediaContents to update
     */
    where?: MediaContentWhereInput
    /**
     * Limit how many MediaContents to update.
     */
    limit?: number
  }

  /**
   * MediaContent updateManyAndReturn
   */
  export type MediaContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaContent
     */
    select?: MediaContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaContent
     */
    omit?: MediaContentOmit<ExtArgs> | null
    /**
     * The data used to update MediaContents.
     */
    data: XOR<MediaContentUpdateManyMutationInput, MediaContentUncheckedUpdateManyInput>
    /**
     * Filter which MediaContents to update
     */
    where?: MediaContentWhereInput
    /**
     * Limit how many MediaContents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaContentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaContent upsert
   */
  export type MediaContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaContent
     */
    select?: MediaContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaContent
     */
    omit?: MediaContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaContentInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaContent to update in case it exists.
     */
    where: MediaContentWhereUniqueInput
    /**
     * In case the MediaContent found by the `where` argument doesn't exist, create a new MediaContent with this data.
     */
    create: XOR<MediaContentCreateInput, MediaContentUncheckedCreateInput>
    /**
     * In case the MediaContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaContentUpdateInput, MediaContentUncheckedUpdateInput>
  }

  /**
   * MediaContent delete
   */
  export type MediaContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaContent
     */
    select?: MediaContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaContent
     */
    omit?: MediaContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaContentInclude<ExtArgs> | null
    /**
     * Filter which MediaContent to delete.
     */
    where: MediaContentWhereUniqueInput
  }

  /**
   * MediaContent deleteMany
   */
  export type MediaContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaContents to delete
     */
    where?: MediaContentWhereInput
    /**
     * Limit how many MediaContents to delete.
     */
    limit?: number
  }

  /**
   * MediaContent.movie
   */
  export type MediaContent$movieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    where?: MovieWhereInput
  }

  /**
   * MediaContent without action
   */
  export type MediaContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaContent
     */
    select?: MediaContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaContent
     */
    omit?: MediaContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaContentInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameJa: string | null
    nameZh: string | null
    description: string | null
    color: string | null
    category: string | null
    createdAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameJa: string | null
    nameZh: string | null
    description: string | null
    color: string | null
    category: string | null
    createdAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    nameJa: number
    nameZh: number
    description: number
    color: number
    category: number
    createdAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    nameJa?: true
    nameZh?: true
    description?: true
    color?: true
    category?: true
    createdAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    nameJa?: true
    nameZh?: true
    description?: true
    color?: true
    category?: true
    createdAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    nameJa?: true
    nameZh?: true
    description?: true
    color?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    nameJa: string | null
    nameZh: string | null
    description: string | null
    color: string | null
    category: string | null
    createdAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameJa?: boolean
    nameZh?: boolean
    description?: boolean
    color?: boolean
    category?: boolean
    createdAt?: boolean
    movieTags?: boolean | Tag$movieTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameJa?: boolean
    nameZh?: boolean
    description?: boolean
    color?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameJa?: boolean
    nameZh?: boolean
    description?: boolean
    color?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    nameJa?: boolean
    nameZh?: boolean
    description?: boolean
    color?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "nameJa" | "nameZh" | "description" | "color" | "category" | "createdAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movieTags?: boolean | Tag$movieTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      movieTags: Prisma.$MovieTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      nameJa: string | null
      nameZh: string | null
      description: string | null
      color: string | null
      category: string | null
      createdAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movieTags<T extends Tag$movieTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$movieTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly nameJa: FieldRef<"Tag", 'String'>
    readonly nameZh: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly category: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.movieTags
   */
  export type Tag$movieTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    where?: MovieTagWhereInput
    orderBy?: MovieTagOrderByWithRelationInput | MovieTagOrderByWithRelationInput[]
    cursor?: MovieTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieTagScalarFieldEnum | MovieTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model MovieTag
   */

  export type AggregateMovieTag = {
    _count: MovieTagCountAggregateOutputType | null
    _min: MovieTagMinAggregateOutputType | null
    _max: MovieTagMaxAggregateOutputType | null
  }

  export type MovieTagMinAggregateOutputType = {
    id: string | null
    movieId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type MovieTagMaxAggregateOutputType = {
    id: string | null
    movieId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type MovieTagCountAggregateOutputType = {
    id: number
    movieId: number
    tagId: number
    createdAt: number
    _all: number
  }


  export type MovieTagMinAggregateInputType = {
    id?: true
    movieId?: true
    tagId?: true
    createdAt?: true
  }

  export type MovieTagMaxAggregateInputType = {
    id?: true
    movieId?: true
    tagId?: true
    createdAt?: true
  }

  export type MovieTagCountAggregateInputType = {
    id?: true
    movieId?: true
    tagId?: true
    createdAt?: true
    _all?: true
  }

  export type MovieTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieTag to aggregate.
     */
    where?: MovieTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieTags to fetch.
     */
    orderBy?: MovieTagOrderByWithRelationInput | MovieTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieTags
    **/
    _count?: true | MovieTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieTagMaxAggregateInputType
  }

  export type GetMovieTagAggregateType<T extends MovieTagAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieTag[P]>
      : GetScalarType<T[P], AggregateMovieTag[P]>
  }




  export type MovieTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieTagWhereInput
    orderBy?: MovieTagOrderByWithAggregationInput | MovieTagOrderByWithAggregationInput[]
    by: MovieTagScalarFieldEnum[] | MovieTagScalarFieldEnum
    having?: MovieTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieTagCountAggregateInputType | true
    _min?: MovieTagMinAggregateInputType
    _max?: MovieTagMaxAggregateInputType
  }

  export type MovieTagGroupByOutputType = {
    id: string
    movieId: string
    tagId: string
    createdAt: Date
    _count: MovieTagCountAggregateOutputType | null
    _min: MovieTagMinAggregateOutputType | null
    _max: MovieTagMaxAggregateOutputType | null
  }

  type GetMovieTagGroupByPayload<T extends MovieTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieTagGroupByOutputType[P]>
            : GetScalarType<T[P], MovieTagGroupByOutputType[P]>
        }
      >
    >


  export type MovieTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    tagId?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieTag"]>

  export type MovieTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    tagId?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieTag"]>

  export type MovieTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    tagId?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieTag"]>

  export type MovieTagSelectScalar = {
    id?: boolean
    movieId?: boolean
    tagId?: boolean
    createdAt?: boolean
  }

  export type MovieTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "movieId" | "tagId" | "createdAt", ExtArgs["result"]["movieTag"]>
  export type MovieTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type MovieTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type MovieTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $MovieTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieTag"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      movieId: string
      tagId: string
      createdAt: Date
    }, ExtArgs["result"]["movieTag"]>
    composites: {}
  }

  type MovieTagGetPayload<S extends boolean | null | undefined | MovieTagDefaultArgs> = $Result.GetResult<Prisma.$MovieTagPayload, S>

  type MovieTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MovieTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MovieTagCountAggregateInputType | true
    }

  export interface MovieTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieTag'], meta: { name: 'MovieTag' } }
    /**
     * Find zero or one MovieTag that matches the filter.
     * @param {MovieTagFindUniqueArgs} args - Arguments to find a MovieTag
     * @example
     * // Get one MovieTag
     * const movieTag = await prisma.movieTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieTagFindUniqueArgs>(args: SelectSubset<T, MovieTagFindUniqueArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MovieTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MovieTagFindUniqueOrThrowArgs} args - Arguments to find a MovieTag
     * @example
     * // Get one MovieTag
     * const movieTag = await prisma.movieTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieTagFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MovieTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagFindFirstArgs} args - Arguments to find a MovieTag
     * @example
     * // Get one MovieTag
     * const movieTag = await prisma.movieTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieTagFindFirstArgs>(args?: SelectSubset<T, MovieTagFindFirstArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MovieTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagFindFirstOrThrowArgs} args - Arguments to find a MovieTag
     * @example
     * // Get one MovieTag
     * const movieTag = await prisma.movieTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieTagFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MovieTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieTags
     * const movieTags = await prisma.movieTag.findMany()
     * 
     * // Get first 10 MovieTags
     * const movieTags = await prisma.movieTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieTagWithIdOnly = await prisma.movieTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieTagFindManyArgs>(args?: SelectSubset<T, MovieTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MovieTag.
     * @param {MovieTagCreateArgs} args - Arguments to create a MovieTag.
     * @example
     * // Create one MovieTag
     * const MovieTag = await prisma.movieTag.create({
     *   data: {
     *     // ... data to create a MovieTag
     *   }
     * })
     * 
     */
    create<T extends MovieTagCreateArgs>(args: SelectSubset<T, MovieTagCreateArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MovieTags.
     * @param {MovieTagCreateManyArgs} args - Arguments to create many MovieTags.
     * @example
     * // Create many MovieTags
     * const movieTag = await prisma.movieTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieTagCreateManyArgs>(args?: SelectSubset<T, MovieTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieTags and returns the data saved in the database.
     * @param {MovieTagCreateManyAndReturnArgs} args - Arguments to create many MovieTags.
     * @example
     * // Create many MovieTags
     * const movieTag = await prisma.movieTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieTags and only return the `id`
     * const movieTagWithIdOnly = await prisma.movieTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieTagCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MovieTag.
     * @param {MovieTagDeleteArgs} args - Arguments to delete one MovieTag.
     * @example
     * // Delete one MovieTag
     * const MovieTag = await prisma.movieTag.delete({
     *   where: {
     *     // ... filter to delete one MovieTag
     *   }
     * })
     * 
     */
    delete<T extends MovieTagDeleteArgs>(args: SelectSubset<T, MovieTagDeleteArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MovieTag.
     * @param {MovieTagUpdateArgs} args - Arguments to update one MovieTag.
     * @example
     * // Update one MovieTag
     * const movieTag = await prisma.movieTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieTagUpdateArgs>(args: SelectSubset<T, MovieTagUpdateArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MovieTags.
     * @param {MovieTagDeleteManyArgs} args - Arguments to filter MovieTags to delete.
     * @example
     * // Delete a few MovieTags
     * const { count } = await prisma.movieTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieTagDeleteManyArgs>(args?: SelectSubset<T, MovieTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieTags
     * const movieTag = await prisma.movieTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieTagUpdateManyArgs>(args: SelectSubset<T, MovieTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieTags and returns the data updated in the database.
     * @param {MovieTagUpdateManyAndReturnArgs} args - Arguments to update many MovieTags.
     * @example
     * // Update many MovieTags
     * const movieTag = await prisma.movieTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MovieTags and only return the `id`
     * const movieTagWithIdOnly = await prisma.movieTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MovieTagUpdateManyAndReturnArgs>(args: SelectSubset<T, MovieTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MovieTag.
     * @param {MovieTagUpsertArgs} args - Arguments to update or create a MovieTag.
     * @example
     * // Update or create a MovieTag
     * const movieTag = await prisma.movieTag.upsert({
     *   create: {
     *     // ... data to create a MovieTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieTag we want to update
     *   }
     * })
     */
    upsert<T extends MovieTagUpsertArgs>(args: SelectSubset<T, MovieTagUpsertArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MovieTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagCountArgs} args - Arguments to filter MovieTags to count.
     * @example
     * // Count the number of MovieTags
     * const count = await prisma.movieTag.count({
     *   where: {
     *     // ... the filter for the MovieTags we want to count
     *   }
     * })
    **/
    count<T extends MovieTagCountArgs>(
      args?: Subset<T, MovieTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieTagAggregateArgs>(args: Subset<T, MovieTagAggregateArgs>): Prisma.PrismaPromise<GetMovieTagAggregateType<T>>

    /**
     * Group by MovieTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieTagGroupByArgs['orderBy'] }
        : { orderBy?: MovieTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieTag model
   */
  readonly fields: MovieTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieTag model
   */
  interface MovieTagFieldRefs {
    readonly id: FieldRef<"MovieTag", 'String'>
    readonly movieId: FieldRef<"MovieTag", 'String'>
    readonly tagId: FieldRef<"MovieTag", 'String'>
    readonly createdAt: FieldRef<"MovieTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MovieTag findUnique
   */
  export type MovieTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * Filter, which MovieTag to fetch.
     */
    where: MovieTagWhereUniqueInput
  }

  /**
   * MovieTag findUniqueOrThrow
   */
  export type MovieTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * Filter, which MovieTag to fetch.
     */
    where: MovieTagWhereUniqueInput
  }

  /**
   * MovieTag findFirst
   */
  export type MovieTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * Filter, which MovieTag to fetch.
     */
    where?: MovieTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieTags to fetch.
     */
    orderBy?: MovieTagOrderByWithRelationInput | MovieTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieTags.
     */
    cursor?: MovieTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieTags.
     */
    distinct?: MovieTagScalarFieldEnum | MovieTagScalarFieldEnum[]
  }

  /**
   * MovieTag findFirstOrThrow
   */
  export type MovieTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * Filter, which MovieTag to fetch.
     */
    where?: MovieTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieTags to fetch.
     */
    orderBy?: MovieTagOrderByWithRelationInput | MovieTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieTags.
     */
    cursor?: MovieTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieTags.
     */
    distinct?: MovieTagScalarFieldEnum | MovieTagScalarFieldEnum[]
  }

  /**
   * MovieTag findMany
   */
  export type MovieTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * Filter, which MovieTags to fetch.
     */
    where?: MovieTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieTags to fetch.
     */
    orderBy?: MovieTagOrderByWithRelationInput | MovieTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieTags.
     */
    cursor?: MovieTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieTags.
     */
    skip?: number
    distinct?: MovieTagScalarFieldEnum | MovieTagScalarFieldEnum[]
  }

  /**
   * MovieTag create
   */
  export type MovieTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieTag.
     */
    data: XOR<MovieTagCreateInput, MovieTagUncheckedCreateInput>
  }

  /**
   * MovieTag createMany
   */
  export type MovieTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieTags.
     */
    data: MovieTagCreateManyInput | MovieTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovieTag createManyAndReturn
   */
  export type MovieTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * The data used to create many MovieTags.
     */
    data: MovieTagCreateManyInput | MovieTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieTag update
   */
  export type MovieTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieTag.
     */
    data: XOR<MovieTagUpdateInput, MovieTagUncheckedUpdateInput>
    /**
     * Choose, which MovieTag to update.
     */
    where: MovieTagWhereUniqueInput
  }

  /**
   * MovieTag updateMany
   */
  export type MovieTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieTags.
     */
    data: XOR<MovieTagUpdateManyMutationInput, MovieTagUncheckedUpdateManyInput>
    /**
     * Filter which MovieTags to update
     */
    where?: MovieTagWhereInput
    /**
     * Limit how many MovieTags to update.
     */
    limit?: number
  }

  /**
   * MovieTag updateManyAndReturn
   */
  export type MovieTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * The data used to update MovieTags.
     */
    data: XOR<MovieTagUpdateManyMutationInput, MovieTagUncheckedUpdateManyInput>
    /**
     * Filter which MovieTags to update
     */
    where?: MovieTagWhereInput
    /**
     * Limit how many MovieTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieTag upsert
   */
  export type MovieTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieTag to update in case it exists.
     */
    where: MovieTagWhereUniqueInput
    /**
     * In case the MovieTag found by the `where` argument doesn't exist, create a new MovieTag with this data.
     */
    create: XOR<MovieTagCreateInput, MovieTagUncheckedCreateInput>
    /**
     * In case the MovieTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieTagUpdateInput, MovieTagUncheckedUpdateInput>
  }

  /**
   * MovieTag delete
   */
  export type MovieTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * Filter which MovieTag to delete.
     */
    where: MovieTagWhereUniqueInput
  }

  /**
   * MovieTag deleteMany
   */
  export type MovieTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieTags to delete
     */
    where?: MovieTagWhereInput
    /**
     * Limit how many MovieTags to delete.
     */
    limit?: number
  }

  /**
   * MovieTag without action
   */
  export type MovieTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
  }


  /**
   * Model UserFavorite
   */

  export type AggregateUserFavorite = {
    _count: UserFavoriteCountAggregateOutputType | null
    _min: UserFavoriteMinAggregateOutputType | null
    _max: UserFavoriteMaxAggregateOutputType | null
  }

  export type UserFavoriteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    movieId: string | null
    createdAt: Date | null
  }

  export type UserFavoriteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    movieId: string | null
    createdAt: Date | null
  }

  export type UserFavoriteCountAggregateOutputType = {
    id: number
    userId: number
    movieId: number
    createdAt: number
    _all: number
  }


  export type UserFavoriteMinAggregateInputType = {
    id?: true
    userId?: true
    movieId?: true
    createdAt?: true
  }

  export type UserFavoriteMaxAggregateInputType = {
    id?: true
    userId?: true
    movieId?: true
    createdAt?: true
  }

  export type UserFavoriteCountAggregateInputType = {
    id?: true
    userId?: true
    movieId?: true
    createdAt?: true
    _all?: true
  }

  export type UserFavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorite to aggregate.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFavorites
    **/
    _count?: true | UserFavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFavoriteMaxAggregateInputType
  }

  export type GetUserFavoriteAggregateType<T extends UserFavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFavorite[P]>
      : GetScalarType<T[P], AggregateUserFavorite[P]>
  }




  export type UserFavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithAggregationInput | UserFavoriteOrderByWithAggregationInput[]
    by: UserFavoriteScalarFieldEnum[] | UserFavoriteScalarFieldEnum
    having?: UserFavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFavoriteCountAggregateInputType | true
    _min?: UserFavoriteMinAggregateInputType
    _max?: UserFavoriteMaxAggregateInputType
  }

  export type UserFavoriteGroupByOutputType = {
    id: string
    userId: string
    movieId: string
    createdAt: Date
    _count: UserFavoriteCountAggregateOutputType | null
    _min: UserFavoriteMinAggregateOutputType | null
    _max: UserFavoriteMaxAggregateOutputType | null
  }

  type GetUserFavoriteGroupByPayload<T extends UserFavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], UserFavoriteGroupByOutputType[P]>
        }
      >
    >


  export type UserFavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    movieId?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    movieId?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    movieId?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectScalar = {
    id?: boolean
    userId?: boolean
    movieId?: boolean
    createdAt?: boolean
  }

  export type UserFavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "movieId" | "createdAt", ExtArgs["result"]["userFavorite"]>
  export type UserFavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }
  export type UserFavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }
  export type UserFavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }

  export type $UserFavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFavorite"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      movieId: string
      createdAt: Date
    }, ExtArgs["result"]["userFavorite"]>
    composites: {}
  }

  type UserFavoriteGetPayload<S extends boolean | null | undefined | UserFavoriteDefaultArgs> = $Result.GetResult<Prisma.$UserFavoritePayload, S>

  type UserFavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFavoriteCountAggregateInputType | true
    }

  export interface UserFavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFavorite'], meta: { name: 'UserFavorite' } }
    /**
     * Find zero or one UserFavorite that matches the filter.
     * @param {UserFavoriteFindUniqueArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFavoriteFindUniqueArgs>(args: SelectSubset<T, UserFavoriteFindUniqueArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFavorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFavoriteFindUniqueOrThrowArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindFirstArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFavoriteFindFirstArgs>(args?: SelectSubset<T, UserFavoriteFindFirstArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindFirstOrThrowArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFavorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFavorites
     * const userFavorites = await prisma.userFavorite.findMany()
     * 
     * // Get first 10 UserFavorites
     * const userFavorites = await prisma.userFavorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFavoriteFindManyArgs>(args?: SelectSubset<T, UserFavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFavorite.
     * @param {UserFavoriteCreateArgs} args - Arguments to create a UserFavorite.
     * @example
     * // Create one UserFavorite
     * const UserFavorite = await prisma.userFavorite.create({
     *   data: {
     *     // ... data to create a UserFavorite
     *   }
     * })
     * 
     */
    create<T extends UserFavoriteCreateArgs>(args: SelectSubset<T, UserFavoriteCreateArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFavorites.
     * @param {UserFavoriteCreateManyArgs} args - Arguments to create many UserFavorites.
     * @example
     * // Create many UserFavorites
     * const userFavorite = await prisma.userFavorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFavoriteCreateManyArgs>(args?: SelectSubset<T, UserFavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFavorites and returns the data saved in the database.
     * @param {UserFavoriteCreateManyAndReturnArgs} args - Arguments to create many UserFavorites.
     * @example
     * // Create many UserFavorites
     * const userFavorite = await prisma.userFavorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFavorites and only return the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFavorite.
     * @param {UserFavoriteDeleteArgs} args - Arguments to delete one UserFavorite.
     * @example
     * // Delete one UserFavorite
     * const UserFavorite = await prisma.userFavorite.delete({
     *   where: {
     *     // ... filter to delete one UserFavorite
     *   }
     * })
     * 
     */
    delete<T extends UserFavoriteDeleteArgs>(args: SelectSubset<T, UserFavoriteDeleteArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFavorite.
     * @param {UserFavoriteUpdateArgs} args - Arguments to update one UserFavorite.
     * @example
     * // Update one UserFavorite
     * const userFavorite = await prisma.userFavorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFavoriteUpdateArgs>(args: SelectSubset<T, UserFavoriteUpdateArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFavorites.
     * @param {UserFavoriteDeleteManyArgs} args - Arguments to filter UserFavorites to delete.
     * @example
     * // Delete a few UserFavorites
     * const { count } = await prisma.userFavorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFavoriteDeleteManyArgs>(args?: SelectSubset<T, UserFavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFavorites
     * const userFavorite = await prisma.userFavorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFavoriteUpdateManyArgs>(args: SelectSubset<T, UserFavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavorites and returns the data updated in the database.
     * @param {UserFavoriteUpdateManyAndReturnArgs} args - Arguments to update many UserFavorites.
     * @example
     * // Update many UserFavorites
     * const userFavorite = await prisma.userFavorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFavorites and only return the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFavorite.
     * @param {UserFavoriteUpsertArgs} args - Arguments to update or create a UserFavorite.
     * @example
     * // Update or create a UserFavorite
     * const userFavorite = await prisma.userFavorite.upsert({
     *   create: {
     *     // ... data to create a UserFavorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFavorite we want to update
     *   }
     * })
     */
    upsert<T extends UserFavoriteUpsertArgs>(args: SelectSubset<T, UserFavoriteUpsertArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteCountArgs} args - Arguments to filter UserFavorites to count.
     * @example
     * // Count the number of UserFavorites
     * const count = await prisma.userFavorite.count({
     *   where: {
     *     // ... the filter for the UserFavorites we want to count
     *   }
     * })
    **/
    count<T extends UserFavoriteCountArgs>(
      args?: Subset<T, UserFavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFavoriteAggregateArgs>(args: Subset<T, UserFavoriteAggregateArgs>): Prisma.PrismaPromise<GetUserFavoriteAggregateType<T>>

    /**
     * Group by UserFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFavoriteGroupByArgs['orderBy'] }
        : { orderBy?: UserFavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFavorite model
   */
  readonly fields: UserFavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFavorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFavorite model
   */
  interface UserFavoriteFieldRefs {
    readonly id: FieldRef<"UserFavorite", 'String'>
    readonly userId: FieldRef<"UserFavorite", 'String'>
    readonly movieId: FieldRef<"UserFavorite", 'String'>
    readonly createdAt: FieldRef<"UserFavorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFavorite findUnique
   */
  export type UserFavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite findUniqueOrThrow
   */
  export type UserFavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite findFirst
   */
  export type UserFavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorites.
     */
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite findFirstOrThrow
   */
  export type UserFavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorites.
     */
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite findMany
   */
  export type UserFavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorites to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite create
   */
  export type UserFavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFavorite.
     */
    data: XOR<UserFavoriteCreateInput, UserFavoriteUncheckedCreateInput>
  }

  /**
   * UserFavorite createMany
   */
  export type UserFavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFavorites.
     */
    data: UserFavoriteCreateManyInput | UserFavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFavorite createManyAndReturn
   */
  export type UserFavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many UserFavorites.
     */
    data: UserFavoriteCreateManyInput | UserFavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavorite update
   */
  export type UserFavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFavorite.
     */
    data: XOR<UserFavoriteUpdateInput, UserFavoriteUncheckedUpdateInput>
    /**
     * Choose, which UserFavorite to update.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite updateMany
   */
  export type UserFavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFavorites.
     */
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which UserFavorites to update
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to update.
     */
    limit?: number
  }

  /**
   * UserFavorite updateManyAndReturn
   */
  export type UserFavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * The data used to update UserFavorites.
     */
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which UserFavorites to update
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavorite upsert
   */
  export type UserFavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFavorite to update in case it exists.
     */
    where: UserFavoriteWhereUniqueInput
    /**
     * In case the UserFavorite found by the `where` argument doesn't exist, create a new UserFavorite with this data.
     */
    create: XOR<UserFavoriteCreateInput, UserFavoriteUncheckedCreateInput>
    /**
     * In case the UserFavorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFavoriteUpdateInput, UserFavoriteUncheckedUpdateInput>
  }

  /**
   * UserFavorite delete
   */
  export type UserFavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter which UserFavorite to delete.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite deleteMany
   */
  export type UserFavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorites to delete
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to delete.
     */
    limit?: number
  }

  /**
   * UserFavorite without action
   */
  export type UserFavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
  }


  /**
   * Model MovieStats
   */

  export type AggregateMovieStats = {
    _count: MovieStatsCountAggregateOutputType | null
    _avg: MovieStatsAvgAggregateOutputType | null
    _sum: MovieStatsSumAggregateOutputType | null
    _min: MovieStatsMinAggregateOutputType | null
    _max: MovieStatsMaxAggregateOutputType | null
  }

  export type MovieStatsAvgAggregateOutputType = {
    viewCount: number | null
    favoriteCount: number | null
    shareCount: number | null
  }

  export type MovieStatsSumAggregateOutputType = {
    viewCount: number | null
    favoriteCount: number | null
    shareCount: number | null
  }

  export type MovieStatsMinAggregateOutputType = {
    id: string | null
    movieId: string | null
    viewCount: number | null
    favoriteCount: number | null
    shareCount: number | null
    lastViewed: Date | null
    updatedAt: Date | null
  }

  export type MovieStatsMaxAggregateOutputType = {
    id: string | null
    movieId: string | null
    viewCount: number | null
    favoriteCount: number | null
    shareCount: number | null
    lastViewed: Date | null
    updatedAt: Date | null
  }

  export type MovieStatsCountAggregateOutputType = {
    id: number
    movieId: number
    viewCount: number
    favoriteCount: number
    shareCount: number
    lastViewed: number
    updatedAt: number
    _all: number
  }


  export type MovieStatsAvgAggregateInputType = {
    viewCount?: true
    favoriteCount?: true
    shareCount?: true
  }

  export type MovieStatsSumAggregateInputType = {
    viewCount?: true
    favoriteCount?: true
    shareCount?: true
  }

  export type MovieStatsMinAggregateInputType = {
    id?: true
    movieId?: true
    viewCount?: true
    favoriteCount?: true
    shareCount?: true
    lastViewed?: true
    updatedAt?: true
  }

  export type MovieStatsMaxAggregateInputType = {
    id?: true
    movieId?: true
    viewCount?: true
    favoriteCount?: true
    shareCount?: true
    lastViewed?: true
    updatedAt?: true
  }

  export type MovieStatsCountAggregateInputType = {
    id?: true
    movieId?: true
    viewCount?: true
    favoriteCount?: true
    shareCount?: true
    lastViewed?: true
    updatedAt?: true
    _all?: true
  }

  export type MovieStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieStats to aggregate.
     */
    where?: MovieStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieStats to fetch.
     */
    orderBy?: MovieStatsOrderByWithRelationInput | MovieStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieStats
    **/
    _count?: true | MovieStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieStatsMaxAggregateInputType
  }

  export type GetMovieStatsAggregateType<T extends MovieStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieStats[P]>
      : GetScalarType<T[P], AggregateMovieStats[P]>
  }




  export type MovieStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieStatsWhereInput
    orderBy?: MovieStatsOrderByWithAggregationInput | MovieStatsOrderByWithAggregationInput[]
    by: MovieStatsScalarFieldEnum[] | MovieStatsScalarFieldEnum
    having?: MovieStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieStatsCountAggregateInputType | true
    _avg?: MovieStatsAvgAggregateInputType
    _sum?: MovieStatsSumAggregateInputType
    _min?: MovieStatsMinAggregateInputType
    _max?: MovieStatsMaxAggregateInputType
  }

  export type MovieStatsGroupByOutputType = {
    id: string
    movieId: string
    viewCount: number
    favoriteCount: number
    shareCount: number
    lastViewed: Date | null
    updatedAt: Date
    _count: MovieStatsCountAggregateOutputType | null
    _avg: MovieStatsAvgAggregateOutputType | null
    _sum: MovieStatsSumAggregateOutputType | null
    _min: MovieStatsMinAggregateOutputType | null
    _max: MovieStatsMaxAggregateOutputType | null
  }

  type GetMovieStatsGroupByPayload<T extends MovieStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieStatsGroupByOutputType[P]>
            : GetScalarType<T[P], MovieStatsGroupByOutputType[P]>
        }
      >
    >


  export type MovieStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    viewCount?: boolean
    favoriteCount?: boolean
    shareCount?: boolean
    lastViewed?: boolean
    updatedAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieStats"]>

  export type MovieStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    viewCount?: boolean
    favoriteCount?: boolean
    shareCount?: boolean
    lastViewed?: boolean
    updatedAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieStats"]>

  export type MovieStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    viewCount?: boolean
    favoriteCount?: boolean
    shareCount?: boolean
    lastViewed?: boolean
    updatedAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieStats"]>

  export type MovieStatsSelectScalar = {
    id?: boolean
    movieId?: boolean
    viewCount?: boolean
    favoriteCount?: boolean
    shareCount?: boolean
    lastViewed?: boolean
    updatedAt?: boolean
  }

  export type MovieStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "movieId" | "viewCount" | "favoriteCount" | "shareCount" | "lastViewed" | "updatedAt", ExtArgs["result"]["movieStats"]>
  export type MovieStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }
  export type MovieStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }
  export type MovieStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }

  export type $MovieStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieStats"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      movieId: string
      viewCount: number
      favoriteCount: number
      shareCount: number
      lastViewed: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["movieStats"]>
    composites: {}
  }

  type MovieStatsGetPayload<S extends boolean | null | undefined | MovieStatsDefaultArgs> = $Result.GetResult<Prisma.$MovieStatsPayload, S>

  type MovieStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MovieStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MovieStatsCountAggregateInputType | true
    }

  export interface MovieStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieStats'], meta: { name: 'MovieStats' } }
    /**
     * Find zero or one MovieStats that matches the filter.
     * @param {MovieStatsFindUniqueArgs} args - Arguments to find a MovieStats
     * @example
     * // Get one MovieStats
     * const movieStats = await prisma.movieStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieStatsFindUniqueArgs>(args: SelectSubset<T, MovieStatsFindUniqueArgs<ExtArgs>>): Prisma__MovieStatsClient<$Result.GetResult<Prisma.$MovieStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MovieStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MovieStatsFindUniqueOrThrowArgs} args - Arguments to find a MovieStats
     * @example
     * // Get one MovieStats
     * const movieStats = await prisma.movieStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieStatsClient<$Result.GetResult<Prisma.$MovieStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MovieStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieStatsFindFirstArgs} args - Arguments to find a MovieStats
     * @example
     * // Get one MovieStats
     * const movieStats = await prisma.movieStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieStatsFindFirstArgs>(args?: SelectSubset<T, MovieStatsFindFirstArgs<ExtArgs>>): Prisma__MovieStatsClient<$Result.GetResult<Prisma.$MovieStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MovieStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieStatsFindFirstOrThrowArgs} args - Arguments to find a MovieStats
     * @example
     * // Get one MovieStats
     * const movieStats = await prisma.movieStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieStatsClient<$Result.GetResult<Prisma.$MovieStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MovieStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieStats
     * const movieStats = await prisma.movieStats.findMany()
     * 
     * // Get first 10 MovieStats
     * const movieStats = await prisma.movieStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieStatsWithIdOnly = await prisma.movieStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieStatsFindManyArgs>(args?: SelectSubset<T, MovieStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MovieStats.
     * @param {MovieStatsCreateArgs} args - Arguments to create a MovieStats.
     * @example
     * // Create one MovieStats
     * const MovieStats = await prisma.movieStats.create({
     *   data: {
     *     // ... data to create a MovieStats
     *   }
     * })
     * 
     */
    create<T extends MovieStatsCreateArgs>(args: SelectSubset<T, MovieStatsCreateArgs<ExtArgs>>): Prisma__MovieStatsClient<$Result.GetResult<Prisma.$MovieStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MovieStats.
     * @param {MovieStatsCreateManyArgs} args - Arguments to create many MovieStats.
     * @example
     * // Create many MovieStats
     * const movieStats = await prisma.movieStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieStatsCreateManyArgs>(args?: SelectSubset<T, MovieStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieStats and returns the data saved in the database.
     * @param {MovieStatsCreateManyAndReturnArgs} args - Arguments to create many MovieStats.
     * @example
     * // Create many MovieStats
     * const movieStats = await prisma.movieStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieStats and only return the `id`
     * const movieStatsWithIdOnly = await prisma.movieStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MovieStats.
     * @param {MovieStatsDeleteArgs} args - Arguments to delete one MovieStats.
     * @example
     * // Delete one MovieStats
     * const MovieStats = await prisma.movieStats.delete({
     *   where: {
     *     // ... filter to delete one MovieStats
     *   }
     * })
     * 
     */
    delete<T extends MovieStatsDeleteArgs>(args: SelectSubset<T, MovieStatsDeleteArgs<ExtArgs>>): Prisma__MovieStatsClient<$Result.GetResult<Prisma.$MovieStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MovieStats.
     * @param {MovieStatsUpdateArgs} args - Arguments to update one MovieStats.
     * @example
     * // Update one MovieStats
     * const movieStats = await prisma.movieStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieStatsUpdateArgs>(args: SelectSubset<T, MovieStatsUpdateArgs<ExtArgs>>): Prisma__MovieStatsClient<$Result.GetResult<Prisma.$MovieStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MovieStats.
     * @param {MovieStatsDeleteManyArgs} args - Arguments to filter MovieStats to delete.
     * @example
     * // Delete a few MovieStats
     * const { count } = await prisma.movieStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieStatsDeleteManyArgs>(args?: SelectSubset<T, MovieStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieStats
     * const movieStats = await prisma.movieStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieStatsUpdateManyArgs>(args: SelectSubset<T, MovieStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieStats and returns the data updated in the database.
     * @param {MovieStatsUpdateManyAndReturnArgs} args - Arguments to update many MovieStats.
     * @example
     * // Update many MovieStats
     * const movieStats = await prisma.movieStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MovieStats and only return the `id`
     * const movieStatsWithIdOnly = await prisma.movieStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MovieStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, MovieStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MovieStats.
     * @param {MovieStatsUpsertArgs} args - Arguments to update or create a MovieStats.
     * @example
     * // Update or create a MovieStats
     * const movieStats = await prisma.movieStats.upsert({
     *   create: {
     *     // ... data to create a MovieStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieStats we want to update
     *   }
     * })
     */
    upsert<T extends MovieStatsUpsertArgs>(args: SelectSubset<T, MovieStatsUpsertArgs<ExtArgs>>): Prisma__MovieStatsClient<$Result.GetResult<Prisma.$MovieStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MovieStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieStatsCountArgs} args - Arguments to filter MovieStats to count.
     * @example
     * // Count the number of MovieStats
     * const count = await prisma.movieStats.count({
     *   where: {
     *     // ... the filter for the MovieStats we want to count
     *   }
     * })
    **/
    count<T extends MovieStatsCountArgs>(
      args?: Subset<T, MovieStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieStatsAggregateArgs>(args: Subset<T, MovieStatsAggregateArgs>): Prisma.PrismaPromise<GetMovieStatsAggregateType<T>>

    /**
     * Group by MovieStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieStatsGroupByArgs['orderBy'] }
        : { orderBy?: MovieStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieStats model
   */
  readonly fields: MovieStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieStats model
   */
  interface MovieStatsFieldRefs {
    readonly id: FieldRef<"MovieStats", 'String'>
    readonly movieId: FieldRef<"MovieStats", 'String'>
    readonly viewCount: FieldRef<"MovieStats", 'Int'>
    readonly favoriteCount: FieldRef<"MovieStats", 'Int'>
    readonly shareCount: FieldRef<"MovieStats", 'Int'>
    readonly lastViewed: FieldRef<"MovieStats", 'DateTime'>
    readonly updatedAt: FieldRef<"MovieStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MovieStats findUnique
   */
  export type MovieStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieStats
     */
    select?: MovieStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieStats
     */
    omit?: MovieStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieStatsInclude<ExtArgs> | null
    /**
     * Filter, which MovieStats to fetch.
     */
    where: MovieStatsWhereUniqueInput
  }

  /**
   * MovieStats findUniqueOrThrow
   */
  export type MovieStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieStats
     */
    select?: MovieStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieStats
     */
    omit?: MovieStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieStatsInclude<ExtArgs> | null
    /**
     * Filter, which MovieStats to fetch.
     */
    where: MovieStatsWhereUniqueInput
  }

  /**
   * MovieStats findFirst
   */
  export type MovieStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieStats
     */
    select?: MovieStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieStats
     */
    omit?: MovieStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieStatsInclude<ExtArgs> | null
    /**
     * Filter, which MovieStats to fetch.
     */
    where?: MovieStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieStats to fetch.
     */
    orderBy?: MovieStatsOrderByWithRelationInput | MovieStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieStats.
     */
    cursor?: MovieStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieStats.
     */
    distinct?: MovieStatsScalarFieldEnum | MovieStatsScalarFieldEnum[]
  }

  /**
   * MovieStats findFirstOrThrow
   */
  export type MovieStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieStats
     */
    select?: MovieStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieStats
     */
    omit?: MovieStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieStatsInclude<ExtArgs> | null
    /**
     * Filter, which MovieStats to fetch.
     */
    where?: MovieStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieStats to fetch.
     */
    orderBy?: MovieStatsOrderByWithRelationInput | MovieStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieStats.
     */
    cursor?: MovieStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieStats.
     */
    distinct?: MovieStatsScalarFieldEnum | MovieStatsScalarFieldEnum[]
  }

  /**
   * MovieStats findMany
   */
  export type MovieStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieStats
     */
    select?: MovieStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieStats
     */
    omit?: MovieStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieStatsInclude<ExtArgs> | null
    /**
     * Filter, which MovieStats to fetch.
     */
    where?: MovieStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieStats to fetch.
     */
    orderBy?: MovieStatsOrderByWithRelationInput | MovieStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieStats.
     */
    cursor?: MovieStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieStats.
     */
    skip?: number
    distinct?: MovieStatsScalarFieldEnum | MovieStatsScalarFieldEnum[]
  }

  /**
   * MovieStats create
   */
  export type MovieStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieStats
     */
    select?: MovieStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieStats
     */
    omit?: MovieStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieStats.
     */
    data: XOR<MovieStatsCreateInput, MovieStatsUncheckedCreateInput>
  }

  /**
   * MovieStats createMany
   */
  export type MovieStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieStats.
     */
    data: MovieStatsCreateManyInput | MovieStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovieStats createManyAndReturn
   */
  export type MovieStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieStats
     */
    select?: MovieStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MovieStats
     */
    omit?: MovieStatsOmit<ExtArgs> | null
    /**
     * The data used to create many MovieStats.
     */
    data: MovieStatsCreateManyInput | MovieStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieStats update
   */
  export type MovieStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieStats
     */
    select?: MovieStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieStats
     */
    omit?: MovieStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieStats.
     */
    data: XOR<MovieStatsUpdateInput, MovieStatsUncheckedUpdateInput>
    /**
     * Choose, which MovieStats to update.
     */
    where: MovieStatsWhereUniqueInput
  }

  /**
   * MovieStats updateMany
   */
  export type MovieStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieStats.
     */
    data: XOR<MovieStatsUpdateManyMutationInput, MovieStatsUncheckedUpdateManyInput>
    /**
     * Filter which MovieStats to update
     */
    where?: MovieStatsWhereInput
    /**
     * Limit how many MovieStats to update.
     */
    limit?: number
  }

  /**
   * MovieStats updateManyAndReturn
   */
  export type MovieStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieStats
     */
    select?: MovieStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MovieStats
     */
    omit?: MovieStatsOmit<ExtArgs> | null
    /**
     * The data used to update MovieStats.
     */
    data: XOR<MovieStatsUpdateManyMutationInput, MovieStatsUncheckedUpdateManyInput>
    /**
     * Filter which MovieStats to update
     */
    where?: MovieStatsWhereInput
    /**
     * Limit how many MovieStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieStats upsert
   */
  export type MovieStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieStats
     */
    select?: MovieStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieStats
     */
    omit?: MovieStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieStats to update in case it exists.
     */
    where: MovieStatsWhereUniqueInput
    /**
     * In case the MovieStats found by the `where` argument doesn't exist, create a new MovieStats with this data.
     */
    create: XOR<MovieStatsCreateInput, MovieStatsUncheckedCreateInput>
    /**
     * In case the MovieStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieStatsUpdateInput, MovieStatsUncheckedUpdateInput>
  }

  /**
   * MovieStats delete
   */
  export type MovieStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieStats
     */
    select?: MovieStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieStats
     */
    omit?: MovieStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieStatsInclude<ExtArgs> | null
    /**
     * Filter which MovieStats to delete.
     */
    where: MovieStatsWhereUniqueInput
  }

  /**
   * MovieStats deleteMany
   */
  export type MovieStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieStats to delete
     */
    where?: MovieStatsWhereInput
    /**
     * Limit how many MovieStats to delete.
     */
    limit?: number
  }

  /**
   * MovieStats without action
   */
  export type MovieStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieStats
     */
    select?: MovieStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieStats
     */
    omit?: MovieStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieStatsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const MovieScalarFieldEnum: {
    id: 'id',
    tmdbId: 'tmdbId',
    titleEn: 'titleEn',
    titleJa: 'titleJa',
    titleZh: 'titleZh',
    year: 'year',
    director: 'director',
    duration: 'duration',
    synopsis: 'synopsis',
    posterUrl: 'posterUrl',
    backdropUrl: 'backdropUrl',
    voteAverage: 'voteAverage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MovieScalarFieldEnum = (typeof MovieScalarFieldEnum)[keyof typeof MovieScalarFieldEnum]


  export const PlatformScalarFieldEnum: {
    id: 'id',
    name: 'name',
    website: 'website',
    type: 'type',
    logo: 'logo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlatformScalarFieldEnum = (typeof PlatformScalarFieldEnum)[keyof typeof PlatformScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const AvailabilityScalarFieldEnum: {
    id: 'id',
    url: 'url',
    price: 'price',
    currency: 'currency',
    type: 'type',
    lastChecked: 'lastChecked',
    isAvailable: 'isAvailable',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    movieId: 'movieId',
    platformId: 'platformId',
    regionId: 'regionId'
  };

  export type AvailabilityScalarFieldEnum = (typeof AvailabilityScalarFieldEnum)[keyof typeof AvailabilityScalarFieldEnum]


  export const ContentVersionScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    version: 'version',
    changes: 'changes',
    changeType: 'changeType',
    author: 'author',
    reason: 'reason',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ContentVersionScalarFieldEnum = (typeof ContentVersionScalarFieldEnum)[keyof typeof ContentVersionScalarFieldEnum]


  export const ContentReviewScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    versionId: 'versionId',
    status: 'status',
    reviewer: 'reviewer',
    comments: 'comments',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt'
  };

  export type ContentReviewScalarFieldEnum = (typeof ContentReviewScalarFieldEnum)[keyof typeof ContentReviewScalarFieldEnum]


  export const ContentUpdateTaskScalarFieldEnum: {
    id: 'id',
    taskType: 'taskType',
    entityType: 'entityType',
    entityId: 'entityId',
    priority: 'priority',
    status: 'status',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorMessage: 'errorMessage',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContentUpdateTaskScalarFieldEnum = (typeof ContentUpdateTaskScalarFieldEnum)[keyof typeof ContentUpdateTaskScalarFieldEnum]


  export const ContentQualityMetricScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    metricType: 'metricType',
    score: 'score',
    details: 'details',
    measuredAt: 'measuredAt'
  };

  export type ContentQualityMetricScalarFieldEnum = (typeof ContentQualityMetricScalarFieldEnum)[keyof typeof ContentQualityMetricScalarFieldEnum]


  export const UserFeedbackScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    feedbackType: 'feedbackType',
    content: 'content',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    isResolved: 'isResolved',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt'
  };

  export type UserFeedbackScalarFieldEnum = (typeof UserFeedbackScalarFieldEnum)[keyof typeof UserFeedbackScalarFieldEnum]


  export const ContentSyncLogScalarFieldEnum: {
    id: 'id',
    source: 'source',
    syncType: 'syncType',
    status: 'status',
    recordsProcessed: 'recordsProcessed',
    recordsUpdated: 'recordsUpdated',
    recordsCreated: 'recordsCreated',
    recordsFailed: 'recordsFailed',
    errorDetails: 'errorDetails',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type ContentSyncLogScalarFieldEnum = (typeof ContentSyncLogScalarFieldEnum)[keyof typeof ContentSyncLogScalarFieldEnum]


  export const CharacterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameJa: 'nameJa',
    nameZh: 'nameZh',
    description: 'description',
    imageUrl: 'imageUrl',
    isMainCharacter: 'isMainCharacter',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const MovieCharacterScalarFieldEnum: {
    id: 'id',
    movieId: 'movieId',
    characterId: 'characterId',
    voiceActor: 'voiceActor',
    voiceActorJa: 'voiceActorJa',
    importance: 'importance',
    createdAt: 'createdAt'
  };

  export type MovieCharacterScalarFieldEnum = (typeof MovieCharacterScalarFieldEnum)[keyof typeof MovieCharacterScalarFieldEnum]


  export const CrewMemberScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameJa: 'nameJa',
    biography: 'biography',
    imageUrl: 'imageUrl',
    birthDate: 'birthDate',
    nationality: 'nationality',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CrewMemberScalarFieldEnum = (typeof CrewMemberScalarFieldEnum)[keyof typeof CrewMemberScalarFieldEnum]


  export const MovieCrewScalarFieldEnum: {
    id: 'id',
    movieId: 'movieId',
    crewMemberId: 'crewMemberId',
    role: 'role',
    department: 'department',
    createdAt: 'createdAt'
  };

  export type MovieCrewScalarFieldEnum = (typeof MovieCrewScalarFieldEnum)[keyof typeof MovieCrewScalarFieldEnum]


  export const MovieReviewScalarFieldEnum: {
    id: 'id',
    movieId: 'movieId',
    title: 'title',
    content: 'content',
    author: 'author',
    rating: 'rating',
    reviewType: 'reviewType',
    language: 'language',
    isPublished: 'isPublished',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MovieReviewScalarFieldEnum = (typeof MovieReviewScalarFieldEnum)[keyof typeof MovieReviewScalarFieldEnum]


  export const WatchGuideScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    guideType: 'guideType',
    content: 'content',
    order: 'order',
    isPublished: 'isPublished',
    language: 'language',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WatchGuideScalarFieldEnum = (typeof WatchGuideScalarFieldEnum)[keyof typeof WatchGuideScalarFieldEnum]


  export const WatchGuideMovieScalarFieldEnum: {
    id: 'id',
    guideId: 'guideId',
    movieId: 'movieId',
    order: 'order',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type WatchGuideMovieScalarFieldEnum = (typeof WatchGuideMovieScalarFieldEnum)[keyof typeof WatchGuideMovieScalarFieldEnum]


  export const MediaContentScalarFieldEnum: {
    id: 'id',
    movieId: 'movieId',
    title: 'title',
    description: 'description',
    mediaType: 'mediaType',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    duration: 'duration',
    fileSize: 'fileSize',
    language: 'language',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaContentScalarFieldEnum = (typeof MediaContentScalarFieldEnum)[keyof typeof MediaContentScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameJa: 'nameJa',
    nameZh: 'nameZh',
    description: 'description',
    color: 'color',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const MovieTagScalarFieldEnum: {
    id: 'id',
    movieId: 'movieId',
    tagId: 'tagId',
    createdAt: 'createdAt'
  };

  export type MovieTagScalarFieldEnum = (typeof MovieTagScalarFieldEnum)[keyof typeof MovieTagScalarFieldEnum]


  export const UserFavoriteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    movieId: 'movieId',
    createdAt: 'createdAt'
  };

  export type UserFavoriteScalarFieldEnum = (typeof UserFavoriteScalarFieldEnum)[keyof typeof UserFavoriteScalarFieldEnum]


  export const MovieStatsScalarFieldEnum: {
    id: 'id',
    movieId: 'movieId',
    viewCount: 'viewCount',
    favoriteCount: 'favoriteCount',
    shareCount: 'shareCount',
    lastViewed: 'lastViewed',
    updatedAt: 'updatedAt'
  };

  export type MovieStatsScalarFieldEnum = (typeof MovieStatsScalarFieldEnum)[keyof typeof MovieStatsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PlatformType'
   */
  export type EnumPlatformTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlatformType'>
    


  /**
   * Reference to a field of type 'PlatformType[]'
   */
  export type ListEnumPlatformTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlatformType[]'>
    


  /**
   * Reference to a field of type 'AvailabilityType'
   */
  export type EnumAvailabilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AvailabilityType'>
    


  /**
   * Reference to a field of type 'AvailabilityType[]'
   */
  export type ListEnumAvailabilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AvailabilityType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ChangeType'
   */
  export type EnumChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeType'>
    


  /**
   * Reference to a field of type 'ChangeType[]'
   */
  export type ListEnumChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeType[]'>
    


  /**
   * Reference to a field of type 'ReviewStatus'
   */
  export type EnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus'>
    


  /**
   * Reference to a field of type 'ReviewStatus[]'
   */
  export type ListEnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus[]'>
    


  /**
   * Reference to a field of type 'TaskType'
   */
  export type EnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType'>
    


  /**
   * Reference to a field of type 'TaskType[]'
   */
  export type ListEnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'FeedbackType'
   */
  export type EnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType'>
    


  /**
   * Reference to a field of type 'FeedbackType[]'
   */
  export type ListEnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType[]'>
    


  /**
   * Reference to a field of type 'SyncType'
   */
  export type EnumSyncTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncType'>
    


  /**
   * Reference to a field of type 'SyncType[]'
   */
  export type ListEnumSyncTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncType[]'>
    


  /**
   * Reference to a field of type 'SyncStatus'
   */
  export type EnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus'>
    


  /**
   * Reference to a field of type 'SyncStatus[]'
   */
  export type ListEnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus[]'>
    


  /**
   * Reference to a field of type 'CrewRole'
   */
  export type EnumCrewRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CrewRole'>
    


  /**
   * Reference to a field of type 'CrewRole[]'
   */
  export type ListEnumCrewRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CrewRole[]'>
    


  /**
   * Reference to a field of type 'ReviewType'
   */
  export type EnumReviewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewType'>
    


  /**
   * Reference to a field of type 'ReviewType[]'
   */
  export type ListEnumReviewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewType[]'>
    


  /**
   * Reference to a field of type 'GuideType'
   */
  export type EnumGuideTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GuideType'>
    


  /**
   * Reference to a field of type 'GuideType[]'
   */
  export type ListEnumGuideTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GuideType[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    
  /**
   * Deep Input Types
   */


  export type MovieWhereInput = {
    AND?: MovieWhereInput | MovieWhereInput[]
    OR?: MovieWhereInput[]
    NOT?: MovieWhereInput | MovieWhereInput[]
    id?: StringFilter<"Movie"> | string
    tmdbId?: IntFilter<"Movie"> | number
    titleEn?: StringFilter<"Movie"> | string
    titleJa?: StringFilter<"Movie"> | string
    titleZh?: StringNullableFilter<"Movie"> | string | null
    year?: IntFilter<"Movie"> | number
    director?: StringNullableFilter<"Movie"> | string | null
    duration?: IntNullableFilter<"Movie"> | number | null
    synopsis?: StringNullableFilter<"Movie"> | string | null
    posterUrl?: StringNullableFilter<"Movie"> | string | null
    backdropUrl?: StringNullableFilter<"Movie"> | string | null
    voteAverage?: FloatNullableFilter<"Movie"> | number | null
    createdAt?: DateTimeFilter<"Movie"> | Date | string
    updatedAt?: DateTimeFilter<"Movie"> | Date | string
    availabilities?: AvailabilityListRelationFilter
    movieCharacters?: MovieCharacterListRelationFilter
    movieCrew?: MovieCrewListRelationFilter
    reviews?: MovieReviewListRelationFilter
    guideMovies?: WatchGuideMovieListRelationFilter
    mediaContent?: MediaContentListRelationFilter
    movieTags?: MovieTagListRelationFilter
    favorites?: UserFavoriteListRelationFilter
    stats?: XOR<MovieStatsNullableScalarRelationFilter, MovieStatsWhereInput> | null
  }

  export type MovieOrderByWithRelationInput = {
    id?: SortOrder
    tmdbId?: SortOrder
    titleEn?: SortOrder
    titleJa?: SortOrder
    titleZh?: SortOrderInput | SortOrder
    year?: SortOrder
    director?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    synopsis?: SortOrderInput | SortOrder
    posterUrl?: SortOrderInput | SortOrder
    backdropUrl?: SortOrderInput | SortOrder
    voteAverage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    availabilities?: AvailabilityOrderByRelationAggregateInput
    movieCharacters?: MovieCharacterOrderByRelationAggregateInput
    movieCrew?: MovieCrewOrderByRelationAggregateInput
    reviews?: MovieReviewOrderByRelationAggregateInput
    guideMovies?: WatchGuideMovieOrderByRelationAggregateInput
    mediaContent?: MediaContentOrderByRelationAggregateInput
    movieTags?: MovieTagOrderByRelationAggregateInput
    favorites?: UserFavoriteOrderByRelationAggregateInput
    stats?: MovieStatsOrderByWithRelationInput
  }

  export type MovieWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tmdbId?: number
    AND?: MovieWhereInput | MovieWhereInput[]
    OR?: MovieWhereInput[]
    NOT?: MovieWhereInput | MovieWhereInput[]
    titleEn?: StringFilter<"Movie"> | string
    titleJa?: StringFilter<"Movie"> | string
    titleZh?: StringNullableFilter<"Movie"> | string | null
    year?: IntFilter<"Movie"> | number
    director?: StringNullableFilter<"Movie"> | string | null
    duration?: IntNullableFilter<"Movie"> | number | null
    synopsis?: StringNullableFilter<"Movie"> | string | null
    posterUrl?: StringNullableFilter<"Movie"> | string | null
    backdropUrl?: StringNullableFilter<"Movie"> | string | null
    voteAverage?: FloatNullableFilter<"Movie"> | number | null
    createdAt?: DateTimeFilter<"Movie"> | Date | string
    updatedAt?: DateTimeFilter<"Movie"> | Date | string
    availabilities?: AvailabilityListRelationFilter
    movieCharacters?: MovieCharacterListRelationFilter
    movieCrew?: MovieCrewListRelationFilter
    reviews?: MovieReviewListRelationFilter
    guideMovies?: WatchGuideMovieListRelationFilter
    mediaContent?: MediaContentListRelationFilter
    movieTags?: MovieTagListRelationFilter
    favorites?: UserFavoriteListRelationFilter
    stats?: XOR<MovieStatsNullableScalarRelationFilter, MovieStatsWhereInput> | null
  }, "id" | "tmdbId">

  export type MovieOrderByWithAggregationInput = {
    id?: SortOrder
    tmdbId?: SortOrder
    titleEn?: SortOrder
    titleJa?: SortOrder
    titleZh?: SortOrderInput | SortOrder
    year?: SortOrder
    director?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    synopsis?: SortOrderInput | SortOrder
    posterUrl?: SortOrderInput | SortOrder
    backdropUrl?: SortOrderInput | SortOrder
    voteAverage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MovieCountOrderByAggregateInput
    _avg?: MovieAvgOrderByAggregateInput
    _max?: MovieMaxOrderByAggregateInput
    _min?: MovieMinOrderByAggregateInput
    _sum?: MovieSumOrderByAggregateInput
  }

  export type MovieScalarWhereWithAggregatesInput = {
    AND?: MovieScalarWhereWithAggregatesInput | MovieScalarWhereWithAggregatesInput[]
    OR?: MovieScalarWhereWithAggregatesInput[]
    NOT?: MovieScalarWhereWithAggregatesInput | MovieScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Movie"> | string
    tmdbId?: IntWithAggregatesFilter<"Movie"> | number
    titleEn?: StringWithAggregatesFilter<"Movie"> | string
    titleJa?: StringWithAggregatesFilter<"Movie"> | string
    titleZh?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    year?: IntWithAggregatesFilter<"Movie"> | number
    director?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Movie"> | number | null
    synopsis?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    posterUrl?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    backdropUrl?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    voteAverage?: FloatNullableWithAggregatesFilter<"Movie"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Movie"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Movie"> | Date | string
  }

  export type PlatformWhereInput = {
    AND?: PlatformWhereInput | PlatformWhereInput[]
    OR?: PlatformWhereInput[]
    NOT?: PlatformWhereInput | PlatformWhereInput[]
    id?: StringFilter<"Platform"> | string
    name?: StringFilter<"Platform"> | string
    website?: StringFilter<"Platform"> | string
    type?: EnumPlatformTypeFilter<"Platform"> | $Enums.PlatformType
    logo?: StringNullableFilter<"Platform"> | string | null
    createdAt?: DateTimeFilter<"Platform"> | Date | string
    updatedAt?: DateTimeFilter<"Platform"> | Date | string
    availabilities?: AvailabilityListRelationFilter
  }

  export type PlatformOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    type?: SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    availabilities?: AvailabilityOrderByRelationAggregateInput
  }

  export type PlatformWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlatformWhereInput | PlatformWhereInput[]
    OR?: PlatformWhereInput[]
    NOT?: PlatformWhereInput | PlatformWhereInput[]
    name?: StringFilter<"Platform"> | string
    website?: StringFilter<"Platform"> | string
    type?: EnumPlatformTypeFilter<"Platform"> | $Enums.PlatformType
    logo?: StringNullableFilter<"Platform"> | string | null
    createdAt?: DateTimeFilter<"Platform"> | Date | string
    updatedAt?: DateTimeFilter<"Platform"> | Date | string
    availabilities?: AvailabilityListRelationFilter
  }, "id">

  export type PlatformOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    type?: SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlatformCountOrderByAggregateInput
    _max?: PlatformMaxOrderByAggregateInput
    _min?: PlatformMinOrderByAggregateInput
  }

  export type PlatformScalarWhereWithAggregatesInput = {
    AND?: PlatformScalarWhereWithAggregatesInput | PlatformScalarWhereWithAggregatesInput[]
    OR?: PlatformScalarWhereWithAggregatesInput[]
    NOT?: PlatformScalarWhereWithAggregatesInput | PlatformScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Platform"> | string
    name?: StringWithAggregatesFilter<"Platform"> | string
    website?: StringWithAggregatesFilter<"Platform"> | string
    type?: EnumPlatformTypeWithAggregatesFilter<"Platform"> | $Enums.PlatformType
    logo?: StringNullableWithAggregatesFilter<"Platform"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Platform"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Platform"> | Date | string
  }

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: StringFilter<"Region"> | string
    code?: StringFilter<"Region"> | string
    name?: StringFilter<"Region"> | string
    createdAt?: DateTimeFilter<"Region"> | Date | string
    updatedAt?: DateTimeFilter<"Region"> | Date | string
    availabilities?: AvailabilityListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    availabilities?: AvailabilityOrderByRelationAggregateInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    name?: StringFilter<"Region"> | string
    createdAt?: DateTimeFilter<"Region"> | Date | string
    updatedAt?: DateTimeFilter<"Region"> | Date | string
    availabilities?: AvailabilityListRelationFilter
  }, "id" | "code">

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Region"> | string
    code?: StringWithAggregatesFilter<"Region"> | string
    name?: StringWithAggregatesFilter<"Region"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Region"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Region"> | Date | string
  }

  export type AvailabilityWhereInput = {
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    id?: StringFilter<"Availability"> | string
    url?: StringNullableFilter<"Availability"> | string | null
    price?: FloatNullableFilter<"Availability"> | number | null
    currency?: StringNullableFilter<"Availability"> | string | null
    type?: EnumAvailabilityTypeFilter<"Availability"> | $Enums.AvailabilityType
    lastChecked?: DateTimeFilter<"Availability"> | Date | string
    isAvailable?: BoolFilter<"Availability"> | boolean
    notes?: StringNullableFilter<"Availability"> | string | null
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
    movieId?: StringFilter<"Availability"> | string
    platformId?: StringFilter<"Availability"> | string
    regionId?: StringFilter<"Availability"> | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
    platform?: XOR<PlatformScalarRelationFilter, PlatformWhereInput>
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
  }

  export type AvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    type?: SortOrder
    lastChecked?: SortOrder
    isAvailable?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movieId?: SortOrder
    platformId?: SortOrder
    regionId?: SortOrder
    movie?: MovieOrderByWithRelationInput
    platform?: PlatformOrderByWithRelationInput
    region?: RegionOrderByWithRelationInput
  }

  export type AvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    movieId_platformId_regionId_type?: AvailabilityMovieIdPlatformIdRegionIdTypeCompoundUniqueInput
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    url?: StringNullableFilter<"Availability"> | string | null
    price?: FloatNullableFilter<"Availability"> | number | null
    currency?: StringNullableFilter<"Availability"> | string | null
    type?: EnumAvailabilityTypeFilter<"Availability"> | $Enums.AvailabilityType
    lastChecked?: DateTimeFilter<"Availability"> | Date | string
    isAvailable?: BoolFilter<"Availability"> | boolean
    notes?: StringNullableFilter<"Availability"> | string | null
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
    movieId?: StringFilter<"Availability"> | string
    platformId?: StringFilter<"Availability"> | string
    regionId?: StringFilter<"Availability"> | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
    platform?: XOR<PlatformScalarRelationFilter, PlatformWhereInput>
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
  }, "id" | "movieId_platformId_regionId_type">

  export type AvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    type?: SortOrder
    lastChecked?: SortOrder
    isAvailable?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movieId?: SortOrder
    platformId?: SortOrder
    regionId?: SortOrder
    _count?: AvailabilityCountOrderByAggregateInput
    _avg?: AvailabilityAvgOrderByAggregateInput
    _max?: AvailabilityMaxOrderByAggregateInput
    _min?: AvailabilityMinOrderByAggregateInput
    _sum?: AvailabilitySumOrderByAggregateInput
  }

  export type AvailabilityScalarWhereWithAggregatesInput = {
    AND?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    OR?: AvailabilityScalarWhereWithAggregatesInput[]
    NOT?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Availability"> | string
    url?: StringNullableWithAggregatesFilter<"Availability"> | string | null
    price?: FloatNullableWithAggregatesFilter<"Availability"> | number | null
    currency?: StringNullableWithAggregatesFilter<"Availability"> | string | null
    type?: EnumAvailabilityTypeWithAggregatesFilter<"Availability"> | $Enums.AvailabilityType
    lastChecked?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
    isAvailable?: BoolWithAggregatesFilter<"Availability"> | boolean
    notes?: StringNullableWithAggregatesFilter<"Availability"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
    movieId?: StringWithAggregatesFilter<"Availability"> | string
    platformId?: StringWithAggregatesFilter<"Availability"> | string
    regionId?: StringWithAggregatesFilter<"Availability"> | string
  }

  export type ContentVersionWhereInput = {
    AND?: ContentVersionWhereInput | ContentVersionWhereInput[]
    OR?: ContentVersionWhereInput[]
    NOT?: ContentVersionWhereInput | ContentVersionWhereInput[]
    id?: StringFilter<"ContentVersion"> | string
    entityType?: StringFilter<"ContentVersion"> | string
    entityId?: StringFilter<"ContentVersion"> | string
    version?: IntFilter<"ContentVersion"> | number
    changes?: JsonFilter<"ContentVersion">
    changeType?: EnumChangeTypeFilter<"ContentVersion"> | $Enums.ChangeType
    author?: StringNullableFilter<"ContentVersion"> | string | null
    reason?: StringNullableFilter<"ContentVersion"> | string | null
    isActive?: BoolFilter<"ContentVersion"> | boolean
    createdAt?: DateTimeFilter<"ContentVersion"> | Date | string
    reviews?: ContentReviewListRelationFilter
  }

  export type ContentVersionOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    version?: SortOrder
    changes?: SortOrder
    changeType?: SortOrder
    author?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    reviews?: ContentReviewOrderByRelationAggregateInput
  }

  export type ContentVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentVersionWhereInput | ContentVersionWhereInput[]
    OR?: ContentVersionWhereInput[]
    NOT?: ContentVersionWhereInput | ContentVersionWhereInput[]
    entityType?: StringFilter<"ContentVersion"> | string
    entityId?: StringFilter<"ContentVersion"> | string
    version?: IntFilter<"ContentVersion"> | number
    changes?: JsonFilter<"ContentVersion">
    changeType?: EnumChangeTypeFilter<"ContentVersion"> | $Enums.ChangeType
    author?: StringNullableFilter<"ContentVersion"> | string | null
    reason?: StringNullableFilter<"ContentVersion"> | string | null
    isActive?: BoolFilter<"ContentVersion"> | boolean
    createdAt?: DateTimeFilter<"ContentVersion"> | Date | string
    reviews?: ContentReviewListRelationFilter
  }, "id">

  export type ContentVersionOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    version?: SortOrder
    changes?: SortOrder
    changeType?: SortOrder
    author?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ContentVersionCountOrderByAggregateInput
    _avg?: ContentVersionAvgOrderByAggregateInput
    _max?: ContentVersionMaxOrderByAggregateInput
    _min?: ContentVersionMinOrderByAggregateInput
    _sum?: ContentVersionSumOrderByAggregateInput
  }

  export type ContentVersionScalarWhereWithAggregatesInput = {
    AND?: ContentVersionScalarWhereWithAggregatesInput | ContentVersionScalarWhereWithAggregatesInput[]
    OR?: ContentVersionScalarWhereWithAggregatesInput[]
    NOT?: ContentVersionScalarWhereWithAggregatesInput | ContentVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentVersion"> | string
    entityType?: StringWithAggregatesFilter<"ContentVersion"> | string
    entityId?: StringWithAggregatesFilter<"ContentVersion"> | string
    version?: IntWithAggregatesFilter<"ContentVersion"> | number
    changes?: JsonWithAggregatesFilter<"ContentVersion">
    changeType?: EnumChangeTypeWithAggregatesFilter<"ContentVersion"> | $Enums.ChangeType
    author?: StringNullableWithAggregatesFilter<"ContentVersion"> | string | null
    reason?: StringNullableWithAggregatesFilter<"ContentVersion"> | string | null
    isActive?: BoolWithAggregatesFilter<"ContentVersion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ContentVersion"> | Date | string
  }

  export type ContentReviewWhereInput = {
    AND?: ContentReviewWhereInput | ContentReviewWhereInput[]
    OR?: ContentReviewWhereInput[]
    NOT?: ContentReviewWhereInput | ContentReviewWhereInput[]
    id?: StringFilter<"ContentReview"> | string
    entityType?: StringFilter<"ContentReview"> | string
    entityId?: StringFilter<"ContentReview"> | string
    versionId?: StringFilter<"ContentReview"> | string
    status?: EnumReviewStatusFilter<"ContentReview"> | $Enums.ReviewStatus
    reviewer?: StringNullableFilter<"ContentReview"> | string | null
    comments?: StringNullableFilter<"ContentReview"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ContentReview"> | Date | string | null
    createdAt?: DateTimeFilter<"ContentReview"> | Date | string
    version?: XOR<ContentVersionScalarRelationFilter, ContentVersionWhereInput>
  }

  export type ContentReviewOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    versionId?: SortOrder
    status?: SortOrder
    reviewer?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    version?: ContentVersionOrderByWithRelationInput
  }

  export type ContentReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentReviewWhereInput | ContentReviewWhereInput[]
    OR?: ContentReviewWhereInput[]
    NOT?: ContentReviewWhereInput | ContentReviewWhereInput[]
    entityType?: StringFilter<"ContentReview"> | string
    entityId?: StringFilter<"ContentReview"> | string
    versionId?: StringFilter<"ContentReview"> | string
    status?: EnumReviewStatusFilter<"ContentReview"> | $Enums.ReviewStatus
    reviewer?: StringNullableFilter<"ContentReview"> | string | null
    comments?: StringNullableFilter<"ContentReview"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ContentReview"> | Date | string | null
    createdAt?: DateTimeFilter<"ContentReview"> | Date | string
    version?: XOR<ContentVersionScalarRelationFilter, ContentVersionWhereInput>
  }, "id">

  export type ContentReviewOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    versionId?: SortOrder
    status?: SortOrder
    reviewer?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ContentReviewCountOrderByAggregateInput
    _max?: ContentReviewMaxOrderByAggregateInput
    _min?: ContentReviewMinOrderByAggregateInput
  }

  export type ContentReviewScalarWhereWithAggregatesInput = {
    AND?: ContentReviewScalarWhereWithAggregatesInput | ContentReviewScalarWhereWithAggregatesInput[]
    OR?: ContentReviewScalarWhereWithAggregatesInput[]
    NOT?: ContentReviewScalarWhereWithAggregatesInput | ContentReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentReview"> | string
    entityType?: StringWithAggregatesFilter<"ContentReview"> | string
    entityId?: StringWithAggregatesFilter<"ContentReview"> | string
    versionId?: StringWithAggregatesFilter<"ContentReview"> | string
    status?: EnumReviewStatusWithAggregatesFilter<"ContentReview"> | $Enums.ReviewStatus
    reviewer?: StringNullableWithAggregatesFilter<"ContentReview"> | string | null
    comments?: StringNullableWithAggregatesFilter<"ContentReview"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"ContentReview"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContentReview"> | Date | string
  }

  export type ContentUpdateTaskWhereInput = {
    AND?: ContentUpdateTaskWhereInput | ContentUpdateTaskWhereInput[]
    OR?: ContentUpdateTaskWhereInput[]
    NOT?: ContentUpdateTaskWhereInput | ContentUpdateTaskWhereInput[]
    id?: StringFilter<"ContentUpdateTask"> | string
    taskType?: EnumTaskTypeFilter<"ContentUpdateTask"> | $Enums.TaskType
    entityType?: StringNullableFilter<"ContentUpdateTask"> | string | null
    entityId?: StringNullableFilter<"ContentUpdateTask"> | string | null
    priority?: EnumPriorityFilter<"ContentUpdateTask"> | $Enums.Priority
    status?: EnumTaskStatusFilter<"ContentUpdateTask"> | $Enums.TaskStatus
    scheduledAt?: DateTimeNullableFilter<"ContentUpdateTask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"ContentUpdateTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ContentUpdateTask"> | Date | string | null
    errorMessage?: StringNullableFilter<"ContentUpdateTask"> | string | null
    metadata?: JsonNullableFilter<"ContentUpdateTask">
    createdAt?: DateTimeFilter<"ContentUpdateTask"> | Date | string
    updatedAt?: DateTimeFilter<"ContentUpdateTask"> | Date | string
  }

  export type ContentUpdateTaskOrderByWithRelationInput = {
    id?: SortOrder
    taskType?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentUpdateTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentUpdateTaskWhereInput | ContentUpdateTaskWhereInput[]
    OR?: ContentUpdateTaskWhereInput[]
    NOT?: ContentUpdateTaskWhereInput | ContentUpdateTaskWhereInput[]
    taskType?: EnumTaskTypeFilter<"ContentUpdateTask"> | $Enums.TaskType
    entityType?: StringNullableFilter<"ContentUpdateTask"> | string | null
    entityId?: StringNullableFilter<"ContentUpdateTask"> | string | null
    priority?: EnumPriorityFilter<"ContentUpdateTask"> | $Enums.Priority
    status?: EnumTaskStatusFilter<"ContentUpdateTask"> | $Enums.TaskStatus
    scheduledAt?: DateTimeNullableFilter<"ContentUpdateTask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"ContentUpdateTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ContentUpdateTask"> | Date | string | null
    errorMessage?: StringNullableFilter<"ContentUpdateTask"> | string | null
    metadata?: JsonNullableFilter<"ContentUpdateTask">
    createdAt?: DateTimeFilter<"ContentUpdateTask"> | Date | string
    updatedAt?: DateTimeFilter<"ContentUpdateTask"> | Date | string
  }, "id">

  export type ContentUpdateTaskOrderByWithAggregationInput = {
    id?: SortOrder
    taskType?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContentUpdateTaskCountOrderByAggregateInput
    _max?: ContentUpdateTaskMaxOrderByAggregateInput
    _min?: ContentUpdateTaskMinOrderByAggregateInput
  }

  export type ContentUpdateTaskScalarWhereWithAggregatesInput = {
    AND?: ContentUpdateTaskScalarWhereWithAggregatesInput | ContentUpdateTaskScalarWhereWithAggregatesInput[]
    OR?: ContentUpdateTaskScalarWhereWithAggregatesInput[]
    NOT?: ContentUpdateTaskScalarWhereWithAggregatesInput | ContentUpdateTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentUpdateTask"> | string
    taskType?: EnumTaskTypeWithAggregatesFilter<"ContentUpdateTask"> | $Enums.TaskType
    entityType?: StringNullableWithAggregatesFilter<"ContentUpdateTask"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"ContentUpdateTask"> | string | null
    priority?: EnumPriorityWithAggregatesFilter<"ContentUpdateTask"> | $Enums.Priority
    status?: EnumTaskStatusWithAggregatesFilter<"ContentUpdateTask"> | $Enums.TaskStatus
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"ContentUpdateTask"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"ContentUpdateTask"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ContentUpdateTask"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"ContentUpdateTask"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ContentUpdateTask">
    createdAt?: DateTimeWithAggregatesFilter<"ContentUpdateTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContentUpdateTask"> | Date | string
  }

  export type ContentQualityMetricWhereInput = {
    AND?: ContentQualityMetricWhereInput | ContentQualityMetricWhereInput[]
    OR?: ContentQualityMetricWhereInput[]
    NOT?: ContentQualityMetricWhereInput | ContentQualityMetricWhereInput[]
    id?: StringFilter<"ContentQualityMetric"> | string
    entityType?: StringFilter<"ContentQualityMetric"> | string
    entityId?: StringFilter<"ContentQualityMetric"> | string
    metricType?: StringFilter<"ContentQualityMetric"> | string
    score?: FloatFilter<"ContentQualityMetric"> | number
    details?: JsonNullableFilter<"ContentQualityMetric">
    measuredAt?: DateTimeFilter<"ContentQualityMetric"> | Date | string
  }

  export type ContentQualityMetricOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metricType?: SortOrder
    score?: SortOrder
    details?: SortOrderInput | SortOrder
    measuredAt?: SortOrder
  }

  export type ContentQualityMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentQualityMetricWhereInput | ContentQualityMetricWhereInput[]
    OR?: ContentQualityMetricWhereInput[]
    NOT?: ContentQualityMetricWhereInput | ContentQualityMetricWhereInput[]
    entityType?: StringFilter<"ContentQualityMetric"> | string
    entityId?: StringFilter<"ContentQualityMetric"> | string
    metricType?: StringFilter<"ContentQualityMetric"> | string
    score?: FloatFilter<"ContentQualityMetric"> | number
    details?: JsonNullableFilter<"ContentQualityMetric">
    measuredAt?: DateTimeFilter<"ContentQualityMetric"> | Date | string
  }, "id">

  export type ContentQualityMetricOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metricType?: SortOrder
    score?: SortOrder
    details?: SortOrderInput | SortOrder
    measuredAt?: SortOrder
    _count?: ContentQualityMetricCountOrderByAggregateInput
    _avg?: ContentQualityMetricAvgOrderByAggregateInput
    _max?: ContentQualityMetricMaxOrderByAggregateInput
    _min?: ContentQualityMetricMinOrderByAggregateInput
    _sum?: ContentQualityMetricSumOrderByAggregateInput
  }

  export type ContentQualityMetricScalarWhereWithAggregatesInput = {
    AND?: ContentQualityMetricScalarWhereWithAggregatesInput | ContentQualityMetricScalarWhereWithAggregatesInput[]
    OR?: ContentQualityMetricScalarWhereWithAggregatesInput[]
    NOT?: ContentQualityMetricScalarWhereWithAggregatesInput | ContentQualityMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentQualityMetric"> | string
    entityType?: StringWithAggregatesFilter<"ContentQualityMetric"> | string
    entityId?: StringWithAggregatesFilter<"ContentQualityMetric"> | string
    metricType?: StringWithAggregatesFilter<"ContentQualityMetric"> | string
    score?: FloatWithAggregatesFilter<"ContentQualityMetric"> | number
    details?: JsonNullableWithAggregatesFilter<"ContentQualityMetric">
    measuredAt?: DateTimeWithAggregatesFilter<"ContentQualityMetric"> | Date | string
  }

  export type UserFeedbackWhereInput = {
    AND?: UserFeedbackWhereInput | UserFeedbackWhereInput[]
    OR?: UserFeedbackWhereInput[]
    NOT?: UserFeedbackWhereInput | UserFeedbackWhereInput[]
    id?: StringFilter<"UserFeedback"> | string
    entityType?: StringFilter<"UserFeedback"> | string
    entityId?: StringFilter<"UserFeedback"> | string
    feedbackType?: EnumFeedbackTypeFilter<"UserFeedback"> | $Enums.FeedbackType
    content?: StringFilter<"UserFeedback"> | string
    userAgent?: StringNullableFilter<"UserFeedback"> | string | null
    ipAddress?: StringNullableFilter<"UserFeedback"> | string | null
    isResolved?: BoolFilter<"UserFeedback"> | boolean
    resolvedAt?: DateTimeNullableFilter<"UserFeedback"> | Date | string | null
    createdAt?: DateTimeFilter<"UserFeedback"> | Date | string
  }

  export type UserFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    feedbackType?: SortOrder
    content?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type UserFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserFeedbackWhereInput | UserFeedbackWhereInput[]
    OR?: UserFeedbackWhereInput[]
    NOT?: UserFeedbackWhereInput | UserFeedbackWhereInput[]
    entityType?: StringFilter<"UserFeedback"> | string
    entityId?: StringFilter<"UserFeedback"> | string
    feedbackType?: EnumFeedbackTypeFilter<"UserFeedback"> | $Enums.FeedbackType
    content?: StringFilter<"UserFeedback"> | string
    userAgent?: StringNullableFilter<"UserFeedback"> | string | null
    ipAddress?: StringNullableFilter<"UserFeedback"> | string | null
    isResolved?: BoolFilter<"UserFeedback"> | boolean
    resolvedAt?: DateTimeNullableFilter<"UserFeedback"> | Date | string | null
    createdAt?: DateTimeFilter<"UserFeedback"> | Date | string
  }, "id">

  export type UserFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    feedbackType?: SortOrder
    content?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserFeedbackCountOrderByAggregateInput
    _max?: UserFeedbackMaxOrderByAggregateInput
    _min?: UserFeedbackMinOrderByAggregateInput
  }

  export type UserFeedbackScalarWhereWithAggregatesInput = {
    AND?: UserFeedbackScalarWhereWithAggregatesInput | UserFeedbackScalarWhereWithAggregatesInput[]
    OR?: UserFeedbackScalarWhereWithAggregatesInput[]
    NOT?: UserFeedbackScalarWhereWithAggregatesInput | UserFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFeedback"> | string
    entityType?: StringWithAggregatesFilter<"UserFeedback"> | string
    entityId?: StringWithAggregatesFilter<"UserFeedback"> | string
    feedbackType?: EnumFeedbackTypeWithAggregatesFilter<"UserFeedback"> | $Enums.FeedbackType
    content?: StringWithAggregatesFilter<"UserFeedback"> | string
    userAgent?: StringNullableWithAggregatesFilter<"UserFeedback"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"UserFeedback"> | string | null
    isResolved?: BoolWithAggregatesFilter<"UserFeedback"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"UserFeedback"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserFeedback"> | Date | string
  }

  export type ContentSyncLogWhereInput = {
    AND?: ContentSyncLogWhereInput | ContentSyncLogWhereInput[]
    OR?: ContentSyncLogWhereInput[]
    NOT?: ContentSyncLogWhereInput | ContentSyncLogWhereInput[]
    id?: StringFilter<"ContentSyncLog"> | string
    source?: StringFilter<"ContentSyncLog"> | string
    syncType?: EnumSyncTypeFilter<"ContentSyncLog"> | $Enums.SyncType
    status?: EnumSyncStatusFilter<"ContentSyncLog"> | $Enums.SyncStatus
    recordsProcessed?: IntFilter<"ContentSyncLog"> | number
    recordsUpdated?: IntFilter<"ContentSyncLog"> | number
    recordsCreated?: IntFilter<"ContentSyncLog"> | number
    recordsFailed?: IntFilter<"ContentSyncLog"> | number
    errorDetails?: JsonNullableFilter<"ContentSyncLog">
    startedAt?: DateTimeFilter<"ContentSyncLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"ContentSyncLog"> | Date | string | null
  }

  export type ContentSyncLogOrderByWithRelationInput = {
    id?: SortOrder
    source?: SortOrder
    syncType?: SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrder
    recordsUpdated?: SortOrder
    recordsCreated?: SortOrder
    recordsFailed?: SortOrder
    errorDetails?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type ContentSyncLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentSyncLogWhereInput | ContentSyncLogWhereInput[]
    OR?: ContentSyncLogWhereInput[]
    NOT?: ContentSyncLogWhereInput | ContentSyncLogWhereInput[]
    source?: StringFilter<"ContentSyncLog"> | string
    syncType?: EnumSyncTypeFilter<"ContentSyncLog"> | $Enums.SyncType
    status?: EnumSyncStatusFilter<"ContentSyncLog"> | $Enums.SyncStatus
    recordsProcessed?: IntFilter<"ContentSyncLog"> | number
    recordsUpdated?: IntFilter<"ContentSyncLog"> | number
    recordsCreated?: IntFilter<"ContentSyncLog"> | number
    recordsFailed?: IntFilter<"ContentSyncLog"> | number
    errorDetails?: JsonNullableFilter<"ContentSyncLog">
    startedAt?: DateTimeFilter<"ContentSyncLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"ContentSyncLog"> | Date | string | null
  }, "id">

  export type ContentSyncLogOrderByWithAggregationInput = {
    id?: SortOrder
    source?: SortOrder
    syncType?: SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrder
    recordsUpdated?: SortOrder
    recordsCreated?: SortOrder
    recordsFailed?: SortOrder
    errorDetails?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ContentSyncLogCountOrderByAggregateInput
    _avg?: ContentSyncLogAvgOrderByAggregateInput
    _max?: ContentSyncLogMaxOrderByAggregateInput
    _min?: ContentSyncLogMinOrderByAggregateInput
    _sum?: ContentSyncLogSumOrderByAggregateInput
  }

  export type ContentSyncLogScalarWhereWithAggregatesInput = {
    AND?: ContentSyncLogScalarWhereWithAggregatesInput | ContentSyncLogScalarWhereWithAggregatesInput[]
    OR?: ContentSyncLogScalarWhereWithAggregatesInput[]
    NOT?: ContentSyncLogScalarWhereWithAggregatesInput | ContentSyncLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentSyncLog"> | string
    source?: StringWithAggregatesFilter<"ContentSyncLog"> | string
    syncType?: EnumSyncTypeWithAggregatesFilter<"ContentSyncLog"> | $Enums.SyncType
    status?: EnumSyncStatusWithAggregatesFilter<"ContentSyncLog"> | $Enums.SyncStatus
    recordsProcessed?: IntWithAggregatesFilter<"ContentSyncLog"> | number
    recordsUpdated?: IntWithAggregatesFilter<"ContentSyncLog"> | number
    recordsCreated?: IntWithAggregatesFilter<"ContentSyncLog"> | number
    recordsFailed?: IntWithAggregatesFilter<"ContentSyncLog"> | number
    errorDetails?: JsonNullableWithAggregatesFilter<"ContentSyncLog">
    startedAt?: DateTimeWithAggregatesFilter<"ContentSyncLog"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ContentSyncLog"> | Date | string | null
  }

  export type CharacterWhereInput = {
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    id?: StringFilter<"Character"> | string
    name?: StringFilter<"Character"> | string
    nameJa?: StringNullableFilter<"Character"> | string | null
    nameZh?: StringNullableFilter<"Character"> | string | null
    description?: StringNullableFilter<"Character"> | string | null
    imageUrl?: StringNullableFilter<"Character"> | string | null
    isMainCharacter?: BoolFilter<"Character"> | boolean
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
    movieCharacters?: MovieCharacterListRelationFilter
  }

  export type CharacterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrderInput | SortOrder
    nameZh?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isMainCharacter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movieCharacters?: MovieCharacterOrderByRelationAggregateInput
  }

  export type CharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    name?: StringFilter<"Character"> | string
    nameJa?: StringNullableFilter<"Character"> | string | null
    nameZh?: StringNullableFilter<"Character"> | string | null
    description?: StringNullableFilter<"Character"> | string | null
    imageUrl?: StringNullableFilter<"Character"> | string | null
    isMainCharacter?: BoolFilter<"Character"> | boolean
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
    movieCharacters?: MovieCharacterListRelationFilter
  }, "id">

  export type CharacterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrderInput | SortOrder
    nameZh?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isMainCharacter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CharacterCountOrderByAggregateInput
    _max?: CharacterMaxOrderByAggregateInput
    _min?: CharacterMinOrderByAggregateInput
  }

  export type CharacterScalarWhereWithAggregatesInput = {
    AND?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    OR?: CharacterScalarWhereWithAggregatesInput[]
    NOT?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Character"> | string
    name?: StringWithAggregatesFilter<"Character"> | string
    nameJa?: StringNullableWithAggregatesFilter<"Character"> | string | null
    nameZh?: StringNullableWithAggregatesFilter<"Character"> | string | null
    description?: StringNullableWithAggregatesFilter<"Character"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Character"> | string | null
    isMainCharacter?: BoolWithAggregatesFilter<"Character"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Character"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Character"> | Date | string
  }

  export type MovieCharacterWhereInput = {
    AND?: MovieCharacterWhereInput | MovieCharacterWhereInput[]
    OR?: MovieCharacterWhereInput[]
    NOT?: MovieCharacterWhereInput | MovieCharacterWhereInput[]
    id?: StringFilter<"MovieCharacter"> | string
    movieId?: StringFilter<"MovieCharacter"> | string
    characterId?: StringFilter<"MovieCharacter"> | string
    voiceActor?: StringNullableFilter<"MovieCharacter"> | string | null
    voiceActorJa?: StringNullableFilter<"MovieCharacter"> | string | null
    importance?: IntFilter<"MovieCharacter"> | number
    createdAt?: DateTimeFilter<"MovieCharacter"> | Date | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
  }

  export type MovieCharacterOrderByWithRelationInput = {
    id?: SortOrder
    movieId?: SortOrder
    characterId?: SortOrder
    voiceActor?: SortOrderInput | SortOrder
    voiceActorJa?: SortOrderInput | SortOrder
    importance?: SortOrder
    createdAt?: SortOrder
    movie?: MovieOrderByWithRelationInput
    character?: CharacterOrderByWithRelationInput
  }

  export type MovieCharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    movieId_characterId?: MovieCharacterMovieIdCharacterIdCompoundUniqueInput
    AND?: MovieCharacterWhereInput | MovieCharacterWhereInput[]
    OR?: MovieCharacterWhereInput[]
    NOT?: MovieCharacterWhereInput | MovieCharacterWhereInput[]
    movieId?: StringFilter<"MovieCharacter"> | string
    characterId?: StringFilter<"MovieCharacter"> | string
    voiceActor?: StringNullableFilter<"MovieCharacter"> | string | null
    voiceActorJa?: StringNullableFilter<"MovieCharacter"> | string | null
    importance?: IntFilter<"MovieCharacter"> | number
    createdAt?: DateTimeFilter<"MovieCharacter"> | Date | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
  }, "id" | "movieId_characterId">

  export type MovieCharacterOrderByWithAggregationInput = {
    id?: SortOrder
    movieId?: SortOrder
    characterId?: SortOrder
    voiceActor?: SortOrderInput | SortOrder
    voiceActorJa?: SortOrderInput | SortOrder
    importance?: SortOrder
    createdAt?: SortOrder
    _count?: MovieCharacterCountOrderByAggregateInput
    _avg?: MovieCharacterAvgOrderByAggregateInput
    _max?: MovieCharacterMaxOrderByAggregateInput
    _min?: MovieCharacterMinOrderByAggregateInput
    _sum?: MovieCharacterSumOrderByAggregateInput
  }

  export type MovieCharacterScalarWhereWithAggregatesInput = {
    AND?: MovieCharacterScalarWhereWithAggregatesInput | MovieCharacterScalarWhereWithAggregatesInput[]
    OR?: MovieCharacterScalarWhereWithAggregatesInput[]
    NOT?: MovieCharacterScalarWhereWithAggregatesInput | MovieCharacterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MovieCharacter"> | string
    movieId?: StringWithAggregatesFilter<"MovieCharacter"> | string
    characterId?: StringWithAggregatesFilter<"MovieCharacter"> | string
    voiceActor?: StringNullableWithAggregatesFilter<"MovieCharacter"> | string | null
    voiceActorJa?: StringNullableWithAggregatesFilter<"MovieCharacter"> | string | null
    importance?: IntWithAggregatesFilter<"MovieCharacter"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MovieCharacter"> | Date | string
  }

  export type CrewMemberWhereInput = {
    AND?: CrewMemberWhereInput | CrewMemberWhereInput[]
    OR?: CrewMemberWhereInput[]
    NOT?: CrewMemberWhereInput | CrewMemberWhereInput[]
    id?: StringFilter<"CrewMember"> | string
    name?: StringFilter<"CrewMember"> | string
    nameJa?: StringNullableFilter<"CrewMember"> | string | null
    biography?: StringNullableFilter<"CrewMember"> | string | null
    imageUrl?: StringNullableFilter<"CrewMember"> | string | null
    birthDate?: DateTimeNullableFilter<"CrewMember"> | Date | string | null
    nationality?: StringNullableFilter<"CrewMember"> | string | null
    createdAt?: DateTimeFilter<"CrewMember"> | Date | string
    updatedAt?: DateTimeFilter<"CrewMember"> | Date | string
    movieCrew?: MovieCrewListRelationFilter
  }

  export type CrewMemberOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrderInput | SortOrder
    biography?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movieCrew?: MovieCrewOrderByRelationAggregateInput
  }

  export type CrewMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrewMemberWhereInput | CrewMemberWhereInput[]
    OR?: CrewMemberWhereInput[]
    NOT?: CrewMemberWhereInput | CrewMemberWhereInput[]
    name?: StringFilter<"CrewMember"> | string
    nameJa?: StringNullableFilter<"CrewMember"> | string | null
    biography?: StringNullableFilter<"CrewMember"> | string | null
    imageUrl?: StringNullableFilter<"CrewMember"> | string | null
    birthDate?: DateTimeNullableFilter<"CrewMember"> | Date | string | null
    nationality?: StringNullableFilter<"CrewMember"> | string | null
    createdAt?: DateTimeFilter<"CrewMember"> | Date | string
    updatedAt?: DateTimeFilter<"CrewMember"> | Date | string
    movieCrew?: MovieCrewListRelationFilter
  }, "id">

  export type CrewMemberOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrderInput | SortOrder
    biography?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CrewMemberCountOrderByAggregateInput
    _max?: CrewMemberMaxOrderByAggregateInput
    _min?: CrewMemberMinOrderByAggregateInput
  }

  export type CrewMemberScalarWhereWithAggregatesInput = {
    AND?: CrewMemberScalarWhereWithAggregatesInput | CrewMemberScalarWhereWithAggregatesInput[]
    OR?: CrewMemberScalarWhereWithAggregatesInput[]
    NOT?: CrewMemberScalarWhereWithAggregatesInput | CrewMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrewMember"> | string
    name?: StringWithAggregatesFilter<"CrewMember"> | string
    nameJa?: StringNullableWithAggregatesFilter<"CrewMember"> | string | null
    biography?: StringNullableWithAggregatesFilter<"CrewMember"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"CrewMember"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"CrewMember"> | Date | string | null
    nationality?: StringNullableWithAggregatesFilter<"CrewMember"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CrewMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CrewMember"> | Date | string
  }

  export type MovieCrewWhereInput = {
    AND?: MovieCrewWhereInput | MovieCrewWhereInput[]
    OR?: MovieCrewWhereInput[]
    NOT?: MovieCrewWhereInput | MovieCrewWhereInput[]
    id?: StringFilter<"MovieCrew"> | string
    movieId?: StringFilter<"MovieCrew"> | string
    crewMemberId?: StringFilter<"MovieCrew"> | string
    role?: EnumCrewRoleFilter<"MovieCrew"> | $Enums.CrewRole
    department?: StringNullableFilter<"MovieCrew"> | string | null
    createdAt?: DateTimeFilter<"MovieCrew"> | Date | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
    crewMember?: XOR<CrewMemberScalarRelationFilter, CrewMemberWhereInput>
  }

  export type MovieCrewOrderByWithRelationInput = {
    id?: SortOrder
    movieId?: SortOrder
    crewMemberId?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    movie?: MovieOrderByWithRelationInput
    crewMember?: CrewMemberOrderByWithRelationInput
  }

  export type MovieCrewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    movieId_crewMemberId_role?: MovieCrewMovieIdCrewMemberIdRoleCompoundUniqueInput
    AND?: MovieCrewWhereInput | MovieCrewWhereInput[]
    OR?: MovieCrewWhereInput[]
    NOT?: MovieCrewWhereInput | MovieCrewWhereInput[]
    movieId?: StringFilter<"MovieCrew"> | string
    crewMemberId?: StringFilter<"MovieCrew"> | string
    role?: EnumCrewRoleFilter<"MovieCrew"> | $Enums.CrewRole
    department?: StringNullableFilter<"MovieCrew"> | string | null
    createdAt?: DateTimeFilter<"MovieCrew"> | Date | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
    crewMember?: XOR<CrewMemberScalarRelationFilter, CrewMemberWhereInput>
  }, "id" | "movieId_crewMemberId_role">

  export type MovieCrewOrderByWithAggregationInput = {
    id?: SortOrder
    movieId?: SortOrder
    crewMemberId?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MovieCrewCountOrderByAggregateInput
    _max?: MovieCrewMaxOrderByAggregateInput
    _min?: MovieCrewMinOrderByAggregateInput
  }

  export type MovieCrewScalarWhereWithAggregatesInput = {
    AND?: MovieCrewScalarWhereWithAggregatesInput | MovieCrewScalarWhereWithAggregatesInput[]
    OR?: MovieCrewScalarWhereWithAggregatesInput[]
    NOT?: MovieCrewScalarWhereWithAggregatesInput | MovieCrewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MovieCrew"> | string
    movieId?: StringWithAggregatesFilter<"MovieCrew"> | string
    crewMemberId?: StringWithAggregatesFilter<"MovieCrew"> | string
    role?: EnumCrewRoleWithAggregatesFilter<"MovieCrew"> | $Enums.CrewRole
    department?: StringNullableWithAggregatesFilter<"MovieCrew"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MovieCrew"> | Date | string
  }

  export type MovieReviewWhereInput = {
    AND?: MovieReviewWhereInput | MovieReviewWhereInput[]
    OR?: MovieReviewWhereInput[]
    NOT?: MovieReviewWhereInput | MovieReviewWhereInput[]
    id?: StringFilter<"MovieReview"> | string
    movieId?: StringFilter<"MovieReview"> | string
    title?: StringFilter<"MovieReview"> | string
    content?: StringFilter<"MovieReview"> | string
    author?: StringFilter<"MovieReview"> | string
    rating?: FloatNullableFilter<"MovieReview"> | number | null
    reviewType?: EnumReviewTypeFilter<"MovieReview"> | $Enums.ReviewType
    language?: StringFilter<"MovieReview"> | string
    isPublished?: BoolFilter<"MovieReview"> | boolean
    publishedAt?: DateTimeNullableFilter<"MovieReview"> | Date | string | null
    createdAt?: DateTimeFilter<"MovieReview"> | Date | string
    updatedAt?: DateTimeFilter<"MovieReview"> | Date | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
  }

  export type MovieReviewOrderByWithRelationInput = {
    id?: SortOrder
    movieId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    author?: SortOrder
    rating?: SortOrderInput | SortOrder
    reviewType?: SortOrder
    language?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movie?: MovieOrderByWithRelationInput
  }

  export type MovieReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MovieReviewWhereInput | MovieReviewWhereInput[]
    OR?: MovieReviewWhereInput[]
    NOT?: MovieReviewWhereInput | MovieReviewWhereInput[]
    movieId?: StringFilter<"MovieReview"> | string
    title?: StringFilter<"MovieReview"> | string
    content?: StringFilter<"MovieReview"> | string
    author?: StringFilter<"MovieReview"> | string
    rating?: FloatNullableFilter<"MovieReview"> | number | null
    reviewType?: EnumReviewTypeFilter<"MovieReview"> | $Enums.ReviewType
    language?: StringFilter<"MovieReview"> | string
    isPublished?: BoolFilter<"MovieReview"> | boolean
    publishedAt?: DateTimeNullableFilter<"MovieReview"> | Date | string | null
    createdAt?: DateTimeFilter<"MovieReview"> | Date | string
    updatedAt?: DateTimeFilter<"MovieReview"> | Date | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
  }, "id">

  export type MovieReviewOrderByWithAggregationInput = {
    id?: SortOrder
    movieId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    author?: SortOrder
    rating?: SortOrderInput | SortOrder
    reviewType?: SortOrder
    language?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MovieReviewCountOrderByAggregateInput
    _avg?: MovieReviewAvgOrderByAggregateInput
    _max?: MovieReviewMaxOrderByAggregateInput
    _min?: MovieReviewMinOrderByAggregateInput
    _sum?: MovieReviewSumOrderByAggregateInput
  }

  export type MovieReviewScalarWhereWithAggregatesInput = {
    AND?: MovieReviewScalarWhereWithAggregatesInput | MovieReviewScalarWhereWithAggregatesInput[]
    OR?: MovieReviewScalarWhereWithAggregatesInput[]
    NOT?: MovieReviewScalarWhereWithAggregatesInput | MovieReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MovieReview"> | string
    movieId?: StringWithAggregatesFilter<"MovieReview"> | string
    title?: StringWithAggregatesFilter<"MovieReview"> | string
    content?: StringWithAggregatesFilter<"MovieReview"> | string
    author?: StringWithAggregatesFilter<"MovieReview"> | string
    rating?: FloatNullableWithAggregatesFilter<"MovieReview"> | number | null
    reviewType?: EnumReviewTypeWithAggregatesFilter<"MovieReview"> | $Enums.ReviewType
    language?: StringWithAggregatesFilter<"MovieReview"> | string
    isPublished?: BoolWithAggregatesFilter<"MovieReview"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"MovieReview"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MovieReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MovieReview"> | Date | string
  }

  export type WatchGuideWhereInput = {
    AND?: WatchGuideWhereInput | WatchGuideWhereInput[]
    OR?: WatchGuideWhereInput[]
    NOT?: WatchGuideWhereInput | WatchGuideWhereInput[]
    id?: StringFilter<"WatchGuide"> | string
    title?: StringFilter<"WatchGuide"> | string
    description?: StringFilter<"WatchGuide"> | string
    guideType?: EnumGuideTypeFilter<"WatchGuide"> | $Enums.GuideType
    content?: JsonFilter<"WatchGuide">
    order?: IntFilter<"WatchGuide"> | number
    isPublished?: BoolFilter<"WatchGuide"> | boolean
    language?: StringFilter<"WatchGuide"> | string
    createdAt?: DateTimeFilter<"WatchGuide"> | Date | string
    updatedAt?: DateTimeFilter<"WatchGuide"> | Date | string
    movies?: WatchGuideMovieListRelationFilter
  }

  export type WatchGuideOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    guideType?: SortOrder
    content?: SortOrder
    order?: SortOrder
    isPublished?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movies?: WatchGuideMovieOrderByRelationAggregateInput
  }

  export type WatchGuideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WatchGuideWhereInput | WatchGuideWhereInput[]
    OR?: WatchGuideWhereInput[]
    NOT?: WatchGuideWhereInput | WatchGuideWhereInput[]
    title?: StringFilter<"WatchGuide"> | string
    description?: StringFilter<"WatchGuide"> | string
    guideType?: EnumGuideTypeFilter<"WatchGuide"> | $Enums.GuideType
    content?: JsonFilter<"WatchGuide">
    order?: IntFilter<"WatchGuide"> | number
    isPublished?: BoolFilter<"WatchGuide"> | boolean
    language?: StringFilter<"WatchGuide"> | string
    createdAt?: DateTimeFilter<"WatchGuide"> | Date | string
    updatedAt?: DateTimeFilter<"WatchGuide"> | Date | string
    movies?: WatchGuideMovieListRelationFilter
  }, "id">

  export type WatchGuideOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    guideType?: SortOrder
    content?: SortOrder
    order?: SortOrder
    isPublished?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WatchGuideCountOrderByAggregateInput
    _avg?: WatchGuideAvgOrderByAggregateInput
    _max?: WatchGuideMaxOrderByAggregateInput
    _min?: WatchGuideMinOrderByAggregateInput
    _sum?: WatchGuideSumOrderByAggregateInput
  }

  export type WatchGuideScalarWhereWithAggregatesInput = {
    AND?: WatchGuideScalarWhereWithAggregatesInput | WatchGuideScalarWhereWithAggregatesInput[]
    OR?: WatchGuideScalarWhereWithAggregatesInput[]
    NOT?: WatchGuideScalarWhereWithAggregatesInput | WatchGuideScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WatchGuide"> | string
    title?: StringWithAggregatesFilter<"WatchGuide"> | string
    description?: StringWithAggregatesFilter<"WatchGuide"> | string
    guideType?: EnumGuideTypeWithAggregatesFilter<"WatchGuide"> | $Enums.GuideType
    content?: JsonWithAggregatesFilter<"WatchGuide">
    order?: IntWithAggregatesFilter<"WatchGuide"> | number
    isPublished?: BoolWithAggregatesFilter<"WatchGuide"> | boolean
    language?: StringWithAggregatesFilter<"WatchGuide"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WatchGuide"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WatchGuide"> | Date | string
  }

  export type WatchGuideMovieWhereInput = {
    AND?: WatchGuideMovieWhereInput | WatchGuideMovieWhereInput[]
    OR?: WatchGuideMovieWhereInput[]
    NOT?: WatchGuideMovieWhereInput | WatchGuideMovieWhereInput[]
    id?: StringFilter<"WatchGuideMovie"> | string
    guideId?: StringFilter<"WatchGuideMovie"> | string
    movieId?: StringFilter<"WatchGuideMovie"> | string
    order?: IntFilter<"WatchGuideMovie"> | number
    notes?: StringNullableFilter<"WatchGuideMovie"> | string | null
    createdAt?: DateTimeFilter<"WatchGuideMovie"> | Date | string
    guide?: XOR<WatchGuideScalarRelationFilter, WatchGuideWhereInput>
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
  }

  export type WatchGuideMovieOrderByWithRelationInput = {
    id?: SortOrder
    guideId?: SortOrder
    movieId?: SortOrder
    order?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    guide?: WatchGuideOrderByWithRelationInput
    movie?: MovieOrderByWithRelationInput
  }

  export type WatchGuideMovieWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    guideId_movieId?: WatchGuideMovieGuideIdMovieIdCompoundUniqueInput
    AND?: WatchGuideMovieWhereInput | WatchGuideMovieWhereInput[]
    OR?: WatchGuideMovieWhereInput[]
    NOT?: WatchGuideMovieWhereInput | WatchGuideMovieWhereInput[]
    guideId?: StringFilter<"WatchGuideMovie"> | string
    movieId?: StringFilter<"WatchGuideMovie"> | string
    order?: IntFilter<"WatchGuideMovie"> | number
    notes?: StringNullableFilter<"WatchGuideMovie"> | string | null
    createdAt?: DateTimeFilter<"WatchGuideMovie"> | Date | string
    guide?: XOR<WatchGuideScalarRelationFilter, WatchGuideWhereInput>
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
  }, "id" | "guideId_movieId">

  export type WatchGuideMovieOrderByWithAggregationInput = {
    id?: SortOrder
    guideId?: SortOrder
    movieId?: SortOrder
    order?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WatchGuideMovieCountOrderByAggregateInput
    _avg?: WatchGuideMovieAvgOrderByAggregateInput
    _max?: WatchGuideMovieMaxOrderByAggregateInput
    _min?: WatchGuideMovieMinOrderByAggregateInput
    _sum?: WatchGuideMovieSumOrderByAggregateInput
  }

  export type WatchGuideMovieScalarWhereWithAggregatesInput = {
    AND?: WatchGuideMovieScalarWhereWithAggregatesInput | WatchGuideMovieScalarWhereWithAggregatesInput[]
    OR?: WatchGuideMovieScalarWhereWithAggregatesInput[]
    NOT?: WatchGuideMovieScalarWhereWithAggregatesInput | WatchGuideMovieScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WatchGuideMovie"> | string
    guideId?: StringWithAggregatesFilter<"WatchGuideMovie"> | string
    movieId?: StringWithAggregatesFilter<"WatchGuideMovie"> | string
    order?: IntWithAggregatesFilter<"WatchGuideMovie"> | number
    notes?: StringNullableWithAggregatesFilter<"WatchGuideMovie"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WatchGuideMovie"> | Date | string
  }

  export type MediaContentWhereInput = {
    AND?: MediaContentWhereInput | MediaContentWhereInput[]
    OR?: MediaContentWhereInput[]
    NOT?: MediaContentWhereInput | MediaContentWhereInput[]
    id?: StringFilter<"MediaContent"> | string
    movieId?: StringNullableFilter<"MediaContent"> | string | null
    title?: StringFilter<"MediaContent"> | string
    description?: StringNullableFilter<"MediaContent"> | string | null
    mediaType?: EnumMediaTypeFilter<"MediaContent"> | $Enums.MediaType
    url?: StringFilter<"MediaContent"> | string
    thumbnailUrl?: StringNullableFilter<"MediaContent"> | string | null
    duration?: IntNullableFilter<"MediaContent"> | number | null
    fileSize?: IntNullableFilter<"MediaContent"> | number | null
    language?: StringNullableFilter<"MediaContent"> | string | null
    isPublished?: BoolFilter<"MediaContent"> | boolean
    createdAt?: DateTimeFilter<"MediaContent"> | Date | string
    updatedAt?: DateTimeFilter<"MediaContent"> | Date | string
    movie?: XOR<MovieNullableScalarRelationFilter, MovieWhereInput> | null
  }

  export type MediaContentOrderByWithRelationInput = {
    id?: SortOrder
    movieId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movie?: MovieOrderByWithRelationInput
  }

  export type MediaContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaContentWhereInput | MediaContentWhereInput[]
    OR?: MediaContentWhereInput[]
    NOT?: MediaContentWhereInput | MediaContentWhereInput[]
    movieId?: StringNullableFilter<"MediaContent"> | string | null
    title?: StringFilter<"MediaContent"> | string
    description?: StringNullableFilter<"MediaContent"> | string | null
    mediaType?: EnumMediaTypeFilter<"MediaContent"> | $Enums.MediaType
    url?: StringFilter<"MediaContent"> | string
    thumbnailUrl?: StringNullableFilter<"MediaContent"> | string | null
    duration?: IntNullableFilter<"MediaContent"> | number | null
    fileSize?: IntNullableFilter<"MediaContent"> | number | null
    language?: StringNullableFilter<"MediaContent"> | string | null
    isPublished?: BoolFilter<"MediaContent"> | boolean
    createdAt?: DateTimeFilter<"MediaContent"> | Date | string
    updatedAt?: DateTimeFilter<"MediaContent"> | Date | string
    movie?: XOR<MovieNullableScalarRelationFilter, MovieWhereInput> | null
  }, "id">

  export type MediaContentOrderByWithAggregationInput = {
    id?: SortOrder
    movieId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaContentCountOrderByAggregateInput
    _avg?: MediaContentAvgOrderByAggregateInput
    _max?: MediaContentMaxOrderByAggregateInput
    _min?: MediaContentMinOrderByAggregateInput
    _sum?: MediaContentSumOrderByAggregateInput
  }

  export type MediaContentScalarWhereWithAggregatesInput = {
    AND?: MediaContentScalarWhereWithAggregatesInput | MediaContentScalarWhereWithAggregatesInput[]
    OR?: MediaContentScalarWhereWithAggregatesInput[]
    NOT?: MediaContentScalarWhereWithAggregatesInput | MediaContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MediaContent"> | string
    movieId?: StringNullableWithAggregatesFilter<"MediaContent"> | string | null
    title?: StringWithAggregatesFilter<"MediaContent"> | string
    description?: StringNullableWithAggregatesFilter<"MediaContent"> | string | null
    mediaType?: EnumMediaTypeWithAggregatesFilter<"MediaContent"> | $Enums.MediaType
    url?: StringWithAggregatesFilter<"MediaContent"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"MediaContent"> | string | null
    duration?: IntNullableWithAggregatesFilter<"MediaContent"> | number | null
    fileSize?: IntNullableWithAggregatesFilter<"MediaContent"> | number | null
    language?: StringNullableWithAggregatesFilter<"MediaContent"> | string | null
    isPublished?: BoolWithAggregatesFilter<"MediaContent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MediaContent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MediaContent"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    nameJa?: StringNullableFilter<"Tag"> | string | null
    nameZh?: StringNullableFilter<"Tag"> | string | null
    description?: StringNullableFilter<"Tag"> | string | null
    color?: StringNullableFilter<"Tag"> | string | null
    category?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    movieTags?: MovieTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrderInput | SortOrder
    nameZh?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    movieTags?: MovieTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    nameJa?: StringNullableFilter<"Tag"> | string | null
    nameZh?: StringNullableFilter<"Tag"> | string | null
    description?: StringNullableFilter<"Tag"> | string | null
    color?: StringNullableFilter<"Tag"> | string | null
    category?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    movieTags?: MovieTagListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrderInput | SortOrder
    nameZh?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    nameJa?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    nameZh?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    color?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    category?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type MovieTagWhereInput = {
    AND?: MovieTagWhereInput | MovieTagWhereInput[]
    OR?: MovieTagWhereInput[]
    NOT?: MovieTagWhereInput | MovieTagWhereInput[]
    id?: StringFilter<"MovieTag"> | string
    movieId?: StringFilter<"MovieTag"> | string
    tagId?: StringFilter<"MovieTag"> | string
    createdAt?: DateTimeFilter<"MovieTag"> | Date | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type MovieTagOrderByWithRelationInput = {
    id?: SortOrder
    movieId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    movie?: MovieOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type MovieTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    movieId_tagId?: MovieTagMovieIdTagIdCompoundUniqueInput
    AND?: MovieTagWhereInput | MovieTagWhereInput[]
    OR?: MovieTagWhereInput[]
    NOT?: MovieTagWhereInput | MovieTagWhereInput[]
    movieId?: StringFilter<"MovieTag"> | string
    tagId?: StringFilter<"MovieTag"> | string
    createdAt?: DateTimeFilter<"MovieTag"> | Date | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "movieId_tagId">

  export type MovieTagOrderByWithAggregationInput = {
    id?: SortOrder
    movieId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    _count?: MovieTagCountOrderByAggregateInput
    _max?: MovieTagMaxOrderByAggregateInput
    _min?: MovieTagMinOrderByAggregateInput
  }

  export type MovieTagScalarWhereWithAggregatesInput = {
    AND?: MovieTagScalarWhereWithAggregatesInput | MovieTagScalarWhereWithAggregatesInput[]
    OR?: MovieTagScalarWhereWithAggregatesInput[]
    NOT?: MovieTagScalarWhereWithAggregatesInput | MovieTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MovieTag"> | string
    movieId?: StringWithAggregatesFilter<"MovieTag"> | string
    tagId?: StringWithAggregatesFilter<"MovieTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MovieTag"> | Date | string
  }

  export type UserFavoriteWhereInput = {
    AND?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    OR?: UserFavoriteWhereInput[]
    NOT?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    id?: StringFilter<"UserFavorite"> | string
    userId?: StringFilter<"UserFavorite"> | string
    movieId?: StringFilter<"UserFavorite"> | string
    createdAt?: DateTimeFilter<"UserFavorite"> | Date | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
  }

  export type UserFavoriteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    createdAt?: SortOrder
    movie?: MovieOrderByWithRelationInput
  }

  export type UserFavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_movieId?: UserFavoriteUserIdMovieIdCompoundUniqueInput
    AND?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    OR?: UserFavoriteWhereInput[]
    NOT?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    userId?: StringFilter<"UserFavorite"> | string
    movieId?: StringFilter<"UserFavorite"> | string
    createdAt?: DateTimeFilter<"UserFavorite"> | Date | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
  }, "id" | "userId_movieId">

  export type UserFavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    createdAt?: SortOrder
    _count?: UserFavoriteCountOrderByAggregateInput
    _max?: UserFavoriteMaxOrderByAggregateInput
    _min?: UserFavoriteMinOrderByAggregateInput
  }

  export type UserFavoriteScalarWhereWithAggregatesInput = {
    AND?: UserFavoriteScalarWhereWithAggregatesInput | UserFavoriteScalarWhereWithAggregatesInput[]
    OR?: UserFavoriteScalarWhereWithAggregatesInput[]
    NOT?: UserFavoriteScalarWhereWithAggregatesInput | UserFavoriteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFavorite"> | string
    userId?: StringWithAggregatesFilter<"UserFavorite"> | string
    movieId?: StringWithAggregatesFilter<"UserFavorite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserFavorite"> | Date | string
  }

  export type MovieStatsWhereInput = {
    AND?: MovieStatsWhereInput | MovieStatsWhereInput[]
    OR?: MovieStatsWhereInput[]
    NOT?: MovieStatsWhereInput | MovieStatsWhereInput[]
    id?: StringFilter<"MovieStats"> | string
    movieId?: StringFilter<"MovieStats"> | string
    viewCount?: IntFilter<"MovieStats"> | number
    favoriteCount?: IntFilter<"MovieStats"> | number
    shareCount?: IntFilter<"MovieStats"> | number
    lastViewed?: DateTimeNullableFilter<"MovieStats"> | Date | string | null
    updatedAt?: DateTimeFilter<"MovieStats"> | Date | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
  }

  export type MovieStatsOrderByWithRelationInput = {
    id?: SortOrder
    movieId?: SortOrder
    viewCount?: SortOrder
    favoriteCount?: SortOrder
    shareCount?: SortOrder
    lastViewed?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    movie?: MovieOrderByWithRelationInput
  }

  export type MovieStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    movieId?: string
    AND?: MovieStatsWhereInput | MovieStatsWhereInput[]
    OR?: MovieStatsWhereInput[]
    NOT?: MovieStatsWhereInput | MovieStatsWhereInput[]
    viewCount?: IntFilter<"MovieStats"> | number
    favoriteCount?: IntFilter<"MovieStats"> | number
    shareCount?: IntFilter<"MovieStats"> | number
    lastViewed?: DateTimeNullableFilter<"MovieStats"> | Date | string | null
    updatedAt?: DateTimeFilter<"MovieStats"> | Date | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
  }, "id" | "movieId">

  export type MovieStatsOrderByWithAggregationInput = {
    id?: SortOrder
    movieId?: SortOrder
    viewCount?: SortOrder
    favoriteCount?: SortOrder
    shareCount?: SortOrder
    lastViewed?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: MovieStatsCountOrderByAggregateInput
    _avg?: MovieStatsAvgOrderByAggregateInput
    _max?: MovieStatsMaxOrderByAggregateInput
    _min?: MovieStatsMinOrderByAggregateInput
    _sum?: MovieStatsSumOrderByAggregateInput
  }

  export type MovieStatsScalarWhereWithAggregatesInput = {
    AND?: MovieStatsScalarWhereWithAggregatesInput | MovieStatsScalarWhereWithAggregatesInput[]
    OR?: MovieStatsScalarWhereWithAggregatesInput[]
    NOT?: MovieStatsScalarWhereWithAggregatesInput | MovieStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MovieStats"> | string
    movieId?: StringWithAggregatesFilter<"MovieStats"> | string
    viewCount?: IntWithAggregatesFilter<"MovieStats"> | number
    favoriteCount?: IntWithAggregatesFilter<"MovieStats"> | number
    shareCount?: IntWithAggregatesFilter<"MovieStats"> | number
    lastViewed?: DateTimeNullableWithAggregatesFilter<"MovieStats"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"MovieStats"> | Date | string
  }

  export type MovieCreateInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteCreateNestedManyWithoutMovieInput
    stats?: MovieStatsCreateNestedOneWithoutMovieInput
  }

  export type MovieUncheckedCreateInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterUncheckedCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewUncheckedCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewUncheckedCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieUncheckedCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentUncheckedCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagUncheckedCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutMovieInput
    stats?: MovieStatsUncheckedCreateNestedOneWithoutMovieInput
  }

  export type MovieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUpdateOneWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUncheckedUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUncheckedUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUncheckedUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUncheckedUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUncheckedUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUncheckedUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUncheckedUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUncheckedUpdateOneWithoutMovieNestedInput
  }

  export type MovieCreateManyInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformCreateInput = {
    id?: string
    name: string
    website: string
    type: $Enums.PlatformType
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityCreateNestedManyWithoutPlatformInput
  }

  export type PlatformUncheckedCreateInput = {
    id?: string
    name: string
    website: string
    type: $Enums.PlatformType
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutPlatformInput
  }

  export type PlatformUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    type?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    type?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUncheckedUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformCreateManyInput = {
    id?: string
    name: string
    website: string
    type: $Enums.PlatformType
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    type?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    type?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionCreateInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionCreateManyInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityCreateInput = {
    id?: string
    url?: string | null
    price?: number | null
    currency?: string | null
    type: $Enums.AvailabilityType
    lastChecked: Date | string
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movie: MovieCreateNestedOneWithoutAvailabilitiesInput
    platform: PlatformCreateNestedOneWithoutAvailabilitiesInput
    region: RegionCreateNestedOneWithoutAvailabilitiesInput
  }

  export type AvailabilityUncheckedCreateInput = {
    id?: string
    url?: string | null
    price?: number | null
    currency?: string | null
    type: $Enums.AvailabilityType
    lastChecked: Date | string
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movieId: string
    platformId: string
    regionId: string
  }

  export type AvailabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutAvailabilitiesNestedInput
    platform?: PlatformUpdateOneRequiredWithoutAvailabilitiesNestedInput
    region?: RegionUpdateOneRequiredWithoutAvailabilitiesNestedInput
  }

  export type AvailabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
  }

  export type AvailabilityCreateManyInput = {
    id?: string
    url?: string | null
    price?: number | null
    currency?: string | null
    type: $Enums.AvailabilityType
    lastChecked: Date | string
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movieId: string
    platformId: string
    regionId: string
  }

  export type AvailabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
  }

  export type ContentVersionCreateInput = {
    id?: string
    entityType: string
    entityId: string
    version: number
    changes: JsonNullValueInput | InputJsonValue
    changeType: $Enums.ChangeType
    author?: string | null
    reason?: string | null
    isActive?: boolean
    createdAt?: Date | string
    reviews?: ContentReviewCreateNestedManyWithoutVersionInput
  }

  export type ContentVersionUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    version: number
    changes: JsonNullValueInput | InputJsonValue
    changeType: $Enums.ChangeType
    author?: string | null
    reason?: string | null
    isActive?: boolean
    createdAt?: Date | string
    reviews?: ContentReviewUncheckedCreateNestedManyWithoutVersionInput
  }

  export type ContentVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    author?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ContentReviewUpdateManyWithoutVersionNestedInput
  }

  export type ContentVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    author?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ContentReviewUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type ContentVersionCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    version: number
    changes: JsonNullValueInput | InputJsonValue
    changeType: $Enums.ChangeType
    author?: string | null
    reason?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ContentVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    author?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    author?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentReviewCreateInput = {
    id?: string
    entityType: string
    entityId: string
    status: $Enums.ReviewStatus
    reviewer?: string | null
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    version: ContentVersionCreateNestedOneWithoutReviewsInput
  }

  export type ContentReviewUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    versionId: string
    status: $Enums.ReviewStatus
    reviewer?: string | null
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ContentReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: ContentVersionUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ContentReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentReviewCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    versionId: string
    status: $Enums.ReviewStatus
    reviewer?: string | null
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ContentReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentUpdateTaskCreateInput = {
    id?: string
    taskType: $Enums.TaskType
    entityType?: string | null
    entityId?: string | null
    priority: $Enums.Priority
    status: $Enums.TaskStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentUpdateTaskUncheckedCreateInput = {
    id?: string
    taskType: $Enums.TaskType
    entityType?: string | null
    entityId?: string | null
    priority: $Enums.Priority
    status: $Enums.TaskStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentUpdateTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentUpdateTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentUpdateTaskCreateManyInput = {
    id?: string
    taskType: $Enums.TaskType
    entityType?: string | null
    entityId?: string | null
    priority: $Enums.Priority
    status: $Enums.TaskStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentUpdateTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentUpdateTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentQualityMetricCreateInput = {
    id?: string
    entityType: string
    entityId: string
    metricType: string
    score: number
    details?: NullableJsonNullValueInput | InputJsonValue
    measuredAt?: Date | string
  }

  export type ContentQualityMetricUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    metricType: string
    score: number
    details?: NullableJsonNullValueInput | InputJsonValue
    measuredAt?: Date | string
  }

  export type ContentQualityMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentQualityMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentQualityMetricCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    metricType: string
    score: number
    details?: NullableJsonNullValueInput | InputJsonValue
    measuredAt?: Date | string
  }

  export type ContentQualityMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentQualityMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackCreateInput = {
    id?: string
    entityType: string
    entityId: string
    feedbackType: $Enums.FeedbackType
    content: string
    userAgent?: string | null
    ipAddress?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserFeedbackUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    feedbackType: $Enums.FeedbackType
    content: string
    userAgent?: string | null
    ipAddress?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    content?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    content?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    feedbackType: $Enums.FeedbackType
    content: string
    userAgent?: string | null
    ipAddress?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    content?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    content?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentSyncLogCreateInput = {
    id?: string
    source: string
    syncType: $Enums.SyncType
    status: $Enums.SyncStatus
    recordsProcessed?: number
    recordsUpdated?: number
    recordsCreated?: number
    recordsFailed?: number
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ContentSyncLogUncheckedCreateInput = {
    id?: string
    source: string
    syncType: $Enums.SyncType
    status: $Enums.SyncStatus
    recordsProcessed?: number
    recordsUpdated?: number
    recordsCreated?: number
    recordsFailed?: number
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ContentSyncLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    recordsProcessed?: IntFieldUpdateOperationsInput | number
    recordsUpdated?: IntFieldUpdateOperationsInput | number
    recordsCreated?: IntFieldUpdateOperationsInput | number
    recordsFailed?: IntFieldUpdateOperationsInput | number
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentSyncLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    recordsProcessed?: IntFieldUpdateOperationsInput | number
    recordsUpdated?: IntFieldUpdateOperationsInput | number
    recordsCreated?: IntFieldUpdateOperationsInput | number
    recordsFailed?: IntFieldUpdateOperationsInput | number
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentSyncLogCreateManyInput = {
    id?: string
    source: string
    syncType: $Enums.SyncType
    status: $Enums.SyncStatus
    recordsProcessed?: number
    recordsUpdated?: number
    recordsCreated?: number
    recordsFailed?: number
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ContentSyncLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    recordsProcessed?: IntFieldUpdateOperationsInput | number
    recordsUpdated?: IntFieldUpdateOperationsInput | number
    recordsCreated?: IntFieldUpdateOperationsInput | number
    recordsFailed?: IntFieldUpdateOperationsInput | number
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentSyncLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    recordsProcessed?: IntFieldUpdateOperationsInput | number
    recordsUpdated?: IntFieldUpdateOperationsInput | number
    recordsCreated?: IntFieldUpdateOperationsInput | number
    recordsFailed?: IntFieldUpdateOperationsInput | number
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterCreateInput = {
    id?: string
    name: string
    nameJa?: string | null
    nameZh?: string | null
    description?: string | null
    imageUrl?: string | null
    isMainCharacter?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    movieCharacters?: MovieCharacterCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateInput = {
    id?: string
    name: string
    nameJa?: string | null
    nameZh?: string | null
    description?: string | null
    imageUrl?: string | null
    isMainCharacter?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    movieCharacters?: MovieCharacterUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isMainCharacter?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieCharacters?: MovieCharacterUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isMainCharacter?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieCharacters?: MovieCharacterUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterCreateManyInput = {
    id?: string
    name: string
    nameJa?: string | null
    nameZh?: string | null
    description?: string | null
    imageUrl?: string | null
    isMainCharacter?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isMainCharacter?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isMainCharacter?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCharacterCreateInput = {
    id?: string
    voiceActor?: string | null
    voiceActorJa?: string | null
    importance?: number
    createdAt?: Date | string
    movie: MovieCreateNestedOneWithoutMovieCharactersInput
    character: CharacterCreateNestedOneWithoutMovieCharactersInput
  }

  export type MovieCharacterUncheckedCreateInput = {
    id?: string
    movieId: string
    characterId: string
    voiceActor?: string | null
    voiceActorJa?: string | null
    importance?: number
    createdAt?: Date | string
  }

  export type MovieCharacterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voiceActor?: NullableStringFieldUpdateOperationsInput | string | null
    voiceActorJa?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutMovieCharactersNestedInput
    character?: CharacterUpdateOneRequiredWithoutMovieCharactersNestedInput
  }

  export type MovieCharacterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    voiceActor?: NullableStringFieldUpdateOperationsInput | string | null
    voiceActorJa?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCharacterCreateManyInput = {
    id?: string
    movieId: string
    characterId: string
    voiceActor?: string | null
    voiceActorJa?: string | null
    importance?: number
    createdAt?: Date | string
  }

  export type MovieCharacterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    voiceActor?: NullableStringFieldUpdateOperationsInput | string | null
    voiceActorJa?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCharacterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    voiceActor?: NullableStringFieldUpdateOperationsInput | string | null
    voiceActorJa?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewMemberCreateInput = {
    id?: string
    name: string
    nameJa?: string | null
    biography?: string | null
    imageUrl?: string | null
    birthDate?: Date | string | null
    nationality?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movieCrew?: MovieCrewCreateNestedManyWithoutCrewMemberInput
  }

  export type CrewMemberUncheckedCreateInput = {
    id?: string
    name: string
    nameJa?: string | null
    biography?: string | null
    imageUrl?: string | null
    birthDate?: Date | string | null
    nationality?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movieCrew?: MovieCrewUncheckedCreateNestedManyWithoutCrewMemberInput
  }

  export type CrewMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieCrew?: MovieCrewUpdateManyWithoutCrewMemberNestedInput
  }

  export type CrewMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieCrew?: MovieCrewUncheckedUpdateManyWithoutCrewMemberNestedInput
  }

  export type CrewMemberCreateManyInput = {
    id?: string
    name: string
    nameJa?: string | null
    biography?: string | null
    imageUrl?: string | null
    birthDate?: Date | string | null
    nationality?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrewMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCrewCreateInput = {
    id?: string
    role: $Enums.CrewRole
    department?: string | null
    createdAt?: Date | string
    movie: MovieCreateNestedOneWithoutMovieCrewInput
    crewMember: CrewMemberCreateNestedOneWithoutMovieCrewInput
  }

  export type MovieCrewUncheckedCreateInput = {
    id?: string
    movieId: string
    crewMemberId: string
    role: $Enums.CrewRole
    department?: string | null
    createdAt?: Date | string
  }

  export type MovieCrewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCrewRoleFieldUpdateOperationsInput | $Enums.CrewRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutMovieCrewNestedInput
    crewMember?: CrewMemberUpdateOneRequiredWithoutMovieCrewNestedInput
  }

  export type MovieCrewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    crewMemberId?: StringFieldUpdateOperationsInput | string
    role?: EnumCrewRoleFieldUpdateOperationsInput | $Enums.CrewRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCrewCreateManyInput = {
    id?: string
    movieId: string
    crewMemberId: string
    role: $Enums.CrewRole
    department?: string | null
    createdAt?: Date | string
  }

  export type MovieCrewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCrewRoleFieldUpdateOperationsInput | $Enums.CrewRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCrewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    crewMemberId?: StringFieldUpdateOperationsInput | string
    role?: EnumCrewRoleFieldUpdateOperationsInput | $Enums.CrewRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieReviewCreateInput = {
    id?: string
    title: string
    content: string
    author: string
    rating?: number | null
    reviewType: $Enums.ReviewType
    language?: string
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movie: MovieCreateNestedOneWithoutReviewsInput
  }

  export type MovieReviewUncheckedCreateInput = {
    id?: string
    movieId: string
    title: string
    content: string
    author: string
    rating?: number | null
    reviewType: $Enums.ReviewType
    language?: string
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewType?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    language?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type MovieReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewType?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    language?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieReviewCreateManyInput = {
    id?: string
    movieId: string
    title: string
    content: string
    author: string
    rating?: number | null
    reviewType: $Enums.ReviewType
    language?: string
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewType?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    language?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewType?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    language?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchGuideCreateInput = {
    id?: string
    title: string
    description: string
    guideType: $Enums.GuideType
    content: JsonNullValueInput | InputJsonValue
    order?: number
    isPublished?: boolean
    language?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    movies?: WatchGuideMovieCreateNestedManyWithoutGuideInput
  }

  export type WatchGuideUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    guideType: $Enums.GuideType
    content: JsonNullValueInput | InputJsonValue
    order?: number
    isPublished?: boolean
    language?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    movies?: WatchGuideMovieUncheckedCreateNestedManyWithoutGuideInput
  }

  export type WatchGuideUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    guideType?: EnumGuideTypeFieldUpdateOperationsInput | $Enums.GuideType
    content?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movies?: WatchGuideMovieUpdateManyWithoutGuideNestedInput
  }

  export type WatchGuideUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    guideType?: EnumGuideTypeFieldUpdateOperationsInput | $Enums.GuideType
    content?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movies?: WatchGuideMovieUncheckedUpdateManyWithoutGuideNestedInput
  }

  export type WatchGuideCreateManyInput = {
    id?: string
    title: string
    description: string
    guideType: $Enums.GuideType
    content: JsonNullValueInput | InputJsonValue
    order?: number
    isPublished?: boolean
    language?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WatchGuideUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    guideType?: EnumGuideTypeFieldUpdateOperationsInput | $Enums.GuideType
    content?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchGuideUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    guideType?: EnumGuideTypeFieldUpdateOperationsInput | $Enums.GuideType
    content?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchGuideMovieCreateInput = {
    id?: string
    order: number
    notes?: string | null
    createdAt?: Date | string
    guide: WatchGuideCreateNestedOneWithoutMoviesInput
    movie: MovieCreateNestedOneWithoutGuideMoviesInput
  }

  export type WatchGuideMovieUncheckedCreateInput = {
    id?: string
    guideId: string
    movieId: string
    order: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type WatchGuideMovieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guide?: WatchGuideUpdateOneRequiredWithoutMoviesNestedInput
    movie?: MovieUpdateOneRequiredWithoutGuideMoviesNestedInput
  }

  export type WatchGuideMovieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guideId?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchGuideMovieCreateManyInput = {
    id?: string
    guideId: string
    movieId: string
    order: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type WatchGuideMovieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchGuideMovieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guideId?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaContentCreateInput = {
    id?: string
    title: string
    description?: string | null
    mediaType: $Enums.MediaType
    url: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    language?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    movie?: MovieCreateNestedOneWithoutMediaContentInput
  }

  export type MediaContentUncheckedCreateInput = {
    id?: string
    movieId?: string | null
    title: string
    description?: string | null
    mediaType: $Enums.MediaType
    url: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    language?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneWithoutMediaContentNestedInput
  }

  export type MediaContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaContentCreateManyInput = {
    id?: string
    movieId?: string | null
    title: string
    description?: string | null
    mediaType: $Enums.MediaType
    url: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    language?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    nameJa?: string | null
    nameZh?: string | null
    description?: string | null
    color?: string | null
    category?: string | null
    createdAt?: Date | string
    movieTags?: MovieTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    nameJa?: string | null
    nameZh?: string | null
    description?: string | null
    color?: string | null
    category?: string | null
    createdAt?: Date | string
    movieTags?: MovieTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTags?: MovieTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTags?: MovieTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    nameJa?: string | null
    nameZh?: string | null
    description?: string | null
    color?: string | null
    category?: string | null
    createdAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieTagCreateInput = {
    id?: string
    createdAt?: Date | string
    movie: MovieCreateNestedOneWithoutMovieTagsInput
    tag: TagCreateNestedOneWithoutMovieTagsInput
  }

  export type MovieTagUncheckedCreateInput = {
    id?: string
    movieId: string
    tagId: string
    createdAt?: Date | string
  }

  export type MovieTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutMovieTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutMovieTagsNestedInput
  }

  export type MovieTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieTagCreateManyInput = {
    id?: string
    movieId: string
    tagId: string
    createdAt?: Date | string
  }

  export type MovieTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    movie: MovieCreateNestedOneWithoutFavoritesInput
  }

  export type UserFavoriteUncheckedCreateInput = {
    id?: string
    userId: string
    movieId: string
    createdAt?: Date | string
  }

  export type UserFavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type UserFavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteCreateManyInput = {
    id?: string
    userId: string
    movieId: string
    createdAt?: Date | string
  }

  export type UserFavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieStatsCreateInput = {
    id?: string
    viewCount?: number
    favoriteCount?: number
    shareCount?: number
    lastViewed?: Date | string | null
    updatedAt?: Date | string
    movie: MovieCreateNestedOneWithoutStatsInput
  }

  export type MovieStatsUncheckedCreateInput = {
    id?: string
    movieId: string
    viewCount?: number
    favoriteCount?: number
    shareCount?: number
    lastViewed?: Date | string | null
    updatedAt?: Date | string
  }

  export type MovieStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    lastViewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutStatsNestedInput
  }

  export type MovieStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    lastViewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieStatsCreateManyInput = {
    id?: string
    movieId: string
    viewCount?: number
    favoriteCount?: number
    shareCount?: number
    lastViewed?: Date | string | null
    updatedAt?: Date | string
  }

  export type MovieStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    lastViewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    lastViewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AvailabilityListRelationFilter = {
    every?: AvailabilityWhereInput
    some?: AvailabilityWhereInput
    none?: AvailabilityWhereInput
  }

  export type MovieCharacterListRelationFilter = {
    every?: MovieCharacterWhereInput
    some?: MovieCharacterWhereInput
    none?: MovieCharacterWhereInput
  }

  export type MovieCrewListRelationFilter = {
    every?: MovieCrewWhereInput
    some?: MovieCrewWhereInput
    none?: MovieCrewWhereInput
  }

  export type MovieReviewListRelationFilter = {
    every?: MovieReviewWhereInput
    some?: MovieReviewWhereInput
    none?: MovieReviewWhereInput
  }

  export type WatchGuideMovieListRelationFilter = {
    every?: WatchGuideMovieWhereInput
    some?: WatchGuideMovieWhereInput
    none?: WatchGuideMovieWhereInput
  }

  export type MediaContentListRelationFilter = {
    every?: MediaContentWhereInput
    some?: MediaContentWhereInput
    none?: MediaContentWhereInput
  }

  export type MovieTagListRelationFilter = {
    every?: MovieTagWhereInput
    some?: MovieTagWhereInput
    none?: MovieTagWhereInput
  }

  export type UserFavoriteListRelationFilter = {
    every?: UserFavoriteWhereInput
    some?: UserFavoriteWhereInput
    none?: UserFavoriteWhereInput
  }

  export type MovieStatsNullableScalarRelationFilter = {
    is?: MovieStatsWhereInput | null
    isNot?: MovieStatsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieCharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieCrewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WatchGuideMovieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieCountOrderByAggregateInput = {
    id?: SortOrder
    tmdbId?: SortOrder
    titleEn?: SortOrder
    titleJa?: SortOrder
    titleZh?: SortOrder
    year?: SortOrder
    director?: SortOrder
    duration?: SortOrder
    synopsis?: SortOrder
    posterUrl?: SortOrder
    backdropUrl?: SortOrder
    voteAverage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieAvgOrderByAggregateInput = {
    tmdbId?: SortOrder
    year?: SortOrder
    duration?: SortOrder
    voteAverage?: SortOrder
  }

  export type MovieMaxOrderByAggregateInput = {
    id?: SortOrder
    tmdbId?: SortOrder
    titleEn?: SortOrder
    titleJa?: SortOrder
    titleZh?: SortOrder
    year?: SortOrder
    director?: SortOrder
    duration?: SortOrder
    synopsis?: SortOrder
    posterUrl?: SortOrder
    backdropUrl?: SortOrder
    voteAverage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieMinOrderByAggregateInput = {
    id?: SortOrder
    tmdbId?: SortOrder
    titleEn?: SortOrder
    titleJa?: SortOrder
    titleZh?: SortOrder
    year?: SortOrder
    director?: SortOrder
    duration?: SortOrder
    synopsis?: SortOrder
    posterUrl?: SortOrder
    backdropUrl?: SortOrder
    voteAverage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieSumOrderByAggregateInput = {
    tmdbId?: SortOrder
    year?: SortOrder
    duration?: SortOrder
    voteAverage?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumPlatformTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlatformType | EnumPlatformTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformTypeFilter<$PrismaModel> | $Enums.PlatformType
  }

  export type PlatformCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    type?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    type?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    type?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPlatformTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlatformType | EnumPlatformTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlatformType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlatformTypeFilter<$PrismaModel>
    _max?: NestedEnumPlatformTypeFilter<$PrismaModel>
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAvailabilityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AvailabilityType | EnumAvailabilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailabilityTypeFilter<$PrismaModel> | $Enums.AvailabilityType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MovieScalarRelationFilter = {
    is?: MovieWhereInput
    isNot?: MovieWhereInput
  }

  export type PlatformScalarRelationFilter = {
    is?: PlatformWhereInput
    isNot?: PlatformWhereInput
  }

  export type RegionScalarRelationFilter = {
    is?: RegionWhereInput
    isNot?: RegionWhereInput
  }

  export type AvailabilityMovieIdPlatformIdRegionIdTypeCompoundUniqueInput = {
    movieId: string
    platformId: string
    regionId: string
    type: $Enums.AvailabilityType
  }

  export type AvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    lastChecked?: SortOrder
    isAvailable?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movieId?: SortOrder
    platformId?: SortOrder
    regionId?: SortOrder
  }

  export type AvailabilityAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type AvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    lastChecked?: SortOrder
    isAvailable?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movieId?: SortOrder
    platformId?: SortOrder
    regionId?: SortOrder
  }

  export type AvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    lastChecked?: SortOrder
    isAvailable?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movieId?: SortOrder
    platformId?: SortOrder
    regionId?: SortOrder
  }

  export type AvailabilitySumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumAvailabilityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AvailabilityType | EnumAvailabilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailabilityTypeWithAggregatesFilter<$PrismaModel> | $Enums.AvailabilityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvailabilityTypeFilter<$PrismaModel>
    _max?: NestedEnumAvailabilityTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeFilter<$PrismaModel> | $Enums.ChangeType
  }

  export type ContentReviewListRelationFilter = {
    every?: ContentReviewWhereInput
    some?: ContentReviewWhereInput
    none?: ContentReviewWhereInput
  }

  export type ContentReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentVersionCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    version?: SortOrder
    changes?: SortOrder
    changeType?: SortOrder
    author?: SortOrder
    reason?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentVersionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ContentVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    version?: SortOrder
    changeType?: SortOrder
    author?: SortOrder
    reason?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentVersionMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    version?: SortOrder
    changeType?: SortOrder
    author?: SortOrder
    reason?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentVersionSumOrderByAggregateInput = {
    version?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumChangeTypeFilter<$PrismaModel>
  }

  export type EnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ContentVersionScalarRelationFilter = {
    is?: ContentVersionWhereInput
    isNot?: ContentVersionWhereInput
  }

  export type ContentReviewCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    versionId?: SortOrder
    status?: SortOrder
    reviewer?: SortOrder
    comments?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    versionId?: SortOrder
    status?: SortOrder
    reviewer?: SortOrder
    comments?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentReviewMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    versionId?: SortOrder
    status?: SortOrder
    reviewer?: SortOrder
    comments?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ContentUpdateTaskCountOrderByAggregateInput = {
    id?: SortOrder
    taskType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentUpdateTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    taskType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentUpdateTaskMinOrderByAggregateInput = {
    id?: SortOrder
    taskType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ContentQualityMetricCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metricType?: SortOrder
    score?: SortOrder
    details?: SortOrder
    measuredAt?: SortOrder
  }

  export type ContentQualityMetricAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type ContentQualityMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metricType?: SortOrder
    score?: SortOrder
    measuredAt?: SortOrder
  }

  export type ContentQualityMetricMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metricType?: SortOrder
    score?: SortOrder
    measuredAt?: SortOrder
  }

  export type ContentQualityMetricSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type UserFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    feedbackType?: SortOrder
    content?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    feedbackType?: SortOrder
    content?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    feedbackType?: SortOrder
    content?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type EnumSyncTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncType | EnumSyncTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncTypeFilter<$PrismaModel> | $Enums.SyncType
  }

  export type EnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }

  export type ContentSyncLogCountOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    syncType?: SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrder
    recordsUpdated?: SortOrder
    recordsCreated?: SortOrder
    recordsFailed?: SortOrder
    errorDetails?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ContentSyncLogAvgOrderByAggregateInput = {
    recordsProcessed?: SortOrder
    recordsUpdated?: SortOrder
    recordsCreated?: SortOrder
    recordsFailed?: SortOrder
  }

  export type ContentSyncLogMaxOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    syncType?: SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrder
    recordsUpdated?: SortOrder
    recordsCreated?: SortOrder
    recordsFailed?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ContentSyncLogMinOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    syncType?: SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrder
    recordsUpdated?: SortOrder
    recordsCreated?: SortOrder
    recordsFailed?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ContentSyncLogSumOrderByAggregateInput = {
    recordsProcessed?: SortOrder
    recordsUpdated?: SortOrder
    recordsCreated?: SortOrder
    recordsFailed?: SortOrder
  }

  export type EnumSyncTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncType | EnumSyncTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncTypeWithAggregatesFilter<$PrismaModel> | $Enums.SyncType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncTypeFilter<$PrismaModel>
    _max?: NestedEnumSyncTypeFilter<$PrismaModel>
  }

  export type EnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type CharacterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrder
    nameZh?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    isMainCharacter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrder
    nameZh?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    isMainCharacter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrder
    nameZh?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    isMainCharacter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterScalarRelationFilter = {
    is?: CharacterWhereInput
    isNot?: CharacterWhereInput
  }

  export type MovieCharacterMovieIdCharacterIdCompoundUniqueInput = {
    movieId: string
    characterId: string
  }

  export type MovieCharacterCountOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    characterId?: SortOrder
    voiceActor?: SortOrder
    voiceActorJa?: SortOrder
    importance?: SortOrder
    createdAt?: SortOrder
  }

  export type MovieCharacterAvgOrderByAggregateInput = {
    importance?: SortOrder
  }

  export type MovieCharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    characterId?: SortOrder
    voiceActor?: SortOrder
    voiceActorJa?: SortOrder
    importance?: SortOrder
    createdAt?: SortOrder
  }

  export type MovieCharacterMinOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    characterId?: SortOrder
    voiceActor?: SortOrder
    voiceActorJa?: SortOrder
    importance?: SortOrder
    createdAt?: SortOrder
  }

  export type MovieCharacterSumOrderByAggregateInput = {
    importance?: SortOrder
  }

  export type CrewMemberCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrder
    biography?: SortOrder
    imageUrl?: SortOrder
    birthDate?: SortOrder
    nationality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrewMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrder
    biography?: SortOrder
    imageUrl?: SortOrder
    birthDate?: SortOrder
    nationality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrewMemberMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrder
    biography?: SortOrder
    imageUrl?: SortOrder
    birthDate?: SortOrder
    nationality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCrewRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CrewRole | EnumCrewRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CrewRole[] | ListEnumCrewRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrewRole[] | ListEnumCrewRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCrewRoleFilter<$PrismaModel> | $Enums.CrewRole
  }

  export type CrewMemberScalarRelationFilter = {
    is?: CrewMemberWhereInput
    isNot?: CrewMemberWhereInput
  }

  export type MovieCrewMovieIdCrewMemberIdRoleCompoundUniqueInput = {
    movieId: string
    crewMemberId: string
    role: $Enums.CrewRole
  }

  export type MovieCrewCountOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    crewMemberId?: SortOrder
    role?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
  }

  export type MovieCrewMaxOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    crewMemberId?: SortOrder
    role?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
  }

  export type MovieCrewMinOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    crewMemberId?: SortOrder
    role?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCrewRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CrewRole | EnumCrewRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CrewRole[] | ListEnumCrewRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrewRole[] | ListEnumCrewRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCrewRoleWithAggregatesFilter<$PrismaModel> | $Enums.CrewRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCrewRoleFilter<$PrismaModel>
    _max?: NestedEnumCrewRoleFilter<$PrismaModel>
  }

  export type EnumReviewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewType | EnumReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeFilter<$PrismaModel> | $Enums.ReviewType
  }

  export type MovieReviewCountOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    author?: SortOrder
    rating?: SortOrder
    reviewType?: SortOrder
    language?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type MovieReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    author?: SortOrder
    rating?: SortOrder
    reviewType?: SortOrder
    language?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieReviewMinOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    author?: SortOrder
    rating?: SortOrder
    reviewType?: SortOrder
    language?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumReviewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewType | EnumReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReviewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewTypeFilter<$PrismaModel>
    _max?: NestedEnumReviewTypeFilter<$PrismaModel>
  }

  export type EnumGuideTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GuideType | EnumGuideTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GuideType[] | ListEnumGuideTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuideType[] | ListEnumGuideTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGuideTypeFilter<$PrismaModel> | $Enums.GuideType
  }

  export type WatchGuideCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    guideType?: SortOrder
    content?: SortOrder
    order?: SortOrder
    isPublished?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WatchGuideAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type WatchGuideMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    guideType?: SortOrder
    order?: SortOrder
    isPublished?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WatchGuideMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    guideType?: SortOrder
    order?: SortOrder
    isPublished?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WatchGuideSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumGuideTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuideType | EnumGuideTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GuideType[] | ListEnumGuideTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuideType[] | ListEnumGuideTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGuideTypeWithAggregatesFilter<$PrismaModel> | $Enums.GuideType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuideTypeFilter<$PrismaModel>
    _max?: NestedEnumGuideTypeFilter<$PrismaModel>
  }

  export type WatchGuideScalarRelationFilter = {
    is?: WatchGuideWhereInput
    isNot?: WatchGuideWhereInput
  }

  export type WatchGuideMovieGuideIdMovieIdCompoundUniqueInput = {
    guideId: string
    movieId: string
  }

  export type WatchGuideMovieCountOrderByAggregateInput = {
    id?: SortOrder
    guideId?: SortOrder
    movieId?: SortOrder
    order?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WatchGuideMovieAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type WatchGuideMovieMaxOrderByAggregateInput = {
    id?: SortOrder
    guideId?: SortOrder
    movieId?: SortOrder
    order?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WatchGuideMovieMinOrderByAggregateInput = {
    id?: SortOrder
    guideId?: SortOrder
    movieId?: SortOrder
    order?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WatchGuideMovieSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type MovieNullableScalarRelationFilter = {
    is?: MovieWhereInput | null
    isNot?: MovieWhereInput | null
  }

  export type MediaContentCountOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    mediaType?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    language?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaContentAvgOrderByAggregateInput = {
    duration?: SortOrder
    fileSize?: SortOrder
  }

  export type MediaContentMaxOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    mediaType?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    language?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaContentMinOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    mediaType?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    language?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaContentSumOrderByAggregateInput = {
    duration?: SortOrder
    fileSize?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrder
    nameZh?: SortOrder
    description?: SortOrder
    color?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrder
    nameZh?: SortOrder
    description?: SortOrder
    color?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameJa?: SortOrder
    nameZh?: SortOrder
    description?: SortOrder
    color?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type MovieTagMovieIdTagIdCompoundUniqueInput = {
    movieId: string
    tagId: string
  }

  export type MovieTagCountOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type MovieTagMaxOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type MovieTagMinOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFavoriteUserIdMovieIdCompoundUniqueInput = {
    userId: string
    movieId: string
  }

  export type UserFavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    createdAt?: SortOrder
  }

  export type MovieStatsCountOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    viewCount?: SortOrder
    favoriteCount?: SortOrder
    shareCount?: SortOrder
    lastViewed?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieStatsAvgOrderByAggregateInput = {
    viewCount?: SortOrder
    favoriteCount?: SortOrder
    shareCount?: SortOrder
  }

  export type MovieStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    viewCount?: SortOrder
    favoriteCount?: SortOrder
    shareCount?: SortOrder
    lastViewed?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieStatsMinOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    viewCount?: SortOrder
    favoriteCount?: SortOrder
    shareCount?: SortOrder
    lastViewed?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieStatsSumOrderByAggregateInput = {
    viewCount?: SortOrder
    favoriteCount?: SortOrder
    shareCount?: SortOrder
  }

  export type AvailabilityCreateNestedManyWithoutMovieInput = {
    create?: XOR<AvailabilityCreateWithoutMovieInput, AvailabilityUncheckedCreateWithoutMovieInput> | AvailabilityCreateWithoutMovieInput[] | AvailabilityUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutMovieInput | AvailabilityCreateOrConnectWithoutMovieInput[]
    createMany?: AvailabilityCreateManyMovieInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type MovieCharacterCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieCharacterCreateWithoutMovieInput, MovieCharacterUncheckedCreateWithoutMovieInput> | MovieCharacterCreateWithoutMovieInput[] | MovieCharacterUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieCharacterCreateOrConnectWithoutMovieInput | MovieCharacterCreateOrConnectWithoutMovieInput[]
    createMany?: MovieCharacterCreateManyMovieInputEnvelope
    connect?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
  }

  export type MovieCrewCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieCrewCreateWithoutMovieInput, MovieCrewUncheckedCreateWithoutMovieInput> | MovieCrewCreateWithoutMovieInput[] | MovieCrewUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieCrewCreateOrConnectWithoutMovieInput | MovieCrewCreateOrConnectWithoutMovieInput[]
    createMany?: MovieCrewCreateManyMovieInputEnvelope
    connect?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
  }

  export type MovieReviewCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieReviewCreateWithoutMovieInput, MovieReviewUncheckedCreateWithoutMovieInput> | MovieReviewCreateWithoutMovieInput[] | MovieReviewUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieReviewCreateOrConnectWithoutMovieInput | MovieReviewCreateOrConnectWithoutMovieInput[]
    createMany?: MovieReviewCreateManyMovieInputEnvelope
    connect?: MovieReviewWhereUniqueInput | MovieReviewWhereUniqueInput[]
  }

  export type WatchGuideMovieCreateNestedManyWithoutMovieInput = {
    create?: XOR<WatchGuideMovieCreateWithoutMovieInput, WatchGuideMovieUncheckedCreateWithoutMovieInput> | WatchGuideMovieCreateWithoutMovieInput[] | WatchGuideMovieUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: WatchGuideMovieCreateOrConnectWithoutMovieInput | WatchGuideMovieCreateOrConnectWithoutMovieInput[]
    createMany?: WatchGuideMovieCreateManyMovieInputEnvelope
    connect?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
  }

  export type MediaContentCreateNestedManyWithoutMovieInput = {
    create?: XOR<MediaContentCreateWithoutMovieInput, MediaContentUncheckedCreateWithoutMovieInput> | MediaContentCreateWithoutMovieInput[] | MediaContentUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MediaContentCreateOrConnectWithoutMovieInput | MediaContentCreateOrConnectWithoutMovieInput[]
    createMany?: MediaContentCreateManyMovieInputEnvelope
    connect?: MediaContentWhereUniqueInput | MediaContentWhereUniqueInput[]
  }

  export type MovieTagCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieTagCreateWithoutMovieInput, MovieTagUncheckedCreateWithoutMovieInput> | MovieTagCreateWithoutMovieInput[] | MovieTagUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutMovieInput | MovieTagCreateOrConnectWithoutMovieInput[]
    createMany?: MovieTagCreateManyMovieInputEnvelope
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
  }

  export type UserFavoriteCreateNestedManyWithoutMovieInput = {
    create?: XOR<UserFavoriteCreateWithoutMovieInput, UserFavoriteUncheckedCreateWithoutMovieInput> | UserFavoriteCreateWithoutMovieInput[] | UserFavoriteUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutMovieInput | UserFavoriteCreateOrConnectWithoutMovieInput[]
    createMany?: UserFavoriteCreateManyMovieInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type MovieStatsCreateNestedOneWithoutMovieInput = {
    create?: XOR<MovieStatsCreateWithoutMovieInput, MovieStatsUncheckedCreateWithoutMovieInput>
    connectOrCreate?: MovieStatsCreateOrConnectWithoutMovieInput
    connect?: MovieStatsWhereUniqueInput
  }

  export type AvailabilityUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<AvailabilityCreateWithoutMovieInput, AvailabilityUncheckedCreateWithoutMovieInput> | AvailabilityCreateWithoutMovieInput[] | AvailabilityUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutMovieInput | AvailabilityCreateOrConnectWithoutMovieInput[]
    createMany?: AvailabilityCreateManyMovieInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type MovieCharacterUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieCharacterCreateWithoutMovieInput, MovieCharacterUncheckedCreateWithoutMovieInput> | MovieCharacterCreateWithoutMovieInput[] | MovieCharacterUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieCharacterCreateOrConnectWithoutMovieInput | MovieCharacterCreateOrConnectWithoutMovieInput[]
    createMany?: MovieCharacterCreateManyMovieInputEnvelope
    connect?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
  }

  export type MovieCrewUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieCrewCreateWithoutMovieInput, MovieCrewUncheckedCreateWithoutMovieInput> | MovieCrewCreateWithoutMovieInput[] | MovieCrewUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieCrewCreateOrConnectWithoutMovieInput | MovieCrewCreateOrConnectWithoutMovieInput[]
    createMany?: MovieCrewCreateManyMovieInputEnvelope
    connect?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
  }

  export type MovieReviewUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieReviewCreateWithoutMovieInput, MovieReviewUncheckedCreateWithoutMovieInput> | MovieReviewCreateWithoutMovieInput[] | MovieReviewUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieReviewCreateOrConnectWithoutMovieInput | MovieReviewCreateOrConnectWithoutMovieInput[]
    createMany?: MovieReviewCreateManyMovieInputEnvelope
    connect?: MovieReviewWhereUniqueInput | MovieReviewWhereUniqueInput[]
  }

  export type WatchGuideMovieUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<WatchGuideMovieCreateWithoutMovieInput, WatchGuideMovieUncheckedCreateWithoutMovieInput> | WatchGuideMovieCreateWithoutMovieInput[] | WatchGuideMovieUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: WatchGuideMovieCreateOrConnectWithoutMovieInput | WatchGuideMovieCreateOrConnectWithoutMovieInput[]
    createMany?: WatchGuideMovieCreateManyMovieInputEnvelope
    connect?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
  }

  export type MediaContentUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MediaContentCreateWithoutMovieInput, MediaContentUncheckedCreateWithoutMovieInput> | MediaContentCreateWithoutMovieInput[] | MediaContentUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MediaContentCreateOrConnectWithoutMovieInput | MediaContentCreateOrConnectWithoutMovieInput[]
    createMany?: MediaContentCreateManyMovieInputEnvelope
    connect?: MediaContentWhereUniqueInput | MediaContentWhereUniqueInput[]
  }

  export type MovieTagUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieTagCreateWithoutMovieInput, MovieTagUncheckedCreateWithoutMovieInput> | MovieTagCreateWithoutMovieInput[] | MovieTagUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutMovieInput | MovieTagCreateOrConnectWithoutMovieInput[]
    createMany?: MovieTagCreateManyMovieInputEnvelope
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
  }

  export type UserFavoriteUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<UserFavoriteCreateWithoutMovieInput, UserFavoriteUncheckedCreateWithoutMovieInput> | UserFavoriteCreateWithoutMovieInput[] | UserFavoriteUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutMovieInput | UserFavoriteCreateOrConnectWithoutMovieInput[]
    createMany?: UserFavoriteCreateManyMovieInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type MovieStatsUncheckedCreateNestedOneWithoutMovieInput = {
    create?: XOR<MovieStatsCreateWithoutMovieInput, MovieStatsUncheckedCreateWithoutMovieInput>
    connectOrCreate?: MovieStatsCreateOrConnectWithoutMovieInput
    connect?: MovieStatsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AvailabilityUpdateManyWithoutMovieNestedInput = {
    create?: XOR<AvailabilityCreateWithoutMovieInput, AvailabilityUncheckedCreateWithoutMovieInput> | AvailabilityCreateWithoutMovieInput[] | AvailabilityUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutMovieInput | AvailabilityCreateOrConnectWithoutMovieInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutMovieInput | AvailabilityUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: AvailabilityCreateManyMovieInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutMovieInput | AvailabilityUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutMovieInput | AvailabilityUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type MovieCharacterUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieCharacterCreateWithoutMovieInput, MovieCharacterUncheckedCreateWithoutMovieInput> | MovieCharacterCreateWithoutMovieInput[] | MovieCharacterUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieCharacterCreateOrConnectWithoutMovieInput | MovieCharacterCreateOrConnectWithoutMovieInput[]
    upsert?: MovieCharacterUpsertWithWhereUniqueWithoutMovieInput | MovieCharacterUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieCharacterCreateManyMovieInputEnvelope
    set?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    disconnect?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    delete?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    connect?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    update?: MovieCharacterUpdateWithWhereUniqueWithoutMovieInput | MovieCharacterUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieCharacterUpdateManyWithWhereWithoutMovieInput | MovieCharacterUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieCharacterScalarWhereInput | MovieCharacterScalarWhereInput[]
  }

  export type MovieCrewUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieCrewCreateWithoutMovieInput, MovieCrewUncheckedCreateWithoutMovieInput> | MovieCrewCreateWithoutMovieInput[] | MovieCrewUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieCrewCreateOrConnectWithoutMovieInput | MovieCrewCreateOrConnectWithoutMovieInput[]
    upsert?: MovieCrewUpsertWithWhereUniqueWithoutMovieInput | MovieCrewUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieCrewCreateManyMovieInputEnvelope
    set?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    disconnect?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    delete?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    connect?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    update?: MovieCrewUpdateWithWhereUniqueWithoutMovieInput | MovieCrewUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieCrewUpdateManyWithWhereWithoutMovieInput | MovieCrewUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieCrewScalarWhereInput | MovieCrewScalarWhereInput[]
  }

  export type MovieReviewUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieReviewCreateWithoutMovieInput, MovieReviewUncheckedCreateWithoutMovieInput> | MovieReviewCreateWithoutMovieInput[] | MovieReviewUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieReviewCreateOrConnectWithoutMovieInput | MovieReviewCreateOrConnectWithoutMovieInput[]
    upsert?: MovieReviewUpsertWithWhereUniqueWithoutMovieInput | MovieReviewUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieReviewCreateManyMovieInputEnvelope
    set?: MovieReviewWhereUniqueInput | MovieReviewWhereUniqueInput[]
    disconnect?: MovieReviewWhereUniqueInput | MovieReviewWhereUniqueInput[]
    delete?: MovieReviewWhereUniqueInput | MovieReviewWhereUniqueInput[]
    connect?: MovieReviewWhereUniqueInput | MovieReviewWhereUniqueInput[]
    update?: MovieReviewUpdateWithWhereUniqueWithoutMovieInput | MovieReviewUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieReviewUpdateManyWithWhereWithoutMovieInput | MovieReviewUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieReviewScalarWhereInput | MovieReviewScalarWhereInput[]
  }

  export type WatchGuideMovieUpdateManyWithoutMovieNestedInput = {
    create?: XOR<WatchGuideMovieCreateWithoutMovieInput, WatchGuideMovieUncheckedCreateWithoutMovieInput> | WatchGuideMovieCreateWithoutMovieInput[] | WatchGuideMovieUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: WatchGuideMovieCreateOrConnectWithoutMovieInput | WatchGuideMovieCreateOrConnectWithoutMovieInput[]
    upsert?: WatchGuideMovieUpsertWithWhereUniqueWithoutMovieInput | WatchGuideMovieUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: WatchGuideMovieCreateManyMovieInputEnvelope
    set?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    disconnect?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    delete?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    connect?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    update?: WatchGuideMovieUpdateWithWhereUniqueWithoutMovieInput | WatchGuideMovieUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: WatchGuideMovieUpdateManyWithWhereWithoutMovieInput | WatchGuideMovieUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: WatchGuideMovieScalarWhereInput | WatchGuideMovieScalarWhereInput[]
  }

  export type MediaContentUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MediaContentCreateWithoutMovieInput, MediaContentUncheckedCreateWithoutMovieInput> | MediaContentCreateWithoutMovieInput[] | MediaContentUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MediaContentCreateOrConnectWithoutMovieInput | MediaContentCreateOrConnectWithoutMovieInput[]
    upsert?: MediaContentUpsertWithWhereUniqueWithoutMovieInput | MediaContentUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MediaContentCreateManyMovieInputEnvelope
    set?: MediaContentWhereUniqueInput | MediaContentWhereUniqueInput[]
    disconnect?: MediaContentWhereUniqueInput | MediaContentWhereUniqueInput[]
    delete?: MediaContentWhereUniqueInput | MediaContentWhereUniqueInput[]
    connect?: MediaContentWhereUniqueInput | MediaContentWhereUniqueInput[]
    update?: MediaContentUpdateWithWhereUniqueWithoutMovieInput | MediaContentUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MediaContentUpdateManyWithWhereWithoutMovieInput | MediaContentUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MediaContentScalarWhereInput | MediaContentScalarWhereInput[]
  }

  export type MovieTagUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieTagCreateWithoutMovieInput, MovieTagUncheckedCreateWithoutMovieInput> | MovieTagCreateWithoutMovieInput[] | MovieTagUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutMovieInput | MovieTagCreateOrConnectWithoutMovieInput[]
    upsert?: MovieTagUpsertWithWhereUniqueWithoutMovieInput | MovieTagUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieTagCreateManyMovieInputEnvelope
    set?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    disconnect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    delete?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    update?: MovieTagUpdateWithWhereUniqueWithoutMovieInput | MovieTagUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieTagUpdateManyWithWhereWithoutMovieInput | MovieTagUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieTagScalarWhereInput | MovieTagScalarWhereInput[]
  }

  export type UserFavoriteUpdateManyWithoutMovieNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutMovieInput, UserFavoriteUncheckedCreateWithoutMovieInput> | UserFavoriteCreateWithoutMovieInput[] | UserFavoriteUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutMovieInput | UserFavoriteCreateOrConnectWithoutMovieInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutMovieInput | UserFavoriteUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: UserFavoriteCreateManyMovieInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutMovieInput | UserFavoriteUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutMovieInput | UserFavoriteUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type MovieStatsUpdateOneWithoutMovieNestedInput = {
    create?: XOR<MovieStatsCreateWithoutMovieInput, MovieStatsUncheckedCreateWithoutMovieInput>
    connectOrCreate?: MovieStatsCreateOrConnectWithoutMovieInput
    upsert?: MovieStatsUpsertWithoutMovieInput
    disconnect?: MovieStatsWhereInput | boolean
    delete?: MovieStatsWhereInput | boolean
    connect?: MovieStatsWhereUniqueInput
    update?: XOR<XOR<MovieStatsUpdateToOneWithWhereWithoutMovieInput, MovieStatsUpdateWithoutMovieInput>, MovieStatsUncheckedUpdateWithoutMovieInput>
  }

  export type AvailabilityUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<AvailabilityCreateWithoutMovieInput, AvailabilityUncheckedCreateWithoutMovieInput> | AvailabilityCreateWithoutMovieInput[] | AvailabilityUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutMovieInput | AvailabilityCreateOrConnectWithoutMovieInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutMovieInput | AvailabilityUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: AvailabilityCreateManyMovieInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutMovieInput | AvailabilityUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutMovieInput | AvailabilityUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type MovieCharacterUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieCharacterCreateWithoutMovieInput, MovieCharacterUncheckedCreateWithoutMovieInput> | MovieCharacterCreateWithoutMovieInput[] | MovieCharacterUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieCharacterCreateOrConnectWithoutMovieInput | MovieCharacterCreateOrConnectWithoutMovieInput[]
    upsert?: MovieCharacterUpsertWithWhereUniqueWithoutMovieInput | MovieCharacterUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieCharacterCreateManyMovieInputEnvelope
    set?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    disconnect?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    delete?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    connect?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    update?: MovieCharacterUpdateWithWhereUniqueWithoutMovieInput | MovieCharacterUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieCharacterUpdateManyWithWhereWithoutMovieInput | MovieCharacterUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieCharacterScalarWhereInput | MovieCharacterScalarWhereInput[]
  }

  export type MovieCrewUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieCrewCreateWithoutMovieInput, MovieCrewUncheckedCreateWithoutMovieInput> | MovieCrewCreateWithoutMovieInput[] | MovieCrewUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieCrewCreateOrConnectWithoutMovieInput | MovieCrewCreateOrConnectWithoutMovieInput[]
    upsert?: MovieCrewUpsertWithWhereUniqueWithoutMovieInput | MovieCrewUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieCrewCreateManyMovieInputEnvelope
    set?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    disconnect?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    delete?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    connect?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    update?: MovieCrewUpdateWithWhereUniqueWithoutMovieInput | MovieCrewUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieCrewUpdateManyWithWhereWithoutMovieInput | MovieCrewUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieCrewScalarWhereInput | MovieCrewScalarWhereInput[]
  }

  export type MovieReviewUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieReviewCreateWithoutMovieInput, MovieReviewUncheckedCreateWithoutMovieInput> | MovieReviewCreateWithoutMovieInput[] | MovieReviewUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieReviewCreateOrConnectWithoutMovieInput | MovieReviewCreateOrConnectWithoutMovieInput[]
    upsert?: MovieReviewUpsertWithWhereUniqueWithoutMovieInput | MovieReviewUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieReviewCreateManyMovieInputEnvelope
    set?: MovieReviewWhereUniqueInput | MovieReviewWhereUniqueInput[]
    disconnect?: MovieReviewWhereUniqueInput | MovieReviewWhereUniqueInput[]
    delete?: MovieReviewWhereUniqueInput | MovieReviewWhereUniqueInput[]
    connect?: MovieReviewWhereUniqueInput | MovieReviewWhereUniqueInput[]
    update?: MovieReviewUpdateWithWhereUniqueWithoutMovieInput | MovieReviewUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieReviewUpdateManyWithWhereWithoutMovieInput | MovieReviewUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieReviewScalarWhereInput | MovieReviewScalarWhereInput[]
  }

  export type WatchGuideMovieUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<WatchGuideMovieCreateWithoutMovieInput, WatchGuideMovieUncheckedCreateWithoutMovieInput> | WatchGuideMovieCreateWithoutMovieInput[] | WatchGuideMovieUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: WatchGuideMovieCreateOrConnectWithoutMovieInput | WatchGuideMovieCreateOrConnectWithoutMovieInput[]
    upsert?: WatchGuideMovieUpsertWithWhereUniqueWithoutMovieInput | WatchGuideMovieUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: WatchGuideMovieCreateManyMovieInputEnvelope
    set?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    disconnect?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    delete?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    connect?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    update?: WatchGuideMovieUpdateWithWhereUniqueWithoutMovieInput | WatchGuideMovieUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: WatchGuideMovieUpdateManyWithWhereWithoutMovieInput | WatchGuideMovieUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: WatchGuideMovieScalarWhereInput | WatchGuideMovieScalarWhereInput[]
  }

  export type MediaContentUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MediaContentCreateWithoutMovieInput, MediaContentUncheckedCreateWithoutMovieInput> | MediaContentCreateWithoutMovieInput[] | MediaContentUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MediaContentCreateOrConnectWithoutMovieInput | MediaContentCreateOrConnectWithoutMovieInput[]
    upsert?: MediaContentUpsertWithWhereUniqueWithoutMovieInput | MediaContentUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MediaContentCreateManyMovieInputEnvelope
    set?: MediaContentWhereUniqueInput | MediaContentWhereUniqueInput[]
    disconnect?: MediaContentWhereUniqueInput | MediaContentWhereUniqueInput[]
    delete?: MediaContentWhereUniqueInput | MediaContentWhereUniqueInput[]
    connect?: MediaContentWhereUniqueInput | MediaContentWhereUniqueInput[]
    update?: MediaContentUpdateWithWhereUniqueWithoutMovieInput | MediaContentUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MediaContentUpdateManyWithWhereWithoutMovieInput | MediaContentUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MediaContentScalarWhereInput | MediaContentScalarWhereInput[]
  }

  export type MovieTagUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieTagCreateWithoutMovieInput, MovieTagUncheckedCreateWithoutMovieInput> | MovieTagCreateWithoutMovieInput[] | MovieTagUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutMovieInput | MovieTagCreateOrConnectWithoutMovieInput[]
    upsert?: MovieTagUpsertWithWhereUniqueWithoutMovieInput | MovieTagUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieTagCreateManyMovieInputEnvelope
    set?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    disconnect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    delete?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    update?: MovieTagUpdateWithWhereUniqueWithoutMovieInput | MovieTagUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieTagUpdateManyWithWhereWithoutMovieInput | MovieTagUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieTagScalarWhereInput | MovieTagScalarWhereInput[]
  }

  export type UserFavoriteUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutMovieInput, UserFavoriteUncheckedCreateWithoutMovieInput> | UserFavoriteCreateWithoutMovieInput[] | UserFavoriteUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutMovieInput | UserFavoriteCreateOrConnectWithoutMovieInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutMovieInput | UserFavoriteUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: UserFavoriteCreateManyMovieInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutMovieInput | UserFavoriteUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutMovieInput | UserFavoriteUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type MovieStatsUncheckedUpdateOneWithoutMovieNestedInput = {
    create?: XOR<MovieStatsCreateWithoutMovieInput, MovieStatsUncheckedCreateWithoutMovieInput>
    connectOrCreate?: MovieStatsCreateOrConnectWithoutMovieInput
    upsert?: MovieStatsUpsertWithoutMovieInput
    disconnect?: MovieStatsWhereInput | boolean
    delete?: MovieStatsWhereInput | boolean
    connect?: MovieStatsWhereUniqueInput
    update?: XOR<XOR<MovieStatsUpdateToOneWithWhereWithoutMovieInput, MovieStatsUpdateWithoutMovieInput>, MovieStatsUncheckedUpdateWithoutMovieInput>
  }

  export type AvailabilityCreateNestedManyWithoutPlatformInput = {
    create?: XOR<AvailabilityCreateWithoutPlatformInput, AvailabilityUncheckedCreateWithoutPlatformInput> | AvailabilityCreateWithoutPlatformInput[] | AvailabilityUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutPlatformInput | AvailabilityCreateOrConnectWithoutPlatformInput[]
    createMany?: AvailabilityCreateManyPlatformInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type AvailabilityUncheckedCreateNestedManyWithoutPlatformInput = {
    create?: XOR<AvailabilityCreateWithoutPlatformInput, AvailabilityUncheckedCreateWithoutPlatformInput> | AvailabilityCreateWithoutPlatformInput[] | AvailabilityUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutPlatformInput | AvailabilityCreateOrConnectWithoutPlatformInput[]
    createMany?: AvailabilityCreateManyPlatformInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type EnumPlatformTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlatformType
  }

  export type AvailabilityUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<AvailabilityCreateWithoutPlatformInput, AvailabilityUncheckedCreateWithoutPlatformInput> | AvailabilityCreateWithoutPlatformInput[] | AvailabilityUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutPlatformInput | AvailabilityCreateOrConnectWithoutPlatformInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutPlatformInput | AvailabilityUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: AvailabilityCreateManyPlatformInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutPlatformInput | AvailabilityUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutPlatformInput | AvailabilityUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type AvailabilityUncheckedUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<AvailabilityCreateWithoutPlatformInput, AvailabilityUncheckedCreateWithoutPlatformInput> | AvailabilityCreateWithoutPlatformInput[] | AvailabilityUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutPlatformInput | AvailabilityCreateOrConnectWithoutPlatformInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutPlatformInput | AvailabilityUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: AvailabilityCreateManyPlatformInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutPlatformInput | AvailabilityUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutPlatformInput | AvailabilityUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type AvailabilityCreateNestedManyWithoutRegionInput = {
    create?: XOR<AvailabilityCreateWithoutRegionInput, AvailabilityUncheckedCreateWithoutRegionInput> | AvailabilityCreateWithoutRegionInput[] | AvailabilityUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutRegionInput | AvailabilityCreateOrConnectWithoutRegionInput[]
    createMany?: AvailabilityCreateManyRegionInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type AvailabilityUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<AvailabilityCreateWithoutRegionInput, AvailabilityUncheckedCreateWithoutRegionInput> | AvailabilityCreateWithoutRegionInput[] | AvailabilityUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutRegionInput | AvailabilityCreateOrConnectWithoutRegionInput[]
    createMany?: AvailabilityCreateManyRegionInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type AvailabilityUpdateManyWithoutRegionNestedInput = {
    create?: XOR<AvailabilityCreateWithoutRegionInput, AvailabilityUncheckedCreateWithoutRegionInput> | AvailabilityCreateWithoutRegionInput[] | AvailabilityUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutRegionInput | AvailabilityCreateOrConnectWithoutRegionInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutRegionInput | AvailabilityUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: AvailabilityCreateManyRegionInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutRegionInput | AvailabilityUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutRegionInput | AvailabilityUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type AvailabilityUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<AvailabilityCreateWithoutRegionInput, AvailabilityUncheckedCreateWithoutRegionInput> | AvailabilityCreateWithoutRegionInput[] | AvailabilityUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutRegionInput | AvailabilityCreateOrConnectWithoutRegionInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutRegionInput | AvailabilityUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: AvailabilityCreateManyRegionInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutRegionInput | AvailabilityUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutRegionInput | AvailabilityUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type MovieCreateNestedOneWithoutAvailabilitiesInput = {
    create?: XOR<MovieCreateWithoutAvailabilitiesInput, MovieUncheckedCreateWithoutAvailabilitiesInput>
    connectOrCreate?: MovieCreateOrConnectWithoutAvailabilitiesInput
    connect?: MovieWhereUniqueInput
  }

  export type PlatformCreateNestedOneWithoutAvailabilitiesInput = {
    create?: XOR<PlatformCreateWithoutAvailabilitiesInput, PlatformUncheckedCreateWithoutAvailabilitiesInput>
    connectOrCreate?: PlatformCreateOrConnectWithoutAvailabilitiesInput
    connect?: PlatformWhereUniqueInput
  }

  export type RegionCreateNestedOneWithoutAvailabilitiesInput = {
    create?: XOR<RegionCreateWithoutAvailabilitiesInput, RegionUncheckedCreateWithoutAvailabilitiesInput>
    connectOrCreate?: RegionCreateOrConnectWithoutAvailabilitiesInput
    connect?: RegionWhereUniqueInput
  }

  export type EnumAvailabilityTypeFieldUpdateOperationsInput = {
    set?: $Enums.AvailabilityType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MovieUpdateOneRequiredWithoutAvailabilitiesNestedInput = {
    create?: XOR<MovieCreateWithoutAvailabilitiesInput, MovieUncheckedCreateWithoutAvailabilitiesInput>
    connectOrCreate?: MovieCreateOrConnectWithoutAvailabilitiesInput
    upsert?: MovieUpsertWithoutAvailabilitiesInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutAvailabilitiesInput, MovieUpdateWithoutAvailabilitiesInput>, MovieUncheckedUpdateWithoutAvailabilitiesInput>
  }

  export type PlatformUpdateOneRequiredWithoutAvailabilitiesNestedInput = {
    create?: XOR<PlatformCreateWithoutAvailabilitiesInput, PlatformUncheckedCreateWithoutAvailabilitiesInput>
    connectOrCreate?: PlatformCreateOrConnectWithoutAvailabilitiesInput
    upsert?: PlatformUpsertWithoutAvailabilitiesInput
    connect?: PlatformWhereUniqueInput
    update?: XOR<XOR<PlatformUpdateToOneWithWhereWithoutAvailabilitiesInput, PlatformUpdateWithoutAvailabilitiesInput>, PlatformUncheckedUpdateWithoutAvailabilitiesInput>
  }

  export type RegionUpdateOneRequiredWithoutAvailabilitiesNestedInput = {
    create?: XOR<RegionCreateWithoutAvailabilitiesInput, RegionUncheckedCreateWithoutAvailabilitiesInput>
    connectOrCreate?: RegionCreateOrConnectWithoutAvailabilitiesInput
    upsert?: RegionUpsertWithoutAvailabilitiesInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutAvailabilitiesInput, RegionUpdateWithoutAvailabilitiesInput>, RegionUncheckedUpdateWithoutAvailabilitiesInput>
  }

  export type ContentReviewCreateNestedManyWithoutVersionInput = {
    create?: XOR<ContentReviewCreateWithoutVersionInput, ContentReviewUncheckedCreateWithoutVersionInput> | ContentReviewCreateWithoutVersionInput[] | ContentReviewUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ContentReviewCreateOrConnectWithoutVersionInput | ContentReviewCreateOrConnectWithoutVersionInput[]
    createMany?: ContentReviewCreateManyVersionInputEnvelope
    connect?: ContentReviewWhereUniqueInput | ContentReviewWhereUniqueInput[]
  }

  export type ContentReviewUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<ContentReviewCreateWithoutVersionInput, ContentReviewUncheckedCreateWithoutVersionInput> | ContentReviewCreateWithoutVersionInput[] | ContentReviewUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ContentReviewCreateOrConnectWithoutVersionInput | ContentReviewCreateOrConnectWithoutVersionInput[]
    createMany?: ContentReviewCreateManyVersionInputEnvelope
    connect?: ContentReviewWhereUniqueInput | ContentReviewWhereUniqueInput[]
  }

  export type EnumChangeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChangeType
  }

  export type ContentReviewUpdateManyWithoutVersionNestedInput = {
    create?: XOR<ContentReviewCreateWithoutVersionInput, ContentReviewUncheckedCreateWithoutVersionInput> | ContentReviewCreateWithoutVersionInput[] | ContentReviewUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ContentReviewCreateOrConnectWithoutVersionInput | ContentReviewCreateOrConnectWithoutVersionInput[]
    upsert?: ContentReviewUpsertWithWhereUniqueWithoutVersionInput | ContentReviewUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: ContentReviewCreateManyVersionInputEnvelope
    set?: ContentReviewWhereUniqueInput | ContentReviewWhereUniqueInput[]
    disconnect?: ContentReviewWhereUniqueInput | ContentReviewWhereUniqueInput[]
    delete?: ContentReviewWhereUniqueInput | ContentReviewWhereUniqueInput[]
    connect?: ContentReviewWhereUniqueInput | ContentReviewWhereUniqueInput[]
    update?: ContentReviewUpdateWithWhereUniqueWithoutVersionInput | ContentReviewUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: ContentReviewUpdateManyWithWhereWithoutVersionInput | ContentReviewUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: ContentReviewScalarWhereInput | ContentReviewScalarWhereInput[]
  }

  export type ContentReviewUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<ContentReviewCreateWithoutVersionInput, ContentReviewUncheckedCreateWithoutVersionInput> | ContentReviewCreateWithoutVersionInput[] | ContentReviewUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ContentReviewCreateOrConnectWithoutVersionInput | ContentReviewCreateOrConnectWithoutVersionInput[]
    upsert?: ContentReviewUpsertWithWhereUniqueWithoutVersionInput | ContentReviewUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: ContentReviewCreateManyVersionInputEnvelope
    set?: ContentReviewWhereUniqueInput | ContentReviewWhereUniqueInput[]
    disconnect?: ContentReviewWhereUniqueInput | ContentReviewWhereUniqueInput[]
    delete?: ContentReviewWhereUniqueInput | ContentReviewWhereUniqueInput[]
    connect?: ContentReviewWhereUniqueInput | ContentReviewWhereUniqueInput[]
    update?: ContentReviewUpdateWithWhereUniqueWithoutVersionInput | ContentReviewUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: ContentReviewUpdateManyWithWhereWithoutVersionInput | ContentReviewUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: ContentReviewScalarWhereInput | ContentReviewScalarWhereInput[]
  }

  export type ContentVersionCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ContentVersionCreateWithoutReviewsInput, ContentVersionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ContentVersionCreateOrConnectWithoutReviewsInput
    connect?: ContentVersionWhereUniqueInput
  }

  export type EnumReviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReviewStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ContentVersionUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ContentVersionCreateWithoutReviewsInput, ContentVersionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ContentVersionCreateOrConnectWithoutReviewsInput
    upsert?: ContentVersionUpsertWithoutReviewsInput
    connect?: ContentVersionWhereUniqueInput
    update?: XOR<XOR<ContentVersionUpdateToOneWithWhereWithoutReviewsInput, ContentVersionUpdateWithoutReviewsInput>, ContentVersionUncheckedUpdateWithoutReviewsInput>
  }

  export type EnumTaskTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaskType
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumFeedbackTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackType
  }

  export type EnumSyncTypeFieldUpdateOperationsInput = {
    set?: $Enums.SyncType
  }

  export type EnumSyncStatusFieldUpdateOperationsInput = {
    set?: $Enums.SyncStatus
  }

  export type MovieCharacterCreateNestedManyWithoutCharacterInput = {
    create?: XOR<MovieCharacterCreateWithoutCharacterInput, MovieCharacterUncheckedCreateWithoutCharacterInput> | MovieCharacterCreateWithoutCharacterInput[] | MovieCharacterUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: MovieCharacterCreateOrConnectWithoutCharacterInput | MovieCharacterCreateOrConnectWithoutCharacterInput[]
    createMany?: MovieCharacterCreateManyCharacterInputEnvelope
    connect?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
  }

  export type MovieCharacterUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<MovieCharacterCreateWithoutCharacterInput, MovieCharacterUncheckedCreateWithoutCharacterInput> | MovieCharacterCreateWithoutCharacterInput[] | MovieCharacterUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: MovieCharacterCreateOrConnectWithoutCharacterInput | MovieCharacterCreateOrConnectWithoutCharacterInput[]
    createMany?: MovieCharacterCreateManyCharacterInputEnvelope
    connect?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
  }

  export type MovieCharacterUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<MovieCharacterCreateWithoutCharacterInput, MovieCharacterUncheckedCreateWithoutCharacterInput> | MovieCharacterCreateWithoutCharacterInput[] | MovieCharacterUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: MovieCharacterCreateOrConnectWithoutCharacterInput | MovieCharacterCreateOrConnectWithoutCharacterInput[]
    upsert?: MovieCharacterUpsertWithWhereUniqueWithoutCharacterInput | MovieCharacterUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: MovieCharacterCreateManyCharacterInputEnvelope
    set?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    disconnect?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    delete?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    connect?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    update?: MovieCharacterUpdateWithWhereUniqueWithoutCharacterInput | MovieCharacterUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: MovieCharacterUpdateManyWithWhereWithoutCharacterInput | MovieCharacterUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: MovieCharacterScalarWhereInput | MovieCharacterScalarWhereInput[]
  }

  export type MovieCharacterUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<MovieCharacterCreateWithoutCharacterInput, MovieCharacterUncheckedCreateWithoutCharacterInput> | MovieCharacterCreateWithoutCharacterInput[] | MovieCharacterUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: MovieCharacterCreateOrConnectWithoutCharacterInput | MovieCharacterCreateOrConnectWithoutCharacterInput[]
    upsert?: MovieCharacterUpsertWithWhereUniqueWithoutCharacterInput | MovieCharacterUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: MovieCharacterCreateManyCharacterInputEnvelope
    set?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    disconnect?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    delete?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    connect?: MovieCharacterWhereUniqueInput | MovieCharacterWhereUniqueInput[]
    update?: MovieCharacterUpdateWithWhereUniqueWithoutCharacterInput | MovieCharacterUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: MovieCharacterUpdateManyWithWhereWithoutCharacterInput | MovieCharacterUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: MovieCharacterScalarWhereInput | MovieCharacterScalarWhereInput[]
  }

  export type MovieCreateNestedOneWithoutMovieCharactersInput = {
    create?: XOR<MovieCreateWithoutMovieCharactersInput, MovieUncheckedCreateWithoutMovieCharactersInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMovieCharactersInput
    connect?: MovieWhereUniqueInput
  }

  export type CharacterCreateNestedOneWithoutMovieCharactersInput = {
    create?: XOR<CharacterCreateWithoutMovieCharactersInput, CharacterUncheckedCreateWithoutMovieCharactersInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutMovieCharactersInput
    connect?: CharacterWhereUniqueInput
  }

  export type MovieUpdateOneRequiredWithoutMovieCharactersNestedInput = {
    create?: XOR<MovieCreateWithoutMovieCharactersInput, MovieUncheckedCreateWithoutMovieCharactersInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMovieCharactersInput
    upsert?: MovieUpsertWithoutMovieCharactersInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutMovieCharactersInput, MovieUpdateWithoutMovieCharactersInput>, MovieUncheckedUpdateWithoutMovieCharactersInput>
  }

  export type CharacterUpdateOneRequiredWithoutMovieCharactersNestedInput = {
    create?: XOR<CharacterCreateWithoutMovieCharactersInput, CharacterUncheckedCreateWithoutMovieCharactersInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutMovieCharactersInput
    upsert?: CharacterUpsertWithoutMovieCharactersInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutMovieCharactersInput, CharacterUpdateWithoutMovieCharactersInput>, CharacterUncheckedUpdateWithoutMovieCharactersInput>
  }

  export type MovieCrewCreateNestedManyWithoutCrewMemberInput = {
    create?: XOR<MovieCrewCreateWithoutCrewMemberInput, MovieCrewUncheckedCreateWithoutCrewMemberInput> | MovieCrewCreateWithoutCrewMemberInput[] | MovieCrewUncheckedCreateWithoutCrewMemberInput[]
    connectOrCreate?: MovieCrewCreateOrConnectWithoutCrewMemberInput | MovieCrewCreateOrConnectWithoutCrewMemberInput[]
    createMany?: MovieCrewCreateManyCrewMemberInputEnvelope
    connect?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
  }

  export type MovieCrewUncheckedCreateNestedManyWithoutCrewMemberInput = {
    create?: XOR<MovieCrewCreateWithoutCrewMemberInput, MovieCrewUncheckedCreateWithoutCrewMemberInput> | MovieCrewCreateWithoutCrewMemberInput[] | MovieCrewUncheckedCreateWithoutCrewMemberInput[]
    connectOrCreate?: MovieCrewCreateOrConnectWithoutCrewMemberInput | MovieCrewCreateOrConnectWithoutCrewMemberInput[]
    createMany?: MovieCrewCreateManyCrewMemberInputEnvelope
    connect?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
  }

  export type MovieCrewUpdateManyWithoutCrewMemberNestedInput = {
    create?: XOR<MovieCrewCreateWithoutCrewMemberInput, MovieCrewUncheckedCreateWithoutCrewMemberInput> | MovieCrewCreateWithoutCrewMemberInput[] | MovieCrewUncheckedCreateWithoutCrewMemberInput[]
    connectOrCreate?: MovieCrewCreateOrConnectWithoutCrewMemberInput | MovieCrewCreateOrConnectWithoutCrewMemberInput[]
    upsert?: MovieCrewUpsertWithWhereUniqueWithoutCrewMemberInput | MovieCrewUpsertWithWhereUniqueWithoutCrewMemberInput[]
    createMany?: MovieCrewCreateManyCrewMemberInputEnvelope
    set?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    disconnect?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    delete?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    connect?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    update?: MovieCrewUpdateWithWhereUniqueWithoutCrewMemberInput | MovieCrewUpdateWithWhereUniqueWithoutCrewMemberInput[]
    updateMany?: MovieCrewUpdateManyWithWhereWithoutCrewMemberInput | MovieCrewUpdateManyWithWhereWithoutCrewMemberInput[]
    deleteMany?: MovieCrewScalarWhereInput | MovieCrewScalarWhereInput[]
  }

  export type MovieCrewUncheckedUpdateManyWithoutCrewMemberNestedInput = {
    create?: XOR<MovieCrewCreateWithoutCrewMemberInput, MovieCrewUncheckedCreateWithoutCrewMemberInput> | MovieCrewCreateWithoutCrewMemberInput[] | MovieCrewUncheckedCreateWithoutCrewMemberInput[]
    connectOrCreate?: MovieCrewCreateOrConnectWithoutCrewMemberInput | MovieCrewCreateOrConnectWithoutCrewMemberInput[]
    upsert?: MovieCrewUpsertWithWhereUniqueWithoutCrewMemberInput | MovieCrewUpsertWithWhereUniqueWithoutCrewMemberInput[]
    createMany?: MovieCrewCreateManyCrewMemberInputEnvelope
    set?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    disconnect?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    delete?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    connect?: MovieCrewWhereUniqueInput | MovieCrewWhereUniqueInput[]
    update?: MovieCrewUpdateWithWhereUniqueWithoutCrewMemberInput | MovieCrewUpdateWithWhereUniqueWithoutCrewMemberInput[]
    updateMany?: MovieCrewUpdateManyWithWhereWithoutCrewMemberInput | MovieCrewUpdateManyWithWhereWithoutCrewMemberInput[]
    deleteMany?: MovieCrewScalarWhereInput | MovieCrewScalarWhereInput[]
  }

  export type MovieCreateNestedOneWithoutMovieCrewInput = {
    create?: XOR<MovieCreateWithoutMovieCrewInput, MovieUncheckedCreateWithoutMovieCrewInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMovieCrewInput
    connect?: MovieWhereUniqueInput
  }

  export type CrewMemberCreateNestedOneWithoutMovieCrewInput = {
    create?: XOR<CrewMemberCreateWithoutMovieCrewInput, CrewMemberUncheckedCreateWithoutMovieCrewInput>
    connectOrCreate?: CrewMemberCreateOrConnectWithoutMovieCrewInput
    connect?: CrewMemberWhereUniqueInput
  }

  export type EnumCrewRoleFieldUpdateOperationsInput = {
    set?: $Enums.CrewRole
  }

  export type MovieUpdateOneRequiredWithoutMovieCrewNestedInput = {
    create?: XOR<MovieCreateWithoutMovieCrewInput, MovieUncheckedCreateWithoutMovieCrewInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMovieCrewInput
    upsert?: MovieUpsertWithoutMovieCrewInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutMovieCrewInput, MovieUpdateWithoutMovieCrewInput>, MovieUncheckedUpdateWithoutMovieCrewInput>
  }

  export type CrewMemberUpdateOneRequiredWithoutMovieCrewNestedInput = {
    create?: XOR<CrewMemberCreateWithoutMovieCrewInput, CrewMemberUncheckedCreateWithoutMovieCrewInput>
    connectOrCreate?: CrewMemberCreateOrConnectWithoutMovieCrewInput
    upsert?: CrewMemberUpsertWithoutMovieCrewInput
    connect?: CrewMemberWhereUniqueInput
    update?: XOR<XOR<CrewMemberUpdateToOneWithWhereWithoutMovieCrewInput, CrewMemberUpdateWithoutMovieCrewInput>, CrewMemberUncheckedUpdateWithoutMovieCrewInput>
  }

  export type MovieCreateNestedOneWithoutReviewsInput = {
    create?: XOR<MovieCreateWithoutReviewsInput, MovieUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutReviewsInput
    connect?: MovieWhereUniqueInput
  }

  export type EnumReviewTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReviewType
  }

  export type MovieUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<MovieCreateWithoutReviewsInput, MovieUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutReviewsInput
    upsert?: MovieUpsertWithoutReviewsInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutReviewsInput, MovieUpdateWithoutReviewsInput>, MovieUncheckedUpdateWithoutReviewsInput>
  }

  export type WatchGuideMovieCreateNestedManyWithoutGuideInput = {
    create?: XOR<WatchGuideMovieCreateWithoutGuideInput, WatchGuideMovieUncheckedCreateWithoutGuideInput> | WatchGuideMovieCreateWithoutGuideInput[] | WatchGuideMovieUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: WatchGuideMovieCreateOrConnectWithoutGuideInput | WatchGuideMovieCreateOrConnectWithoutGuideInput[]
    createMany?: WatchGuideMovieCreateManyGuideInputEnvelope
    connect?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
  }

  export type WatchGuideMovieUncheckedCreateNestedManyWithoutGuideInput = {
    create?: XOR<WatchGuideMovieCreateWithoutGuideInput, WatchGuideMovieUncheckedCreateWithoutGuideInput> | WatchGuideMovieCreateWithoutGuideInput[] | WatchGuideMovieUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: WatchGuideMovieCreateOrConnectWithoutGuideInput | WatchGuideMovieCreateOrConnectWithoutGuideInput[]
    createMany?: WatchGuideMovieCreateManyGuideInputEnvelope
    connect?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
  }

  export type EnumGuideTypeFieldUpdateOperationsInput = {
    set?: $Enums.GuideType
  }

  export type WatchGuideMovieUpdateManyWithoutGuideNestedInput = {
    create?: XOR<WatchGuideMovieCreateWithoutGuideInput, WatchGuideMovieUncheckedCreateWithoutGuideInput> | WatchGuideMovieCreateWithoutGuideInput[] | WatchGuideMovieUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: WatchGuideMovieCreateOrConnectWithoutGuideInput | WatchGuideMovieCreateOrConnectWithoutGuideInput[]
    upsert?: WatchGuideMovieUpsertWithWhereUniqueWithoutGuideInput | WatchGuideMovieUpsertWithWhereUniqueWithoutGuideInput[]
    createMany?: WatchGuideMovieCreateManyGuideInputEnvelope
    set?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    disconnect?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    delete?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    connect?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    update?: WatchGuideMovieUpdateWithWhereUniqueWithoutGuideInput | WatchGuideMovieUpdateWithWhereUniqueWithoutGuideInput[]
    updateMany?: WatchGuideMovieUpdateManyWithWhereWithoutGuideInput | WatchGuideMovieUpdateManyWithWhereWithoutGuideInput[]
    deleteMany?: WatchGuideMovieScalarWhereInput | WatchGuideMovieScalarWhereInput[]
  }

  export type WatchGuideMovieUncheckedUpdateManyWithoutGuideNestedInput = {
    create?: XOR<WatchGuideMovieCreateWithoutGuideInput, WatchGuideMovieUncheckedCreateWithoutGuideInput> | WatchGuideMovieCreateWithoutGuideInput[] | WatchGuideMovieUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: WatchGuideMovieCreateOrConnectWithoutGuideInput | WatchGuideMovieCreateOrConnectWithoutGuideInput[]
    upsert?: WatchGuideMovieUpsertWithWhereUniqueWithoutGuideInput | WatchGuideMovieUpsertWithWhereUniqueWithoutGuideInput[]
    createMany?: WatchGuideMovieCreateManyGuideInputEnvelope
    set?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    disconnect?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    delete?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    connect?: WatchGuideMovieWhereUniqueInput | WatchGuideMovieWhereUniqueInput[]
    update?: WatchGuideMovieUpdateWithWhereUniqueWithoutGuideInput | WatchGuideMovieUpdateWithWhereUniqueWithoutGuideInput[]
    updateMany?: WatchGuideMovieUpdateManyWithWhereWithoutGuideInput | WatchGuideMovieUpdateManyWithWhereWithoutGuideInput[]
    deleteMany?: WatchGuideMovieScalarWhereInput | WatchGuideMovieScalarWhereInput[]
  }

  export type WatchGuideCreateNestedOneWithoutMoviesInput = {
    create?: XOR<WatchGuideCreateWithoutMoviesInput, WatchGuideUncheckedCreateWithoutMoviesInput>
    connectOrCreate?: WatchGuideCreateOrConnectWithoutMoviesInput
    connect?: WatchGuideWhereUniqueInput
  }

  export type MovieCreateNestedOneWithoutGuideMoviesInput = {
    create?: XOR<MovieCreateWithoutGuideMoviesInput, MovieUncheckedCreateWithoutGuideMoviesInput>
    connectOrCreate?: MovieCreateOrConnectWithoutGuideMoviesInput
    connect?: MovieWhereUniqueInput
  }

  export type WatchGuideUpdateOneRequiredWithoutMoviesNestedInput = {
    create?: XOR<WatchGuideCreateWithoutMoviesInput, WatchGuideUncheckedCreateWithoutMoviesInput>
    connectOrCreate?: WatchGuideCreateOrConnectWithoutMoviesInput
    upsert?: WatchGuideUpsertWithoutMoviesInput
    connect?: WatchGuideWhereUniqueInput
    update?: XOR<XOR<WatchGuideUpdateToOneWithWhereWithoutMoviesInput, WatchGuideUpdateWithoutMoviesInput>, WatchGuideUncheckedUpdateWithoutMoviesInput>
  }

  export type MovieUpdateOneRequiredWithoutGuideMoviesNestedInput = {
    create?: XOR<MovieCreateWithoutGuideMoviesInput, MovieUncheckedCreateWithoutGuideMoviesInput>
    connectOrCreate?: MovieCreateOrConnectWithoutGuideMoviesInput
    upsert?: MovieUpsertWithoutGuideMoviesInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutGuideMoviesInput, MovieUpdateWithoutGuideMoviesInput>, MovieUncheckedUpdateWithoutGuideMoviesInput>
  }

  export type MovieCreateNestedOneWithoutMediaContentInput = {
    create?: XOR<MovieCreateWithoutMediaContentInput, MovieUncheckedCreateWithoutMediaContentInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMediaContentInput
    connect?: MovieWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type MovieUpdateOneWithoutMediaContentNestedInput = {
    create?: XOR<MovieCreateWithoutMediaContentInput, MovieUncheckedCreateWithoutMediaContentInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMediaContentInput
    upsert?: MovieUpsertWithoutMediaContentInput
    disconnect?: MovieWhereInput | boolean
    delete?: MovieWhereInput | boolean
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutMediaContentInput, MovieUpdateWithoutMediaContentInput>, MovieUncheckedUpdateWithoutMediaContentInput>
  }

  export type MovieTagCreateNestedManyWithoutTagInput = {
    create?: XOR<MovieTagCreateWithoutTagInput, MovieTagUncheckedCreateWithoutTagInput> | MovieTagCreateWithoutTagInput[] | MovieTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutTagInput | MovieTagCreateOrConnectWithoutTagInput[]
    createMany?: MovieTagCreateManyTagInputEnvelope
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
  }

  export type MovieTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<MovieTagCreateWithoutTagInput, MovieTagUncheckedCreateWithoutTagInput> | MovieTagCreateWithoutTagInput[] | MovieTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutTagInput | MovieTagCreateOrConnectWithoutTagInput[]
    createMany?: MovieTagCreateManyTagInputEnvelope
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
  }

  export type MovieTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<MovieTagCreateWithoutTagInput, MovieTagUncheckedCreateWithoutTagInput> | MovieTagCreateWithoutTagInput[] | MovieTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutTagInput | MovieTagCreateOrConnectWithoutTagInput[]
    upsert?: MovieTagUpsertWithWhereUniqueWithoutTagInput | MovieTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: MovieTagCreateManyTagInputEnvelope
    set?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    disconnect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    delete?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    update?: MovieTagUpdateWithWhereUniqueWithoutTagInput | MovieTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: MovieTagUpdateManyWithWhereWithoutTagInput | MovieTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: MovieTagScalarWhereInput | MovieTagScalarWhereInput[]
  }

  export type MovieTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<MovieTagCreateWithoutTagInput, MovieTagUncheckedCreateWithoutTagInput> | MovieTagCreateWithoutTagInput[] | MovieTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutTagInput | MovieTagCreateOrConnectWithoutTagInput[]
    upsert?: MovieTagUpsertWithWhereUniqueWithoutTagInput | MovieTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: MovieTagCreateManyTagInputEnvelope
    set?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    disconnect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    delete?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    update?: MovieTagUpdateWithWhereUniqueWithoutTagInput | MovieTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: MovieTagUpdateManyWithWhereWithoutTagInput | MovieTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: MovieTagScalarWhereInput | MovieTagScalarWhereInput[]
  }

  export type MovieCreateNestedOneWithoutMovieTagsInput = {
    create?: XOR<MovieCreateWithoutMovieTagsInput, MovieUncheckedCreateWithoutMovieTagsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMovieTagsInput
    connect?: MovieWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutMovieTagsInput = {
    create?: XOR<TagCreateWithoutMovieTagsInput, TagUncheckedCreateWithoutMovieTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutMovieTagsInput
    connect?: TagWhereUniqueInput
  }

  export type MovieUpdateOneRequiredWithoutMovieTagsNestedInput = {
    create?: XOR<MovieCreateWithoutMovieTagsInput, MovieUncheckedCreateWithoutMovieTagsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMovieTagsInput
    upsert?: MovieUpsertWithoutMovieTagsInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutMovieTagsInput, MovieUpdateWithoutMovieTagsInput>, MovieUncheckedUpdateWithoutMovieTagsInput>
  }

  export type TagUpdateOneRequiredWithoutMovieTagsNestedInput = {
    create?: XOR<TagCreateWithoutMovieTagsInput, TagUncheckedCreateWithoutMovieTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutMovieTagsInput
    upsert?: TagUpsertWithoutMovieTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutMovieTagsInput, TagUpdateWithoutMovieTagsInput>, TagUncheckedUpdateWithoutMovieTagsInput>
  }

  export type MovieCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<MovieCreateWithoutFavoritesInput, MovieUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: MovieCreateOrConnectWithoutFavoritesInput
    connect?: MovieWhereUniqueInput
  }

  export type MovieUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<MovieCreateWithoutFavoritesInput, MovieUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: MovieCreateOrConnectWithoutFavoritesInput
    upsert?: MovieUpsertWithoutFavoritesInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutFavoritesInput, MovieUpdateWithoutFavoritesInput>, MovieUncheckedUpdateWithoutFavoritesInput>
  }

  export type MovieCreateNestedOneWithoutStatsInput = {
    create?: XOR<MovieCreateWithoutStatsInput, MovieUncheckedCreateWithoutStatsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutStatsInput
    connect?: MovieWhereUniqueInput
  }

  export type MovieUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<MovieCreateWithoutStatsInput, MovieUncheckedCreateWithoutStatsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutStatsInput
    upsert?: MovieUpsertWithoutStatsInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutStatsInput, MovieUpdateWithoutStatsInput>, MovieUncheckedUpdateWithoutStatsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPlatformTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlatformType | EnumPlatformTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformTypeFilter<$PrismaModel> | $Enums.PlatformType
  }

  export type NestedEnumPlatformTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlatformType | EnumPlatformTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlatformType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlatformTypeFilter<$PrismaModel>
    _max?: NestedEnumPlatformTypeFilter<$PrismaModel>
  }

  export type NestedEnumAvailabilityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AvailabilityType | EnumAvailabilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailabilityTypeFilter<$PrismaModel> | $Enums.AvailabilityType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumAvailabilityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AvailabilityType | EnumAvailabilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailabilityTypeWithAggregatesFilter<$PrismaModel> | $Enums.AvailabilityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvailabilityTypeFilter<$PrismaModel>
    _max?: NestedEnumAvailabilityTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeFilter<$PrismaModel> | $Enums.ChangeType
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumChangeTypeFilter<$PrismaModel>
  }

  export type NestedEnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type NestedEnumSyncTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncType | EnumSyncTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncTypeFilter<$PrismaModel> | $Enums.SyncType
  }

  export type NestedEnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }

  export type NestedEnumSyncTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncType | EnumSyncTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncTypeWithAggregatesFilter<$PrismaModel> | $Enums.SyncType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncTypeFilter<$PrismaModel>
    _max?: NestedEnumSyncTypeFilter<$PrismaModel>
  }

  export type NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type NestedEnumCrewRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CrewRole | EnumCrewRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CrewRole[] | ListEnumCrewRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrewRole[] | ListEnumCrewRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCrewRoleFilter<$PrismaModel> | $Enums.CrewRole
  }

  export type NestedEnumCrewRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CrewRole | EnumCrewRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CrewRole[] | ListEnumCrewRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrewRole[] | ListEnumCrewRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCrewRoleWithAggregatesFilter<$PrismaModel> | $Enums.CrewRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCrewRoleFilter<$PrismaModel>
    _max?: NestedEnumCrewRoleFilter<$PrismaModel>
  }

  export type NestedEnumReviewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewType | EnumReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeFilter<$PrismaModel> | $Enums.ReviewType
  }

  export type NestedEnumReviewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewType | EnumReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReviewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewTypeFilter<$PrismaModel>
    _max?: NestedEnumReviewTypeFilter<$PrismaModel>
  }

  export type NestedEnumGuideTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GuideType | EnumGuideTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GuideType[] | ListEnumGuideTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuideType[] | ListEnumGuideTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGuideTypeFilter<$PrismaModel> | $Enums.GuideType
  }

  export type NestedEnumGuideTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuideType | EnumGuideTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GuideType[] | ListEnumGuideTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuideType[] | ListEnumGuideTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGuideTypeWithAggregatesFilter<$PrismaModel> | $Enums.GuideType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuideTypeFilter<$PrismaModel>
    _max?: NestedEnumGuideTypeFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type AvailabilityCreateWithoutMovieInput = {
    id?: string
    url?: string | null
    price?: number | null
    currency?: string | null
    type: $Enums.AvailabilityType
    lastChecked: Date | string
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    platform: PlatformCreateNestedOneWithoutAvailabilitiesInput
    region: RegionCreateNestedOneWithoutAvailabilitiesInput
  }

  export type AvailabilityUncheckedCreateWithoutMovieInput = {
    id?: string
    url?: string | null
    price?: number | null
    currency?: string | null
    type: $Enums.AvailabilityType
    lastChecked: Date | string
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    platformId: string
    regionId: string
  }

  export type AvailabilityCreateOrConnectWithoutMovieInput = {
    where: AvailabilityWhereUniqueInput
    create: XOR<AvailabilityCreateWithoutMovieInput, AvailabilityUncheckedCreateWithoutMovieInput>
  }

  export type AvailabilityCreateManyMovieInputEnvelope = {
    data: AvailabilityCreateManyMovieInput | AvailabilityCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type MovieCharacterCreateWithoutMovieInput = {
    id?: string
    voiceActor?: string | null
    voiceActorJa?: string | null
    importance?: number
    createdAt?: Date | string
    character: CharacterCreateNestedOneWithoutMovieCharactersInput
  }

  export type MovieCharacterUncheckedCreateWithoutMovieInput = {
    id?: string
    characterId: string
    voiceActor?: string | null
    voiceActorJa?: string | null
    importance?: number
    createdAt?: Date | string
  }

  export type MovieCharacterCreateOrConnectWithoutMovieInput = {
    where: MovieCharacterWhereUniqueInput
    create: XOR<MovieCharacterCreateWithoutMovieInput, MovieCharacterUncheckedCreateWithoutMovieInput>
  }

  export type MovieCharacterCreateManyMovieInputEnvelope = {
    data: MovieCharacterCreateManyMovieInput | MovieCharacterCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type MovieCrewCreateWithoutMovieInput = {
    id?: string
    role: $Enums.CrewRole
    department?: string | null
    createdAt?: Date | string
    crewMember: CrewMemberCreateNestedOneWithoutMovieCrewInput
  }

  export type MovieCrewUncheckedCreateWithoutMovieInput = {
    id?: string
    crewMemberId: string
    role: $Enums.CrewRole
    department?: string | null
    createdAt?: Date | string
  }

  export type MovieCrewCreateOrConnectWithoutMovieInput = {
    where: MovieCrewWhereUniqueInput
    create: XOR<MovieCrewCreateWithoutMovieInput, MovieCrewUncheckedCreateWithoutMovieInput>
  }

  export type MovieCrewCreateManyMovieInputEnvelope = {
    data: MovieCrewCreateManyMovieInput | MovieCrewCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type MovieReviewCreateWithoutMovieInput = {
    id?: string
    title: string
    content: string
    author: string
    rating?: number | null
    reviewType: $Enums.ReviewType
    language?: string
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieReviewUncheckedCreateWithoutMovieInput = {
    id?: string
    title: string
    content: string
    author: string
    rating?: number | null
    reviewType: $Enums.ReviewType
    language?: string
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieReviewCreateOrConnectWithoutMovieInput = {
    where: MovieReviewWhereUniqueInput
    create: XOR<MovieReviewCreateWithoutMovieInput, MovieReviewUncheckedCreateWithoutMovieInput>
  }

  export type MovieReviewCreateManyMovieInputEnvelope = {
    data: MovieReviewCreateManyMovieInput | MovieReviewCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type WatchGuideMovieCreateWithoutMovieInput = {
    id?: string
    order: number
    notes?: string | null
    createdAt?: Date | string
    guide: WatchGuideCreateNestedOneWithoutMoviesInput
  }

  export type WatchGuideMovieUncheckedCreateWithoutMovieInput = {
    id?: string
    guideId: string
    order: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type WatchGuideMovieCreateOrConnectWithoutMovieInput = {
    where: WatchGuideMovieWhereUniqueInput
    create: XOR<WatchGuideMovieCreateWithoutMovieInput, WatchGuideMovieUncheckedCreateWithoutMovieInput>
  }

  export type WatchGuideMovieCreateManyMovieInputEnvelope = {
    data: WatchGuideMovieCreateManyMovieInput | WatchGuideMovieCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type MediaContentCreateWithoutMovieInput = {
    id?: string
    title: string
    description?: string | null
    mediaType: $Enums.MediaType
    url: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    language?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaContentUncheckedCreateWithoutMovieInput = {
    id?: string
    title: string
    description?: string | null
    mediaType: $Enums.MediaType
    url: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    language?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaContentCreateOrConnectWithoutMovieInput = {
    where: MediaContentWhereUniqueInput
    create: XOR<MediaContentCreateWithoutMovieInput, MediaContentUncheckedCreateWithoutMovieInput>
  }

  export type MediaContentCreateManyMovieInputEnvelope = {
    data: MediaContentCreateManyMovieInput | MediaContentCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type MovieTagCreateWithoutMovieInput = {
    id?: string
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutMovieTagsInput
  }

  export type MovieTagUncheckedCreateWithoutMovieInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type MovieTagCreateOrConnectWithoutMovieInput = {
    where: MovieTagWhereUniqueInput
    create: XOR<MovieTagCreateWithoutMovieInput, MovieTagUncheckedCreateWithoutMovieInput>
  }

  export type MovieTagCreateManyMovieInputEnvelope = {
    data: MovieTagCreateManyMovieInput | MovieTagCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type UserFavoriteCreateWithoutMovieInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserFavoriteUncheckedCreateWithoutMovieInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserFavoriteCreateOrConnectWithoutMovieInput = {
    where: UserFavoriteWhereUniqueInput
    create: XOR<UserFavoriteCreateWithoutMovieInput, UserFavoriteUncheckedCreateWithoutMovieInput>
  }

  export type UserFavoriteCreateManyMovieInputEnvelope = {
    data: UserFavoriteCreateManyMovieInput | UserFavoriteCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type MovieStatsCreateWithoutMovieInput = {
    id?: string
    viewCount?: number
    favoriteCount?: number
    shareCount?: number
    lastViewed?: Date | string | null
    updatedAt?: Date | string
  }

  export type MovieStatsUncheckedCreateWithoutMovieInput = {
    id?: string
    viewCount?: number
    favoriteCount?: number
    shareCount?: number
    lastViewed?: Date | string | null
    updatedAt?: Date | string
  }

  export type MovieStatsCreateOrConnectWithoutMovieInput = {
    where: MovieStatsWhereUniqueInput
    create: XOR<MovieStatsCreateWithoutMovieInput, MovieStatsUncheckedCreateWithoutMovieInput>
  }

  export type AvailabilityUpsertWithWhereUniqueWithoutMovieInput = {
    where: AvailabilityWhereUniqueInput
    update: XOR<AvailabilityUpdateWithoutMovieInput, AvailabilityUncheckedUpdateWithoutMovieInput>
    create: XOR<AvailabilityCreateWithoutMovieInput, AvailabilityUncheckedCreateWithoutMovieInput>
  }

  export type AvailabilityUpdateWithWhereUniqueWithoutMovieInput = {
    where: AvailabilityWhereUniqueInput
    data: XOR<AvailabilityUpdateWithoutMovieInput, AvailabilityUncheckedUpdateWithoutMovieInput>
  }

  export type AvailabilityUpdateManyWithWhereWithoutMovieInput = {
    where: AvailabilityScalarWhereInput
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyWithoutMovieInput>
  }

  export type AvailabilityScalarWhereInput = {
    AND?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    OR?: AvailabilityScalarWhereInput[]
    NOT?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    id?: StringFilter<"Availability"> | string
    url?: StringNullableFilter<"Availability"> | string | null
    price?: FloatNullableFilter<"Availability"> | number | null
    currency?: StringNullableFilter<"Availability"> | string | null
    type?: EnumAvailabilityTypeFilter<"Availability"> | $Enums.AvailabilityType
    lastChecked?: DateTimeFilter<"Availability"> | Date | string
    isAvailable?: BoolFilter<"Availability"> | boolean
    notes?: StringNullableFilter<"Availability"> | string | null
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
    movieId?: StringFilter<"Availability"> | string
    platformId?: StringFilter<"Availability"> | string
    regionId?: StringFilter<"Availability"> | string
  }

  export type MovieCharacterUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieCharacterWhereUniqueInput
    update: XOR<MovieCharacterUpdateWithoutMovieInput, MovieCharacterUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieCharacterCreateWithoutMovieInput, MovieCharacterUncheckedCreateWithoutMovieInput>
  }

  export type MovieCharacterUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieCharacterWhereUniqueInput
    data: XOR<MovieCharacterUpdateWithoutMovieInput, MovieCharacterUncheckedUpdateWithoutMovieInput>
  }

  export type MovieCharacterUpdateManyWithWhereWithoutMovieInput = {
    where: MovieCharacterScalarWhereInput
    data: XOR<MovieCharacterUpdateManyMutationInput, MovieCharacterUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieCharacterScalarWhereInput = {
    AND?: MovieCharacterScalarWhereInput | MovieCharacterScalarWhereInput[]
    OR?: MovieCharacterScalarWhereInput[]
    NOT?: MovieCharacterScalarWhereInput | MovieCharacterScalarWhereInput[]
    id?: StringFilter<"MovieCharacter"> | string
    movieId?: StringFilter<"MovieCharacter"> | string
    characterId?: StringFilter<"MovieCharacter"> | string
    voiceActor?: StringNullableFilter<"MovieCharacter"> | string | null
    voiceActorJa?: StringNullableFilter<"MovieCharacter"> | string | null
    importance?: IntFilter<"MovieCharacter"> | number
    createdAt?: DateTimeFilter<"MovieCharacter"> | Date | string
  }

  export type MovieCrewUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieCrewWhereUniqueInput
    update: XOR<MovieCrewUpdateWithoutMovieInput, MovieCrewUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieCrewCreateWithoutMovieInput, MovieCrewUncheckedCreateWithoutMovieInput>
  }

  export type MovieCrewUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieCrewWhereUniqueInput
    data: XOR<MovieCrewUpdateWithoutMovieInput, MovieCrewUncheckedUpdateWithoutMovieInput>
  }

  export type MovieCrewUpdateManyWithWhereWithoutMovieInput = {
    where: MovieCrewScalarWhereInput
    data: XOR<MovieCrewUpdateManyMutationInput, MovieCrewUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieCrewScalarWhereInput = {
    AND?: MovieCrewScalarWhereInput | MovieCrewScalarWhereInput[]
    OR?: MovieCrewScalarWhereInput[]
    NOT?: MovieCrewScalarWhereInput | MovieCrewScalarWhereInput[]
    id?: StringFilter<"MovieCrew"> | string
    movieId?: StringFilter<"MovieCrew"> | string
    crewMemberId?: StringFilter<"MovieCrew"> | string
    role?: EnumCrewRoleFilter<"MovieCrew"> | $Enums.CrewRole
    department?: StringNullableFilter<"MovieCrew"> | string | null
    createdAt?: DateTimeFilter<"MovieCrew"> | Date | string
  }

  export type MovieReviewUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieReviewWhereUniqueInput
    update: XOR<MovieReviewUpdateWithoutMovieInput, MovieReviewUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieReviewCreateWithoutMovieInput, MovieReviewUncheckedCreateWithoutMovieInput>
  }

  export type MovieReviewUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieReviewWhereUniqueInput
    data: XOR<MovieReviewUpdateWithoutMovieInput, MovieReviewUncheckedUpdateWithoutMovieInput>
  }

  export type MovieReviewUpdateManyWithWhereWithoutMovieInput = {
    where: MovieReviewScalarWhereInput
    data: XOR<MovieReviewUpdateManyMutationInput, MovieReviewUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieReviewScalarWhereInput = {
    AND?: MovieReviewScalarWhereInput | MovieReviewScalarWhereInput[]
    OR?: MovieReviewScalarWhereInput[]
    NOT?: MovieReviewScalarWhereInput | MovieReviewScalarWhereInput[]
    id?: StringFilter<"MovieReview"> | string
    movieId?: StringFilter<"MovieReview"> | string
    title?: StringFilter<"MovieReview"> | string
    content?: StringFilter<"MovieReview"> | string
    author?: StringFilter<"MovieReview"> | string
    rating?: FloatNullableFilter<"MovieReview"> | number | null
    reviewType?: EnumReviewTypeFilter<"MovieReview"> | $Enums.ReviewType
    language?: StringFilter<"MovieReview"> | string
    isPublished?: BoolFilter<"MovieReview"> | boolean
    publishedAt?: DateTimeNullableFilter<"MovieReview"> | Date | string | null
    createdAt?: DateTimeFilter<"MovieReview"> | Date | string
    updatedAt?: DateTimeFilter<"MovieReview"> | Date | string
  }

  export type WatchGuideMovieUpsertWithWhereUniqueWithoutMovieInput = {
    where: WatchGuideMovieWhereUniqueInput
    update: XOR<WatchGuideMovieUpdateWithoutMovieInput, WatchGuideMovieUncheckedUpdateWithoutMovieInput>
    create: XOR<WatchGuideMovieCreateWithoutMovieInput, WatchGuideMovieUncheckedCreateWithoutMovieInput>
  }

  export type WatchGuideMovieUpdateWithWhereUniqueWithoutMovieInput = {
    where: WatchGuideMovieWhereUniqueInput
    data: XOR<WatchGuideMovieUpdateWithoutMovieInput, WatchGuideMovieUncheckedUpdateWithoutMovieInput>
  }

  export type WatchGuideMovieUpdateManyWithWhereWithoutMovieInput = {
    where: WatchGuideMovieScalarWhereInput
    data: XOR<WatchGuideMovieUpdateManyMutationInput, WatchGuideMovieUncheckedUpdateManyWithoutMovieInput>
  }

  export type WatchGuideMovieScalarWhereInput = {
    AND?: WatchGuideMovieScalarWhereInput | WatchGuideMovieScalarWhereInput[]
    OR?: WatchGuideMovieScalarWhereInput[]
    NOT?: WatchGuideMovieScalarWhereInput | WatchGuideMovieScalarWhereInput[]
    id?: StringFilter<"WatchGuideMovie"> | string
    guideId?: StringFilter<"WatchGuideMovie"> | string
    movieId?: StringFilter<"WatchGuideMovie"> | string
    order?: IntFilter<"WatchGuideMovie"> | number
    notes?: StringNullableFilter<"WatchGuideMovie"> | string | null
    createdAt?: DateTimeFilter<"WatchGuideMovie"> | Date | string
  }

  export type MediaContentUpsertWithWhereUniqueWithoutMovieInput = {
    where: MediaContentWhereUniqueInput
    update: XOR<MediaContentUpdateWithoutMovieInput, MediaContentUncheckedUpdateWithoutMovieInput>
    create: XOR<MediaContentCreateWithoutMovieInput, MediaContentUncheckedCreateWithoutMovieInput>
  }

  export type MediaContentUpdateWithWhereUniqueWithoutMovieInput = {
    where: MediaContentWhereUniqueInput
    data: XOR<MediaContentUpdateWithoutMovieInput, MediaContentUncheckedUpdateWithoutMovieInput>
  }

  export type MediaContentUpdateManyWithWhereWithoutMovieInput = {
    where: MediaContentScalarWhereInput
    data: XOR<MediaContentUpdateManyMutationInput, MediaContentUncheckedUpdateManyWithoutMovieInput>
  }

  export type MediaContentScalarWhereInput = {
    AND?: MediaContentScalarWhereInput | MediaContentScalarWhereInput[]
    OR?: MediaContentScalarWhereInput[]
    NOT?: MediaContentScalarWhereInput | MediaContentScalarWhereInput[]
    id?: StringFilter<"MediaContent"> | string
    movieId?: StringNullableFilter<"MediaContent"> | string | null
    title?: StringFilter<"MediaContent"> | string
    description?: StringNullableFilter<"MediaContent"> | string | null
    mediaType?: EnumMediaTypeFilter<"MediaContent"> | $Enums.MediaType
    url?: StringFilter<"MediaContent"> | string
    thumbnailUrl?: StringNullableFilter<"MediaContent"> | string | null
    duration?: IntNullableFilter<"MediaContent"> | number | null
    fileSize?: IntNullableFilter<"MediaContent"> | number | null
    language?: StringNullableFilter<"MediaContent"> | string | null
    isPublished?: BoolFilter<"MediaContent"> | boolean
    createdAt?: DateTimeFilter<"MediaContent"> | Date | string
    updatedAt?: DateTimeFilter<"MediaContent"> | Date | string
  }

  export type MovieTagUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieTagWhereUniqueInput
    update: XOR<MovieTagUpdateWithoutMovieInput, MovieTagUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieTagCreateWithoutMovieInput, MovieTagUncheckedCreateWithoutMovieInput>
  }

  export type MovieTagUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieTagWhereUniqueInput
    data: XOR<MovieTagUpdateWithoutMovieInput, MovieTagUncheckedUpdateWithoutMovieInput>
  }

  export type MovieTagUpdateManyWithWhereWithoutMovieInput = {
    where: MovieTagScalarWhereInput
    data: XOR<MovieTagUpdateManyMutationInput, MovieTagUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieTagScalarWhereInput = {
    AND?: MovieTagScalarWhereInput | MovieTagScalarWhereInput[]
    OR?: MovieTagScalarWhereInput[]
    NOT?: MovieTagScalarWhereInput | MovieTagScalarWhereInput[]
    id?: StringFilter<"MovieTag"> | string
    movieId?: StringFilter<"MovieTag"> | string
    tagId?: StringFilter<"MovieTag"> | string
    createdAt?: DateTimeFilter<"MovieTag"> | Date | string
  }

  export type UserFavoriteUpsertWithWhereUniqueWithoutMovieInput = {
    where: UserFavoriteWhereUniqueInput
    update: XOR<UserFavoriteUpdateWithoutMovieInput, UserFavoriteUncheckedUpdateWithoutMovieInput>
    create: XOR<UserFavoriteCreateWithoutMovieInput, UserFavoriteUncheckedCreateWithoutMovieInput>
  }

  export type UserFavoriteUpdateWithWhereUniqueWithoutMovieInput = {
    where: UserFavoriteWhereUniqueInput
    data: XOR<UserFavoriteUpdateWithoutMovieInput, UserFavoriteUncheckedUpdateWithoutMovieInput>
  }

  export type UserFavoriteUpdateManyWithWhereWithoutMovieInput = {
    where: UserFavoriteScalarWhereInput
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyWithoutMovieInput>
  }

  export type UserFavoriteScalarWhereInput = {
    AND?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
    OR?: UserFavoriteScalarWhereInput[]
    NOT?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
    id?: StringFilter<"UserFavorite"> | string
    userId?: StringFilter<"UserFavorite"> | string
    movieId?: StringFilter<"UserFavorite"> | string
    createdAt?: DateTimeFilter<"UserFavorite"> | Date | string
  }

  export type MovieStatsUpsertWithoutMovieInput = {
    update: XOR<MovieStatsUpdateWithoutMovieInput, MovieStatsUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieStatsCreateWithoutMovieInput, MovieStatsUncheckedCreateWithoutMovieInput>
    where?: MovieStatsWhereInput
  }

  export type MovieStatsUpdateToOneWithWhereWithoutMovieInput = {
    where?: MovieStatsWhereInput
    data: XOR<MovieStatsUpdateWithoutMovieInput, MovieStatsUncheckedUpdateWithoutMovieInput>
  }

  export type MovieStatsUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    lastViewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieStatsUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    lastViewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityCreateWithoutPlatformInput = {
    id?: string
    url?: string | null
    price?: number | null
    currency?: string | null
    type: $Enums.AvailabilityType
    lastChecked: Date | string
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movie: MovieCreateNestedOneWithoutAvailabilitiesInput
    region: RegionCreateNestedOneWithoutAvailabilitiesInput
  }

  export type AvailabilityUncheckedCreateWithoutPlatformInput = {
    id?: string
    url?: string | null
    price?: number | null
    currency?: string | null
    type: $Enums.AvailabilityType
    lastChecked: Date | string
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movieId: string
    regionId: string
  }

  export type AvailabilityCreateOrConnectWithoutPlatformInput = {
    where: AvailabilityWhereUniqueInput
    create: XOR<AvailabilityCreateWithoutPlatformInput, AvailabilityUncheckedCreateWithoutPlatformInput>
  }

  export type AvailabilityCreateManyPlatformInputEnvelope = {
    data: AvailabilityCreateManyPlatformInput | AvailabilityCreateManyPlatformInput[]
    skipDuplicates?: boolean
  }

  export type AvailabilityUpsertWithWhereUniqueWithoutPlatformInput = {
    where: AvailabilityWhereUniqueInput
    update: XOR<AvailabilityUpdateWithoutPlatformInput, AvailabilityUncheckedUpdateWithoutPlatformInput>
    create: XOR<AvailabilityCreateWithoutPlatformInput, AvailabilityUncheckedCreateWithoutPlatformInput>
  }

  export type AvailabilityUpdateWithWhereUniqueWithoutPlatformInput = {
    where: AvailabilityWhereUniqueInput
    data: XOR<AvailabilityUpdateWithoutPlatformInput, AvailabilityUncheckedUpdateWithoutPlatformInput>
  }

  export type AvailabilityUpdateManyWithWhereWithoutPlatformInput = {
    where: AvailabilityScalarWhereInput
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyWithoutPlatformInput>
  }

  export type AvailabilityCreateWithoutRegionInput = {
    id?: string
    url?: string | null
    price?: number | null
    currency?: string | null
    type: $Enums.AvailabilityType
    lastChecked: Date | string
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movie: MovieCreateNestedOneWithoutAvailabilitiesInput
    platform: PlatformCreateNestedOneWithoutAvailabilitiesInput
  }

  export type AvailabilityUncheckedCreateWithoutRegionInput = {
    id?: string
    url?: string | null
    price?: number | null
    currency?: string | null
    type: $Enums.AvailabilityType
    lastChecked: Date | string
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movieId: string
    platformId: string
  }

  export type AvailabilityCreateOrConnectWithoutRegionInput = {
    where: AvailabilityWhereUniqueInput
    create: XOR<AvailabilityCreateWithoutRegionInput, AvailabilityUncheckedCreateWithoutRegionInput>
  }

  export type AvailabilityCreateManyRegionInputEnvelope = {
    data: AvailabilityCreateManyRegionInput | AvailabilityCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type AvailabilityUpsertWithWhereUniqueWithoutRegionInput = {
    where: AvailabilityWhereUniqueInput
    update: XOR<AvailabilityUpdateWithoutRegionInput, AvailabilityUncheckedUpdateWithoutRegionInput>
    create: XOR<AvailabilityCreateWithoutRegionInput, AvailabilityUncheckedCreateWithoutRegionInput>
  }

  export type AvailabilityUpdateWithWhereUniqueWithoutRegionInput = {
    where: AvailabilityWhereUniqueInput
    data: XOR<AvailabilityUpdateWithoutRegionInput, AvailabilityUncheckedUpdateWithoutRegionInput>
  }

  export type AvailabilityUpdateManyWithWhereWithoutRegionInput = {
    where: AvailabilityScalarWhereInput
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyWithoutRegionInput>
  }

  export type MovieCreateWithoutAvailabilitiesInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movieCharacters?: MovieCharacterCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteCreateNestedManyWithoutMovieInput
    stats?: MovieStatsCreateNestedOneWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutAvailabilitiesInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movieCharacters?: MovieCharacterUncheckedCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewUncheckedCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewUncheckedCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieUncheckedCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentUncheckedCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagUncheckedCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutMovieInput
    stats?: MovieStatsUncheckedCreateNestedOneWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutAvailabilitiesInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutAvailabilitiesInput, MovieUncheckedCreateWithoutAvailabilitiesInput>
  }

  export type PlatformCreateWithoutAvailabilitiesInput = {
    id?: string
    name: string
    website: string
    type: $Enums.PlatformType
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformUncheckedCreateWithoutAvailabilitiesInput = {
    id?: string
    name: string
    website: string
    type: $Enums.PlatformType
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformCreateOrConnectWithoutAvailabilitiesInput = {
    where: PlatformWhereUniqueInput
    create: XOR<PlatformCreateWithoutAvailabilitiesInput, PlatformUncheckedCreateWithoutAvailabilitiesInput>
  }

  export type RegionCreateWithoutAvailabilitiesInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegionUncheckedCreateWithoutAvailabilitiesInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegionCreateOrConnectWithoutAvailabilitiesInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutAvailabilitiesInput, RegionUncheckedCreateWithoutAvailabilitiesInput>
  }

  export type MovieUpsertWithoutAvailabilitiesInput = {
    update: XOR<MovieUpdateWithoutAvailabilitiesInput, MovieUncheckedUpdateWithoutAvailabilitiesInput>
    create: XOR<MovieCreateWithoutAvailabilitiesInput, MovieUncheckedCreateWithoutAvailabilitiesInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutAvailabilitiesInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutAvailabilitiesInput, MovieUncheckedUpdateWithoutAvailabilitiesInput>
  }

  export type MovieUpdateWithoutAvailabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieCharacters?: MovieCharacterUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUpdateOneWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutAvailabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieCharacters?: MovieCharacterUncheckedUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUncheckedUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUncheckedUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUncheckedUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUncheckedUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUncheckedUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUncheckedUpdateOneWithoutMovieNestedInput
  }

  export type PlatformUpsertWithoutAvailabilitiesInput = {
    update: XOR<PlatformUpdateWithoutAvailabilitiesInput, PlatformUncheckedUpdateWithoutAvailabilitiesInput>
    create: XOR<PlatformCreateWithoutAvailabilitiesInput, PlatformUncheckedCreateWithoutAvailabilitiesInput>
    where?: PlatformWhereInput
  }

  export type PlatformUpdateToOneWithWhereWithoutAvailabilitiesInput = {
    where?: PlatformWhereInput
    data: XOR<PlatformUpdateWithoutAvailabilitiesInput, PlatformUncheckedUpdateWithoutAvailabilitiesInput>
  }

  export type PlatformUpdateWithoutAvailabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    type?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformUncheckedUpdateWithoutAvailabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    type?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUpsertWithoutAvailabilitiesInput = {
    update: XOR<RegionUpdateWithoutAvailabilitiesInput, RegionUncheckedUpdateWithoutAvailabilitiesInput>
    create: XOR<RegionCreateWithoutAvailabilitiesInput, RegionUncheckedCreateWithoutAvailabilitiesInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutAvailabilitiesInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutAvailabilitiesInput, RegionUncheckedUpdateWithoutAvailabilitiesInput>
  }

  export type RegionUpdateWithoutAvailabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateWithoutAvailabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentReviewCreateWithoutVersionInput = {
    id?: string
    entityType: string
    entityId: string
    status: $Enums.ReviewStatus
    reviewer?: string | null
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ContentReviewUncheckedCreateWithoutVersionInput = {
    id?: string
    entityType: string
    entityId: string
    status: $Enums.ReviewStatus
    reviewer?: string | null
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ContentReviewCreateOrConnectWithoutVersionInput = {
    where: ContentReviewWhereUniqueInput
    create: XOR<ContentReviewCreateWithoutVersionInput, ContentReviewUncheckedCreateWithoutVersionInput>
  }

  export type ContentReviewCreateManyVersionInputEnvelope = {
    data: ContentReviewCreateManyVersionInput | ContentReviewCreateManyVersionInput[]
    skipDuplicates?: boolean
  }

  export type ContentReviewUpsertWithWhereUniqueWithoutVersionInput = {
    where: ContentReviewWhereUniqueInput
    update: XOR<ContentReviewUpdateWithoutVersionInput, ContentReviewUncheckedUpdateWithoutVersionInput>
    create: XOR<ContentReviewCreateWithoutVersionInput, ContentReviewUncheckedCreateWithoutVersionInput>
  }

  export type ContentReviewUpdateWithWhereUniqueWithoutVersionInput = {
    where: ContentReviewWhereUniqueInput
    data: XOR<ContentReviewUpdateWithoutVersionInput, ContentReviewUncheckedUpdateWithoutVersionInput>
  }

  export type ContentReviewUpdateManyWithWhereWithoutVersionInput = {
    where: ContentReviewScalarWhereInput
    data: XOR<ContentReviewUpdateManyMutationInput, ContentReviewUncheckedUpdateManyWithoutVersionInput>
  }

  export type ContentReviewScalarWhereInput = {
    AND?: ContentReviewScalarWhereInput | ContentReviewScalarWhereInput[]
    OR?: ContentReviewScalarWhereInput[]
    NOT?: ContentReviewScalarWhereInput | ContentReviewScalarWhereInput[]
    id?: StringFilter<"ContentReview"> | string
    entityType?: StringFilter<"ContentReview"> | string
    entityId?: StringFilter<"ContentReview"> | string
    versionId?: StringFilter<"ContentReview"> | string
    status?: EnumReviewStatusFilter<"ContentReview"> | $Enums.ReviewStatus
    reviewer?: StringNullableFilter<"ContentReview"> | string | null
    comments?: StringNullableFilter<"ContentReview"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ContentReview"> | Date | string | null
    createdAt?: DateTimeFilter<"ContentReview"> | Date | string
  }

  export type ContentVersionCreateWithoutReviewsInput = {
    id?: string
    entityType: string
    entityId: string
    version: number
    changes: JsonNullValueInput | InputJsonValue
    changeType: $Enums.ChangeType
    author?: string | null
    reason?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ContentVersionUncheckedCreateWithoutReviewsInput = {
    id?: string
    entityType: string
    entityId: string
    version: number
    changes: JsonNullValueInput | InputJsonValue
    changeType: $Enums.ChangeType
    author?: string | null
    reason?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ContentVersionCreateOrConnectWithoutReviewsInput = {
    where: ContentVersionWhereUniqueInput
    create: XOR<ContentVersionCreateWithoutReviewsInput, ContentVersionUncheckedCreateWithoutReviewsInput>
  }

  export type ContentVersionUpsertWithoutReviewsInput = {
    update: XOR<ContentVersionUpdateWithoutReviewsInput, ContentVersionUncheckedUpdateWithoutReviewsInput>
    create: XOR<ContentVersionCreateWithoutReviewsInput, ContentVersionUncheckedCreateWithoutReviewsInput>
    where?: ContentVersionWhereInput
  }

  export type ContentVersionUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ContentVersionWhereInput
    data: XOR<ContentVersionUpdateWithoutReviewsInput, ContentVersionUncheckedUpdateWithoutReviewsInput>
  }

  export type ContentVersionUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    author?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentVersionUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    author?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCharacterCreateWithoutCharacterInput = {
    id?: string
    voiceActor?: string | null
    voiceActorJa?: string | null
    importance?: number
    createdAt?: Date | string
    movie: MovieCreateNestedOneWithoutMovieCharactersInput
  }

  export type MovieCharacterUncheckedCreateWithoutCharacterInput = {
    id?: string
    movieId: string
    voiceActor?: string | null
    voiceActorJa?: string | null
    importance?: number
    createdAt?: Date | string
  }

  export type MovieCharacterCreateOrConnectWithoutCharacterInput = {
    where: MovieCharacterWhereUniqueInput
    create: XOR<MovieCharacterCreateWithoutCharacterInput, MovieCharacterUncheckedCreateWithoutCharacterInput>
  }

  export type MovieCharacterCreateManyCharacterInputEnvelope = {
    data: MovieCharacterCreateManyCharacterInput | MovieCharacterCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type MovieCharacterUpsertWithWhereUniqueWithoutCharacterInput = {
    where: MovieCharacterWhereUniqueInput
    update: XOR<MovieCharacterUpdateWithoutCharacterInput, MovieCharacterUncheckedUpdateWithoutCharacterInput>
    create: XOR<MovieCharacterCreateWithoutCharacterInput, MovieCharacterUncheckedCreateWithoutCharacterInput>
  }

  export type MovieCharacterUpdateWithWhereUniqueWithoutCharacterInput = {
    where: MovieCharacterWhereUniqueInput
    data: XOR<MovieCharacterUpdateWithoutCharacterInput, MovieCharacterUncheckedUpdateWithoutCharacterInput>
  }

  export type MovieCharacterUpdateManyWithWhereWithoutCharacterInput = {
    where: MovieCharacterScalarWhereInput
    data: XOR<MovieCharacterUpdateManyMutationInput, MovieCharacterUncheckedUpdateManyWithoutCharacterInput>
  }

  export type MovieCreateWithoutMovieCharactersInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteCreateNestedManyWithoutMovieInput
    stats?: MovieStatsCreateNestedOneWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutMovieCharactersInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewUncheckedCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewUncheckedCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieUncheckedCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentUncheckedCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagUncheckedCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutMovieInput
    stats?: MovieStatsUncheckedCreateNestedOneWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutMovieCharactersInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutMovieCharactersInput, MovieUncheckedCreateWithoutMovieCharactersInput>
  }

  export type CharacterCreateWithoutMovieCharactersInput = {
    id?: string
    name: string
    nameJa?: string | null
    nameZh?: string | null
    description?: string | null
    imageUrl?: string | null
    isMainCharacter?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterUncheckedCreateWithoutMovieCharactersInput = {
    id?: string
    name: string
    nameJa?: string | null
    nameZh?: string | null
    description?: string | null
    imageUrl?: string | null
    isMainCharacter?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterCreateOrConnectWithoutMovieCharactersInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutMovieCharactersInput, CharacterUncheckedCreateWithoutMovieCharactersInput>
  }

  export type MovieUpsertWithoutMovieCharactersInput = {
    update: XOR<MovieUpdateWithoutMovieCharactersInput, MovieUncheckedUpdateWithoutMovieCharactersInput>
    create: XOR<MovieCreateWithoutMovieCharactersInput, MovieUncheckedCreateWithoutMovieCharactersInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutMovieCharactersInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutMovieCharactersInput, MovieUncheckedUpdateWithoutMovieCharactersInput>
  }

  export type MovieUpdateWithoutMovieCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUpdateOneWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutMovieCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUncheckedUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUncheckedUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUncheckedUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUncheckedUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUncheckedUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUncheckedUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUncheckedUpdateOneWithoutMovieNestedInput
  }

  export type CharacterUpsertWithoutMovieCharactersInput = {
    update: XOR<CharacterUpdateWithoutMovieCharactersInput, CharacterUncheckedUpdateWithoutMovieCharactersInput>
    create: XOR<CharacterCreateWithoutMovieCharactersInput, CharacterUncheckedCreateWithoutMovieCharactersInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutMovieCharactersInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutMovieCharactersInput, CharacterUncheckedUpdateWithoutMovieCharactersInput>
  }

  export type CharacterUpdateWithoutMovieCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isMainCharacter?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterUncheckedUpdateWithoutMovieCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isMainCharacter?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCrewCreateWithoutCrewMemberInput = {
    id?: string
    role: $Enums.CrewRole
    department?: string | null
    createdAt?: Date | string
    movie: MovieCreateNestedOneWithoutMovieCrewInput
  }

  export type MovieCrewUncheckedCreateWithoutCrewMemberInput = {
    id?: string
    movieId: string
    role: $Enums.CrewRole
    department?: string | null
    createdAt?: Date | string
  }

  export type MovieCrewCreateOrConnectWithoutCrewMemberInput = {
    where: MovieCrewWhereUniqueInput
    create: XOR<MovieCrewCreateWithoutCrewMemberInput, MovieCrewUncheckedCreateWithoutCrewMemberInput>
  }

  export type MovieCrewCreateManyCrewMemberInputEnvelope = {
    data: MovieCrewCreateManyCrewMemberInput | MovieCrewCreateManyCrewMemberInput[]
    skipDuplicates?: boolean
  }

  export type MovieCrewUpsertWithWhereUniqueWithoutCrewMemberInput = {
    where: MovieCrewWhereUniqueInput
    update: XOR<MovieCrewUpdateWithoutCrewMemberInput, MovieCrewUncheckedUpdateWithoutCrewMemberInput>
    create: XOR<MovieCrewCreateWithoutCrewMemberInput, MovieCrewUncheckedCreateWithoutCrewMemberInput>
  }

  export type MovieCrewUpdateWithWhereUniqueWithoutCrewMemberInput = {
    where: MovieCrewWhereUniqueInput
    data: XOR<MovieCrewUpdateWithoutCrewMemberInput, MovieCrewUncheckedUpdateWithoutCrewMemberInput>
  }

  export type MovieCrewUpdateManyWithWhereWithoutCrewMemberInput = {
    where: MovieCrewScalarWhereInput
    data: XOR<MovieCrewUpdateManyMutationInput, MovieCrewUncheckedUpdateManyWithoutCrewMemberInput>
  }

  export type MovieCreateWithoutMovieCrewInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteCreateNestedManyWithoutMovieInput
    stats?: MovieStatsCreateNestedOneWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutMovieCrewInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterUncheckedCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewUncheckedCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieUncheckedCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentUncheckedCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagUncheckedCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutMovieInput
    stats?: MovieStatsUncheckedCreateNestedOneWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutMovieCrewInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutMovieCrewInput, MovieUncheckedCreateWithoutMovieCrewInput>
  }

  export type CrewMemberCreateWithoutMovieCrewInput = {
    id?: string
    name: string
    nameJa?: string | null
    biography?: string | null
    imageUrl?: string | null
    birthDate?: Date | string | null
    nationality?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrewMemberUncheckedCreateWithoutMovieCrewInput = {
    id?: string
    name: string
    nameJa?: string | null
    biography?: string | null
    imageUrl?: string | null
    birthDate?: Date | string | null
    nationality?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrewMemberCreateOrConnectWithoutMovieCrewInput = {
    where: CrewMemberWhereUniqueInput
    create: XOR<CrewMemberCreateWithoutMovieCrewInput, CrewMemberUncheckedCreateWithoutMovieCrewInput>
  }

  export type MovieUpsertWithoutMovieCrewInput = {
    update: XOR<MovieUpdateWithoutMovieCrewInput, MovieUncheckedUpdateWithoutMovieCrewInput>
    create: XOR<MovieCreateWithoutMovieCrewInput, MovieUncheckedCreateWithoutMovieCrewInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutMovieCrewInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutMovieCrewInput, MovieUncheckedUpdateWithoutMovieCrewInput>
  }

  export type MovieUpdateWithoutMovieCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUpdateOneWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutMovieCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUncheckedUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUncheckedUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUncheckedUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUncheckedUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUncheckedUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUncheckedUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUncheckedUpdateOneWithoutMovieNestedInput
  }

  export type CrewMemberUpsertWithoutMovieCrewInput = {
    update: XOR<CrewMemberUpdateWithoutMovieCrewInput, CrewMemberUncheckedUpdateWithoutMovieCrewInput>
    create: XOR<CrewMemberCreateWithoutMovieCrewInput, CrewMemberUncheckedCreateWithoutMovieCrewInput>
    where?: CrewMemberWhereInput
  }

  export type CrewMemberUpdateToOneWithWhereWithoutMovieCrewInput = {
    where?: CrewMemberWhereInput
    data: XOR<CrewMemberUpdateWithoutMovieCrewInput, CrewMemberUncheckedUpdateWithoutMovieCrewInput>
  }

  export type CrewMemberUpdateWithoutMovieCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewMemberUncheckedUpdateWithoutMovieCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCreateWithoutReviewsInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteCreateNestedManyWithoutMovieInput
    stats?: MovieStatsCreateNestedOneWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutReviewsInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterUncheckedCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewUncheckedCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieUncheckedCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentUncheckedCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagUncheckedCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutMovieInput
    stats?: MovieStatsUncheckedCreateNestedOneWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutReviewsInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutReviewsInput, MovieUncheckedCreateWithoutReviewsInput>
  }

  export type MovieUpsertWithoutReviewsInput = {
    update: XOR<MovieUpdateWithoutReviewsInput, MovieUncheckedUpdateWithoutReviewsInput>
    create: XOR<MovieCreateWithoutReviewsInput, MovieUncheckedCreateWithoutReviewsInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutReviewsInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutReviewsInput, MovieUncheckedUpdateWithoutReviewsInput>
  }

  export type MovieUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUpdateOneWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUncheckedUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUncheckedUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUncheckedUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUncheckedUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUncheckedUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUncheckedUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUncheckedUpdateOneWithoutMovieNestedInput
  }

  export type WatchGuideMovieCreateWithoutGuideInput = {
    id?: string
    order: number
    notes?: string | null
    createdAt?: Date | string
    movie: MovieCreateNestedOneWithoutGuideMoviesInput
  }

  export type WatchGuideMovieUncheckedCreateWithoutGuideInput = {
    id?: string
    movieId: string
    order: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type WatchGuideMovieCreateOrConnectWithoutGuideInput = {
    where: WatchGuideMovieWhereUniqueInput
    create: XOR<WatchGuideMovieCreateWithoutGuideInput, WatchGuideMovieUncheckedCreateWithoutGuideInput>
  }

  export type WatchGuideMovieCreateManyGuideInputEnvelope = {
    data: WatchGuideMovieCreateManyGuideInput | WatchGuideMovieCreateManyGuideInput[]
    skipDuplicates?: boolean
  }

  export type WatchGuideMovieUpsertWithWhereUniqueWithoutGuideInput = {
    where: WatchGuideMovieWhereUniqueInput
    update: XOR<WatchGuideMovieUpdateWithoutGuideInput, WatchGuideMovieUncheckedUpdateWithoutGuideInput>
    create: XOR<WatchGuideMovieCreateWithoutGuideInput, WatchGuideMovieUncheckedCreateWithoutGuideInput>
  }

  export type WatchGuideMovieUpdateWithWhereUniqueWithoutGuideInput = {
    where: WatchGuideMovieWhereUniqueInput
    data: XOR<WatchGuideMovieUpdateWithoutGuideInput, WatchGuideMovieUncheckedUpdateWithoutGuideInput>
  }

  export type WatchGuideMovieUpdateManyWithWhereWithoutGuideInput = {
    where: WatchGuideMovieScalarWhereInput
    data: XOR<WatchGuideMovieUpdateManyMutationInput, WatchGuideMovieUncheckedUpdateManyWithoutGuideInput>
  }

  export type WatchGuideCreateWithoutMoviesInput = {
    id?: string
    title: string
    description: string
    guideType: $Enums.GuideType
    content: JsonNullValueInput | InputJsonValue
    order?: number
    isPublished?: boolean
    language?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WatchGuideUncheckedCreateWithoutMoviesInput = {
    id?: string
    title: string
    description: string
    guideType: $Enums.GuideType
    content: JsonNullValueInput | InputJsonValue
    order?: number
    isPublished?: boolean
    language?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WatchGuideCreateOrConnectWithoutMoviesInput = {
    where: WatchGuideWhereUniqueInput
    create: XOR<WatchGuideCreateWithoutMoviesInput, WatchGuideUncheckedCreateWithoutMoviesInput>
  }

  export type MovieCreateWithoutGuideMoviesInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteCreateNestedManyWithoutMovieInput
    stats?: MovieStatsCreateNestedOneWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutGuideMoviesInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterUncheckedCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewUncheckedCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewUncheckedCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentUncheckedCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagUncheckedCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutMovieInput
    stats?: MovieStatsUncheckedCreateNestedOneWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutGuideMoviesInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutGuideMoviesInput, MovieUncheckedCreateWithoutGuideMoviesInput>
  }

  export type WatchGuideUpsertWithoutMoviesInput = {
    update: XOR<WatchGuideUpdateWithoutMoviesInput, WatchGuideUncheckedUpdateWithoutMoviesInput>
    create: XOR<WatchGuideCreateWithoutMoviesInput, WatchGuideUncheckedCreateWithoutMoviesInput>
    where?: WatchGuideWhereInput
  }

  export type WatchGuideUpdateToOneWithWhereWithoutMoviesInput = {
    where?: WatchGuideWhereInput
    data: XOR<WatchGuideUpdateWithoutMoviesInput, WatchGuideUncheckedUpdateWithoutMoviesInput>
  }

  export type WatchGuideUpdateWithoutMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    guideType?: EnumGuideTypeFieldUpdateOperationsInput | $Enums.GuideType
    content?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchGuideUncheckedUpdateWithoutMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    guideType?: EnumGuideTypeFieldUpdateOperationsInput | $Enums.GuideType
    content?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieUpsertWithoutGuideMoviesInput = {
    update: XOR<MovieUpdateWithoutGuideMoviesInput, MovieUncheckedUpdateWithoutGuideMoviesInput>
    create: XOR<MovieCreateWithoutGuideMoviesInput, MovieUncheckedCreateWithoutGuideMoviesInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutGuideMoviesInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutGuideMoviesInput, MovieUncheckedUpdateWithoutGuideMoviesInput>
  }

  export type MovieUpdateWithoutGuideMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUpdateOneWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutGuideMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUncheckedUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUncheckedUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUncheckedUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUncheckedUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUncheckedUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUncheckedUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUncheckedUpdateOneWithoutMovieNestedInput
  }

  export type MovieCreateWithoutMediaContentInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteCreateNestedManyWithoutMovieInput
    stats?: MovieStatsCreateNestedOneWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutMediaContentInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterUncheckedCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewUncheckedCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewUncheckedCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieUncheckedCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagUncheckedCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutMovieInput
    stats?: MovieStatsUncheckedCreateNestedOneWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutMediaContentInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutMediaContentInput, MovieUncheckedCreateWithoutMediaContentInput>
  }

  export type MovieUpsertWithoutMediaContentInput = {
    update: XOR<MovieUpdateWithoutMediaContentInput, MovieUncheckedUpdateWithoutMediaContentInput>
    create: XOR<MovieCreateWithoutMediaContentInput, MovieUncheckedCreateWithoutMediaContentInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutMediaContentInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutMediaContentInput, MovieUncheckedUpdateWithoutMediaContentInput>
  }

  export type MovieUpdateWithoutMediaContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUpdateOneWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutMediaContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUncheckedUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUncheckedUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUncheckedUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUncheckedUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUncheckedUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUncheckedUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUncheckedUpdateOneWithoutMovieNestedInput
  }

  export type MovieTagCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string
    movie: MovieCreateNestedOneWithoutMovieTagsInput
  }

  export type MovieTagUncheckedCreateWithoutTagInput = {
    id?: string
    movieId: string
    createdAt?: Date | string
  }

  export type MovieTagCreateOrConnectWithoutTagInput = {
    where: MovieTagWhereUniqueInput
    create: XOR<MovieTagCreateWithoutTagInput, MovieTagUncheckedCreateWithoutTagInput>
  }

  export type MovieTagCreateManyTagInputEnvelope = {
    data: MovieTagCreateManyTagInput | MovieTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type MovieTagUpsertWithWhereUniqueWithoutTagInput = {
    where: MovieTagWhereUniqueInput
    update: XOR<MovieTagUpdateWithoutTagInput, MovieTagUncheckedUpdateWithoutTagInput>
    create: XOR<MovieTagCreateWithoutTagInput, MovieTagUncheckedCreateWithoutTagInput>
  }

  export type MovieTagUpdateWithWhereUniqueWithoutTagInput = {
    where: MovieTagWhereUniqueInput
    data: XOR<MovieTagUpdateWithoutTagInput, MovieTagUncheckedUpdateWithoutTagInput>
  }

  export type MovieTagUpdateManyWithWhereWithoutTagInput = {
    where: MovieTagScalarWhereInput
    data: XOR<MovieTagUpdateManyMutationInput, MovieTagUncheckedUpdateManyWithoutTagInput>
  }

  export type MovieCreateWithoutMovieTagsInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteCreateNestedManyWithoutMovieInput
    stats?: MovieStatsCreateNestedOneWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutMovieTagsInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterUncheckedCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewUncheckedCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewUncheckedCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieUncheckedCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentUncheckedCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutMovieInput
    stats?: MovieStatsUncheckedCreateNestedOneWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutMovieTagsInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutMovieTagsInput, MovieUncheckedCreateWithoutMovieTagsInput>
  }

  export type TagCreateWithoutMovieTagsInput = {
    id?: string
    name: string
    nameJa?: string | null
    nameZh?: string | null
    description?: string | null
    color?: string | null
    category?: string | null
    createdAt?: Date | string
  }

  export type TagUncheckedCreateWithoutMovieTagsInput = {
    id?: string
    name: string
    nameJa?: string | null
    nameZh?: string | null
    description?: string | null
    color?: string | null
    category?: string | null
    createdAt?: Date | string
  }

  export type TagCreateOrConnectWithoutMovieTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutMovieTagsInput, TagUncheckedCreateWithoutMovieTagsInput>
  }

  export type MovieUpsertWithoutMovieTagsInput = {
    update: XOR<MovieUpdateWithoutMovieTagsInput, MovieUncheckedUpdateWithoutMovieTagsInput>
    create: XOR<MovieCreateWithoutMovieTagsInput, MovieUncheckedCreateWithoutMovieTagsInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutMovieTagsInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutMovieTagsInput, MovieUncheckedUpdateWithoutMovieTagsInput>
  }

  export type MovieUpdateWithoutMovieTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUpdateOneWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutMovieTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUncheckedUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUncheckedUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUncheckedUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUncheckedUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUncheckedUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUncheckedUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUncheckedUpdateOneWithoutMovieNestedInput
  }

  export type TagUpsertWithoutMovieTagsInput = {
    update: XOR<TagUpdateWithoutMovieTagsInput, TagUncheckedUpdateWithoutMovieTagsInput>
    create: XOR<TagCreateWithoutMovieTagsInput, TagUncheckedCreateWithoutMovieTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutMovieTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutMovieTagsInput, TagUncheckedUpdateWithoutMovieTagsInput>
  }

  export type TagUpdateWithoutMovieTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutMovieTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameJa?: NullableStringFieldUpdateOperationsInput | string | null
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCreateWithoutFavoritesInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagCreateNestedManyWithoutMovieInput
    stats?: MovieStatsCreateNestedOneWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutFavoritesInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterUncheckedCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewUncheckedCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewUncheckedCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieUncheckedCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentUncheckedCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagUncheckedCreateNestedManyWithoutMovieInput
    stats?: MovieStatsUncheckedCreateNestedOneWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutFavoritesInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutFavoritesInput, MovieUncheckedCreateWithoutFavoritesInput>
  }

  export type MovieUpsertWithoutFavoritesInput = {
    update: XOR<MovieUpdateWithoutFavoritesInput, MovieUncheckedUpdateWithoutFavoritesInput>
    create: XOR<MovieCreateWithoutFavoritesInput, MovieUncheckedCreateWithoutFavoritesInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutFavoritesInput, MovieUncheckedUpdateWithoutFavoritesInput>
  }

  export type MovieUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUpdateOneWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUncheckedUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUncheckedUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUncheckedUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUncheckedUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUncheckedUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUncheckedUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUncheckedUpdateManyWithoutMovieNestedInput
    stats?: MovieStatsUncheckedUpdateOneWithoutMovieNestedInput
  }

  export type MovieCreateWithoutStatsInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutStatsInput = {
    id?: string
    tmdbId: number
    titleEn: string
    titleJa: string
    titleZh?: string | null
    year: number
    director?: string | null
    duration?: number | null
    synopsis?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    voteAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutMovieInput
    movieCharacters?: MovieCharacterUncheckedCreateNestedManyWithoutMovieInput
    movieCrew?: MovieCrewUncheckedCreateNestedManyWithoutMovieInput
    reviews?: MovieReviewUncheckedCreateNestedManyWithoutMovieInput
    guideMovies?: WatchGuideMovieUncheckedCreateNestedManyWithoutMovieInput
    mediaContent?: MediaContentUncheckedCreateNestedManyWithoutMovieInput
    movieTags?: MovieTagUncheckedCreateNestedManyWithoutMovieInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutStatsInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutStatsInput, MovieUncheckedCreateWithoutStatsInput>
  }

  export type MovieUpsertWithoutStatsInput = {
    update: XOR<MovieUpdateWithoutStatsInput, MovieUncheckedUpdateWithoutStatsInput>
    create: XOR<MovieCreateWithoutStatsInput, MovieUncheckedCreateWithoutStatsInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutStatsInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutStatsInput, MovieUncheckedUpdateWithoutStatsInput>
  }

  export type MovieUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    titleEn?: StringFieldUpdateOperationsInput | string
    titleJa?: StringFieldUpdateOperationsInput | string
    titleZh?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    director?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    voteAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilities?: AvailabilityUncheckedUpdateManyWithoutMovieNestedInput
    movieCharacters?: MovieCharacterUncheckedUpdateManyWithoutMovieNestedInput
    movieCrew?: MovieCrewUncheckedUpdateManyWithoutMovieNestedInput
    reviews?: MovieReviewUncheckedUpdateManyWithoutMovieNestedInput
    guideMovies?: WatchGuideMovieUncheckedUpdateManyWithoutMovieNestedInput
    mediaContent?: MediaContentUncheckedUpdateManyWithoutMovieNestedInput
    movieTags?: MovieTagUncheckedUpdateManyWithoutMovieNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type AvailabilityCreateManyMovieInput = {
    id?: string
    url?: string | null
    price?: number | null
    currency?: string | null
    type: $Enums.AvailabilityType
    lastChecked: Date | string
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    platformId: string
    regionId: string
  }

  export type MovieCharacterCreateManyMovieInput = {
    id?: string
    characterId: string
    voiceActor?: string | null
    voiceActorJa?: string | null
    importance?: number
    createdAt?: Date | string
  }

  export type MovieCrewCreateManyMovieInput = {
    id?: string
    crewMemberId: string
    role: $Enums.CrewRole
    department?: string | null
    createdAt?: Date | string
  }

  export type MovieReviewCreateManyMovieInput = {
    id?: string
    title: string
    content: string
    author: string
    rating?: number | null
    reviewType: $Enums.ReviewType
    language?: string
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WatchGuideMovieCreateManyMovieInput = {
    id?: string
    guideId: string
    order: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type MediaContentCreateManyMovieInput = {
    id?: string
    title: string
    description?: string | null
    mediaType: $Enums.MediaType
    url: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    language?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieTagCreateManyMovieInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type UserFavoriteCreateManyMovieInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type AvailabilityUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: PlatformUpdateOneRequiredWithoutAvailabilitiesNestedInput
    region?: RegionUpdateOneRequiredWithoutAvailabilitiesNestedInput
  }

  export type AvailabilityUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platformId?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
  }

  export type AvailabilityUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platformId?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
  }

  export type MovieCharacterUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    voiceActor?: NullableStringFieldUpdateOperationsInput | string | null
    voiceActorJa?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneRequiredWithoutMovieCharactersNestedInput
  }

  export type MovieCharacterUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    voiceActor?: NullableStringFieldUpdateOperationsInput | string | null
    voiceActorJa?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCharacterUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    voiceActor?: NullableStringFieldUpdateOperationsInput | string | null
    voiceActorJa?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCrewUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCrewRoleFieldUpdateOperationsInput | $Enums.CrewRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crewMember?: CrewMemberUpdateOneRequiredWithoutMovieCrewNestedInput
  }

  export type MovieCrewUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewMemberId?: StringFieldUpdateOperationsInput | string
    role?: EnumCrewRoleFieldUpdateOperationsInput | $Enums.CrewRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCrewUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewMemberId?: StringFieldUpdateOperationsInput | string
    role?: EnumCrewRoleFieldUpdateOperationsInput | $Enums.CrewRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieReviewUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewType?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    language?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieReviewUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewType?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    language?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieReviewUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewType?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    language?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchGuideMovieUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guide?: WatchGuideUpdateOneRequiredWithoutMoviesNestedInput
  }

  export type WatchGuideMovieUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    guideId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchGuideMovieUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    guideId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaContentUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaContentUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaContentUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieTagUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutMovieTagsNestedInput
  }

  export type MovieTagUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieTagUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityCreateManyPlatformInput = {
    id?: string
    url?: string | null
    price?: number | null
    currency?: string | null
    type: $Enums.AvailabilityType
    lastChecked: Date | string
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movieId: string
    regionId: string
  }

  export type AvailabilityUpdateWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutAvailabilitiesNestedInput
    region?: RegionUpdateOneRequiredWithoutAvailabilitiesNestedInput
  }

  export type AvailabilityUncheckedUpdateWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieId?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
  }

  export type AvailabilityUncheckedUpdateManyWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieId?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
  }

  export type AvailabilityCreateManyRegionInput = {
    id?: string
    url?: string | null
    price?: number | null
    currency?: string | null
    type: $Enums.AvailabilityType
    lastChecked: Date | string
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movieId: string
    platformId: string
  }

  export type AvailabilityUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutAvailabilitiesNestedInput
    platform?: PlatformUpdateOneRequiredWithoutAvailabilitiesNestedInput
  }

  export type AvailabilityUncheckedUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
  }

  export type AvailabilityUncheckedUpdateManyWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
  }

  export type ContentReviewCreateManyVersionInput = {
    id?: string
    entityType: string
    entityId: string
    status: $Enums.ReviewStatus
    reviewer?: string | null
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ContentReviewUpdateWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentReviewUncheckedUpdateWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentReviewUncheckedUpdateManyWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCharacterCreateManyCharacterInput = {
    id?: string
    movieId: string
    voiceActor?: string | null
    voiceActorJa?: string | null
    importance?: number
    createdAt?: Date | string
  }

  export type MovieCharacterUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    voiceActor?: NullableStringFieldUpdateOperationsInput | string | null
    voiceActorJa?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutMovieCharactersNestedInput
  }

  export type MovieCharacterUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    voiceActor?: NullableStringFieldUpdateOperationsInput | string | null
    voiceActorJa?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCharacterUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    voiceActor?: NullableStringFieldUpdateOperationsInput | string | null
    voiceActorJa?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCrewCreateManyCrewMemberInput = {
    id?: string
    movieId: string
    role: $Enums.CrewRole
    department?: string | null
    createdAt?: Date | string
  }

  export type MovieCrewUpdateWithoutCrewMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCrewRoleFieldUpdateOperationsInput | $Enums.CrewRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutMovieCrewNestedInput
  }

  export type MovieCrewUncheckedUpdateWithoutCrewMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    role?: EnumCrewRoleFieldUpdateOperationsInput | $Enums.CrewRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCrewUncheckedUpdateManyWithoutCrewMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    role?: EnumCrewRoleFieldUpdateOperationsInput | $Enums.CrewRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchGuideMovieCreateManyGuideInput = {
    id?: string
    movieId: string
    order: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type WatchGuideMovieUpdateWithoutGuideInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutGuideMoviesNestedInput
  }

  export type WatchGuideMovieUncheckedUpdateWithoutGuideInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchGuideMovieUncheckedUpdateManyWithoutGuideInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieTagCreateManyTagInput = {
    id?: string
    movieId: string
    createdAt?: Date | string
  }

  export type MovieTagUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutMovieTagsNestedInput
  }

  export type MovieTagUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieTagUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}